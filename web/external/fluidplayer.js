/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 410:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(645);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_suggestedVideos_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(414);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(667);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3__);
// Imports




var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(858), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(924), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(373), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(212), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(928), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_5___ = new URL(/* asset import */ __webpack_require__(46), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_6___ = new URL(/* asset import */ __webpack_require__(276), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_suggestedVideos_css__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_4___);
var ___CSS_LOADER_URL_REPLACEMENT_5___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_5___);
var ___CSS_LOADER_URL_REPLACEMENT_6___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_6___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".fluid_video_wrapper {\n    animation: none;\n    animation-delay: 0;\n    animation-direction: normal;\n    animation-duration: 0;\n    animation-fill-mode: none;\n    animation-iteration-count: 1;\n    animation-name: none;\n    animation-play-state: running;\n    animation-timing-function: ease;\n    backface-visibility: visible;\n    background: 0;\n    background-attachment: scroll;\n    background-clip: border-box;\n    background-color: transparent;\n    background-image: none;\n    background-origin: padding-box;\n    background-position: 0 0;\n    background-position-x: 0;\n    background-position-y: 0;\n    background-repeat: repeat;\n    background-size: auto auto;\n    border: 0;\n    border-style: none;\n    border-width: medium;\n    border-color: inherit;\n    border-bottom: 0;\n    border-bottom-color: inherit;\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n    border-bottom-style: none;\n    border-bottom-width: medium;\n    border-collapse: separate;\n    border-image: none;\n    border-left: 0;\n    border-left-color: inherit;\n    border-left-style: none;\n    border-left-width: medium;\n    border-radius: 0;\n    border-right: 0;\n    border-right-color: inherit;\n    border-right-style: none;\n    border-right-width: medium;\n    border-spacing: 0;\n    border-top: 0;\n    border-top-color: inherit;\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n    border-top-style: none;\n    border-top-width: medium;\n    bottom: auto;\n    box-shadow: none;\n    -webkit-box-sizing: content-box;\n    -moz-box-sizing: content-box;\n    box-sizing: content-box;\n    caption-side: top;\n    clear: none;\n    clip: auto;\n    color: inherit;\n    columns: auto;\n    column-count: auto;\n    column-fill: balance;\n    column-gap: normal;\n    column-rule: medium none currentColor;\n    column-rule-color: currentColor;\n    column-rule-style: none;\n    column-rule-width: none;\n    column-span: 1;\n    column-width: auto;\n    content: normal;\n    counter-increment: none;\n    counter-reset: none;\n    cursor: auto;\n    direction: ltr;\n    display: inline;\n    empty-cells: show;\n    float: none;\n    font: normal;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    font-size: medium;\n    font-style: normal;\n    font-variant: normal;\n    font-weight: normal;\n    height: auto;\n    hyphens: none;\n    left: auto;\n    letter-spacing: normal;\n    line-height: normal;\n    list-style: none;\n    list-style-image: none;\n    list-style-position: outside;\n    list-style-type: disc;\n    margin: 0;\n    margin-bottom: 0;\n    margin-left: 0;\n    margin-right: 0;\n    margin-top: 0;\n    max-height: none;\n    max-width: none;\n    min-height: 0;\n    min-width: 0;\n    opacity: 1;\n    orphans: 0;\n    outline: 0;\n    outline-color: invert;\n    outline-style: none;\n    outline-width: medium;\n    overflow: visible;\n    overflow-x: visible;\n    overflow-y: visible;\n    padding: 0;\n    padding-bottom: 0;\n    padding-left: 0;\n    padding-right: 0;\n    padding-top: 0;\n    page-break-after: auto;\n    page-break-before: auto;\n    page-break-inside: auto;\n    perspective: none;\n    perspective-origin: 50% 50%;\n    position: static;\n    /* May need to alter quotes for different locales (e.g fr) */\n    quotes: '\\201C' '\\201D' '\\2018' '\\2019';\n    right: auto;\n    tab-size: 8;\n    table-layout: auto;\n    text-align: inherit;\n    text-align-last: auto;\n    text-decoration: none;\n    text-decoration-color: inherit;\n    text-decoration-line: none;\n    text-decoration-style: solid;\n    text-indent: 0;\n    text-shadow: none;\n    text-transform: none;\n    top: auto;\n    transform: none;\n    transform-style: flat;\n    transition: none;\n    transition-delay: 0s;\n    transition-duration: 0s;\n    transition-property: none;\n    transition-timing-function: ease;\n    unicode-bidi: normal;\n    vertical-align: baseline;\n    visibility: visible;\n    white-space: normal;\n    widows: 0;\n    width: auto;\n    word-spacing: normal;\n    z-index: auto;\n    -webkit-tap-highlight-color: transparent;\n}\n\n.fluid_video_wrapper canvas {\n    pointer-events: none;\n}\n\n.fluid_video_wrapper,\n.fluid_video_wrapper * {\n    -webkit-box-sizing: content-box;\n    -moz-box-sizing: content-box;\n    box-sizing: content-box;\n}\n\n.fluid_video_wrapper:after, .fluid_video_wrapper:before {\n    content: none;\n}\n\n.fluid_video_wrapper {\n    position: relative;\n    display: inline-block;\n}\n\n.fluid_video_wrapper video {\n    position: relative;\n    background-color: #000000;\n    display: block;\n}\n\n.fluid_video_wrapper .vast_video_loading {\n    display: table;\n    text-align: center;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    pointer-events: auto;\n    z-index: 1;\n}\n\n.fluid_video_wrapper .vast_video_loading:before {\n    background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n    background-position: center, center;\n    background-repeat: no-repeat, repeat;\n    background-color: rgba(0, 0, 0, 0.2);\n    content: '';\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    top: 0;\n    left: 0;\n}\n\n.skip_button {\n    position: absolute;\n    bottom: 50px;\n    right: 0;\n    background-color: rgba(0, 0, 0, 0.7);\n    padding: 13px 21px 13px 21px;\n}\n\n.skip_button, .skip_button a {\n    color: #ffffff;\n    text-decoration: none;\n    cursor: pointer;\n    z-index: 10;\n    font-size: 13px;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    font-weight: normal;\n    white-space: nowrap;\n    text-align: start;\n}\n\n.skip_button a span.skip_button_icon {\n    display: inline-block;\n    text-align: left;\n    width: 21px;\n    position: relative;\n    bottom: 20px;\n}\n\n.skip_button a span.skip_button_icon:before {\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") no-repeat;\n    position: absolute;\n    height: 18px;\n    width: 18px;\n    top: 6px;\n    content: \"\";\n    opacity: 0.8;\n    -webkit-transition: opacity 0.3s ease-in-out;\n    -moz-transition: opacity 0.3s ease-in-out;\n    -ms-transition: opacity 0.3s ease-in-out;\n    -o-transition: opacity 0.3s ease-in-out;\n    transition: opacity 0.3s ease-in-out;\n    background-position: -122px -57px;\n}\n\n.skip_button a span.skip_button_icon:before:hover {\n    opacity: 1;\n}\n\n.skip_button_disabled {\n    cursor: default !important;\n    padding: 13px 21px 13px 21px;\n}\n\n.close_button {\n    position: absolute;\n    background: #000000 url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") no-repeat scroll center center;\n    height: 16px;\n    width: 16px;\n    top: 0;\n    right: 0;\n    background-size: 18px 18px;\n    cursor: pointer;\n    padding: 1px;\n    z-index: 31;\n}\n\n.close_button:hover {\n    background-color: #000000;\n    border: 1px solid #ffffff;\n}\n\n.vast_clickthrough_layer {\n    /*IE Fix*/\n    background-color: white;\n    opacity: 0;\n}\n\n.fluid_ad_playing {\n    position: absolute;\n    background-color: black;\n    opacity: 0.8;\n    border-radius: 1px;\n    color: #ffffff;\n    font-size: 13px;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    font-weight: normal;\n    white-space: nowrap;\n    text-align: start;\n    line-height: 18px;\n    z-index: 10;\n    padding: 13px 21px 13px 21px;\n}\n\n.fluid_ad_cta {\n    position: absolute;\n    background-color: rgba(0, 0, 0, 0.7);\n    color: #ffffff;\n    font-size: 13px;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    font-weight: normal;\n    text-align: right;\n    cursor: pointer;\n    z-index: 10;\n    padding: 13px 21px 13px 13px;\n    max-width: 50%;\n}\n\n.fluid_ad_cta.left {\n    text-align: left;\n}\n\n.fluid_ad_cta a {\n    text-decoration: none;\n    color: #ffffff;\n    line-height: 18px;\n}\n\n.fluid_ad_cta:hover,\n.skip_button:not(.skip_button_disabled):hover {\n    background-color: rgba(0, 0, 0, 1);\n}\n\n.fluid_html_on_pause,\n.fluid_html_on_pause_container,\n.fluid_pseudo_poster {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    margin: auto;\n    z-index: 0;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    pointer-events: none;\n}\n\n.fluid_html_on_pause_container *,\n.fluid_html_on_pause * {\n    pointer-events: auto;\n}\n\n/*Mobile Layout*/\n.fluid_video_wrapper.mobile .skip_button {\n    bottom: 50px;\n}\n\n/*\n.fluid_video_wrapper.mobile .fluid_ad_cta {\n        bottom: 125px;\n}\n*/\n.fluid_initial_play {\n    width: 60px;\n    height: 60px;\n    border-radius: 50px;\n    cursor: pointer;\n}\n\n.fluid_initial_play_button {\n    margin-top: 15px;\n    margin-left: 23px;\n    border-style: solid;\n    border-width: 15px 0 15px 21px;\n    border-color: transparent transparent transparent #ffffff;\n}\n\n.fluid_initial_pause_button {\n    margin-top: 15px;\n    margin-left: 17px;\n    width: 8px;\n    height: 31px;\n    border: 9px solid white;\n    border-top: 0;\n    border-bottom: 0;\n}\n\n.fluid_timeline_preview {\n    bottom: 11px;\n    color: #ffffff;\n    font-size: 13px;\n    line-height: 18px;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    font-weight: normal;\n    text-align: start;\n    padding: 13px 21px 13px 21px;\n    background-color: rgba(0, 0, 0, 0.85);\n    border-radius: 1px;\n}\n\n/* Duration */\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_fluid_control_duration {\n    display: inline-block;\n    position: absolute;\n    left: 32px;\n    height: 24px;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    font-size: 13px;\n    font-weight: normal;\n    font-style: normal;\n    text-align: left;\n    text-decoration: none;\n    line-height: 21px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_fluid_control_duration.cardboard_time {\n    left: 13px;\n    top: -15px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_fluid_control_duration.cardboard_time .ad_timer_prefix {\n    color: #F2C94C;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .ad_countdown .ad_timer_prefix {\n    color: #F2C94C;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .ad_countdown {\n    /*display: none;*/\n    position: absolute;\n    right: 0;\n    width: 75px;\n    bottom: 5px;\n    height: 24px;\n    color: red;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    font-size: 13px;\n    font-weight: normal;\n    font-style: normal;\n    text-align: left;\n    text-decoration: none;\n    line-height: 21px;\n}\n\n.initial_controls_show {\n    visibility: visible !important;\n    opacity: 1 !important;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container {\n    color: white;\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    background: -moz-linear-gradient(top, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.6) 100%); /* FF3.6-15 */\n    background: -webkit-linear-gradient(top, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.6) 100%); /* Chrome10-25,Safari5.1-6 */\n    background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.6) 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */\n    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#ad000000', GradientType=0); /* IE6-9 */\n    height: 100%;\n    width: 100%;\n    z-index: 0;\n    pointer-events: none;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container .fluid_vr_joystick_panel {\n    height: 96px;\n    width: 72px;\n    left: 10px;\n    top: 10px;\n    position: absolute;\n    background: rgba(0, 0, 0, 0.7);\n    text-align: center;\n    border-radius: 6px;\n    overflow: hidden;\n    pointer-events: auto;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container .fluid_vr_joystick_panel .fluid_vr_button {\n    cursor: pointer;\n    display: inline-block;\n    text-align: left;\n    height: 24px;\n    width: 24px;\n    position: relative;\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") no-repeat;\n    opacity: 0.8;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container .fluid_vr_joystick_panel .fluid_vr_button:hover {\n    opacity: 1;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container .fluid_vr_joystick_panel .fluid_vr_joystick_up {\n    background-position: -336px -55px;\n    -webkit-transform: rotate(270deg); /* Chrome, Opera 15+, Safari 3.1+ */\n    -ms-transform: rotate(270deg); /* IE 9 */\n    transform: rotate(270deg); /* Firefox 16+, IE 10+, Opera  */\n    display: block;\n    left: calc(50% - 12px);\n    top: 0;\n    position: absolute;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container .fluid_vr_joystick_panel .fluid_vr_joystick_left {\n    background-position: -336px -55px;\n    -webkit-transform: rotate(180deg); /* Chrome, Opera 15+, Safari 3.1+ */\n    -ms-transform: rotate(1890deg); /* IE 9 */\n    transform: rotate(180deg); /* Firefox 16+, IE 10+, Opera  */\n    display: block;\n    left: 0;\n    top: 24px;\n    position: absolute;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container .fluid_vr_joystick_panel .fluid_vr_joystick_right {\n    background-position: -336px -55px;\n    -webkit-transform: rotate(0deg); /* Chrome, Opera 15+, Safari 3.1+ */\n    -ms-transform: rotate(0deg); /* IE 9 */\n    transform: rotate(0deg); /* Firefox 16+, IE 10+, Opera  */\n    display: block;\n    right: 0;\n    top: 24px;\n    position: absolute;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container .fluid_vr_joystick_panel .fluid_vr_joystick_down {\n    background-position: -336px -55px;\n    -webkit-transform: rotate(90deg); /* Chrome, Opera 15+, Safari 3.1+ */\n    -ms-transform: rotate(90deg); /* IE 9 */\n    transform: rotate(90deg); /* Firefox 16+, IE 10+, Opera  */\n    display: block;\n    left: calc(50% - 12px);\n    top: 48px;\n    position: absolute;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container .fluid_vr_joystick_panel .fluid_vr_joystick_zoomdefault {\n    background-position: -336px -17px;\n    top: 72px;\n    -webkit-transform: rotate(0deg); /* Chrome, Opera 15+, Safari 3.1+ */\n    -ms-transform: rotate(0deg); /* IE 9 */\n    transform: rotate(0deg); /* Firefox 16+, IE 10+, Opera  */\n    position: absolute;\n    left: calc(50% - 12px);\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container .fluid_vr_joystick_panel .fluid_vr_joystick_zoomin {\n    background-position: -305px -55px;\n    top: 72px;\n    -webkit-transform: rotate(0deg); /* Chrome, Opera 15+, Safari 3.1+ */\n    -ms-transform: rotate(0deg); /* IE 9 */\n    transform: rotate(0deg); /* Firefox 16+, IE 10+, Opera  */\n    position: absolute;\n    right: 0;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vr_container .fluid_vr_joystick_panel .fluid_vr_joystick_zoomout {\n    background-position: -305px -17px;\n    top: 72px;\n    -webkit-transform: rotate(0deg); /* Chrome, Opera 15+, Safari 3.1+ */\n    -ms-transform: rotate(0deg); /* IE 9 */\n    transform: rotate(0deg); /* Firefox 16+, IE 10+, Opera  */\n    position: absolute;\n    left: 0;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container.fluid_vr_controls_container {\n    width: 50% !important;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container.fluid_vr2_controls_container {\n    width: 50% !important;\n    left: 50%;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container {\n    color: white;\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    background: -moz-linear-gradient(top, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.6) 100%); /* FF3.6-15 */\n    background: -webkit-linear-gradient(top, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.6) 100%); /* Chrome10-25,Safari5.1-6 */\n    background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.6) 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */\n    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#ad000000', GradientType=0); /* IE6-9 */\n    height: 53px;\n    z-index: 1;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vpaid_iframe {\n    position: absolute;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    left: 0;\n    z-index: -10;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vpaid_nonlinear_slot_iframe {\n    z-index: 30;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_vpaid_slot {\n    position: absolute !important;\n    top: 0 !important;\n    width: 100% !important;\n    height: 100% !important;\n    left: 0 !important;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_subtitles_container {\n    color: white;\n    position: absolute;\n    bottom: 46px;\n    left: 0;\n    right: 0;\n    height: auto;\n    z-index: 1;\n    text-align: center;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_subtitles_container div {\n    display: inline;\n    background: black;\n    color: white;\n    font-size: 1em;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    padding: 0.25em;\n    border-radius: 4px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fade_out {\n    visibility: hidden;\n    opacity: 0;\n    -webkit-transition: visibility 0.5s, opacity 0.5s; /* Safari */\n    transition: visibility 0.5s, opacity 0.5s;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fade_in {\n    visibility: visible;\n    opacity: 1;\n    -webkit-transition: visibility 0.5s, opacity 0.5s; /* Safari */\n    transition: visibility 0.5s, opacity 0.5s;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default.pseudo_fullscreen {\n    width: 100% !important;\n    height: 100% !important;\n    top: 0;\n    left: 0;\n    position: fixed;\n    z-index: 99999;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default:-webkit-full-screen {\n    width: 100% !important;\n    height: 100% !important;\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default:-ms-fullscreen {\n    width: 100% !important;\n    height: 100% !important;\n    position: absolute;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_context_menu {\n    background-color: #000000;\n    color: #ffffff;\n    font-size: 13px;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    font-weight: normal;\n    white-space: nowrap;\n    text-align: start;\n    z-index: 11;\n    opacity: 0.8;\n    border-radius: 1px;\n}\n\n/* IE 10+ */\n_:-ms-lang(x),\n.fluid_video_wrapper.fluid_player_layout_default .fluid_context_menu {\n    text-align: left;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_context_menu ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_context_menu ul li {\n    padding: 13px 71px 13px 21px;\n    cursor: pointer;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_context_menu ul li + li {\n    border-top: 1px solid #000000;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_context_menu ul li:hover {\n    background-color: #1e1e1e;\n    color: #fbfaff;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_left {\n    width: 24px;\n    left: 20px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container.skip_controls .fluid_controls_left {\n    width: 80px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button {\n    width: 24px;\n    height: 24px;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right {\n    left: 60px;\n    right: 20px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container.skip_controls .fluid_controls_right {\n    left: 110px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_left,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right {\n    position: absolute;\n    height: 24px;\n    top: 23px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container {\n    height: 14px;\n    position: absolute;\n    left: 13px;\n    right: 13px;\n    z-index: 1;\n    top: 8px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container .fluid_controls_progress {\n    position: absolute;\n    top: 5px;\n    width: 100%;\n    height: 4px;\n    background-color: rgba(255, 255, 255, 0.25);\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container .fluid_controls_buffered {\n    position: absolute;\n    top: 5px;\n    width: 0;\n    height: 3px;\n    background-color: rgba(255, 255, 255, 0.5);\n    z-index: -1;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container .fluid_controls_progress,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container .fluid_controls_progress .fluid_controls_currentprogress {\n    position: absolute;\n    height: 3px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container:hover .fluid_controls_progress,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container:hover .fluid_controls_buffered,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container:hover .fluid_controls_ad_markers_holder {\n    margin-top: -1px;\n    height: 5px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container:hover .fluid_controls_progress .fluid_controls_currentprogress {\n    height: 5px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container .fluid_timeline_preview_container {\n    border: 1px solid #262626;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container .fluid_timeline_preview_container, .fluid_timeline_preview_container_shadow {\n    bottom: 14px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container.fluid_slider .fluid_controls_progress .fluid_controls_currentprogress .fluid_controls_currentpos {\n    background-color: white;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container.fluid_slider .fluid_controls_progress .fluid_controls_currentprogress .fluid_controls_currentpos,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container.fluid_ad_slider .fluid_controls_progress .fluid_controls_currentprogress .fluid_controls_currentpos {\n    opacity: 0;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container.fluid_slider:hover .fluid_controls_progress .fluid_controls_currentprogress .fluid_controls_currentpos {\n    opacity: 1;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container.fluid_slider .fluid_controls_progress .fluid_controls_currentprogress .fluid_controls_currentpos {\n    -webkit-transition: opacity 0.3s; /* Safari */\n    transition: opacity 0.3s;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_ad_markers_holder {\n    position: absolute;\n    top: 5px;\n    width: 100%;\n    height: 3px;\n    z-index: 2;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_ad_marker {\n    position: absolute;\n    background-color: #FFCC00;\n    height: 100%;\n    width: 6px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_control_volume_container {\n    height: 24px;\n    width: 56px;\n    left: 25px;\n    top: -1px;\n    z-index: 2;\n    opacity: 0.8;\n    -webkit-transition: opacity 0.3s ease-in-out;\n    -moz-transition: opacity 0.3s ease-in-out;\n    -ms-transition: opacity 0.3s ease-in-out;\n    -o-transition: opacity 0.3s ease-in-out;\n    transition: opacity 0.3s ease-in-out;\n    display: none;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_control_volume_container:hover {\n    opacity: 1;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_control_volume_container .fluid_control_volume {\n    position: relative;\n    height: 3px;\n    width: 100%;\n    margin-top: 10px;\n    background-color: rgba(171, 172, 172, 0.68);\n    z-index: 3;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_control_volume_container .fluid_control_volume .fluid_control_currentvolume {\n    float: left;\n    background-color: white;\n    height: 3px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_control_volume_container .fluid_control_volume .fluid_control_currentvolume .fluid_control_volume_currentpos {\n    background-color: white;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container .fluid_controls_progress .fluid_controls_currentpos {\n    right: -4px;\n    z-index: 3;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_control_volume_container .fluid_control_volume .fluid_control_currentvolume .fluid_control_volume_currentpos,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container .fluid_controls_progress .fluid_controls_currentpos {\n    width: 11px;\n    height: 11px;\n    position: absolute;\n    top: -4px;\n    border-radius: 6px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_progress_container .fluid_controls_progress .fluid_controls_currentpos {\n    width: 13px;\n    height: 13px;\n    position: absolute;\n    top: -4px;\n    border-radius: 6px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container.no_volume_bar .fluid_controls_right .fluid_control_volume_container {\n    display: none;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_slider {\n    cursor: pointer;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container div div {\n    display: block;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button.fluid_button_fullscreen,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button.fluid_button_fullscreen_exit,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button.fluid_button_mini_player {\n    float: right;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_video_source,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_subtitles,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_cardboard {\n    font-size: 13px;\n    height: 24px;\n    line-height: 24px;\n    float: right;\n    cursor: pointer;\n    position: relative;\n    text-align: right;\n    -webkit-touch-callout: none; /* iOS Safari */\n    -webkit-user-select: none; /* Safari */\n    -khtml-user-select: none; /* Konqueror HTML */\n    -moz-user-select: none; /* Firefox */\n    -ms-user-select: none; /* Internet Explorer/Edge */\n    user-select: none;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_video_source .fluid_video_sources_title,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_subtitles .fluid_subtitles_title {\n    width: 80px;\n    overflow: hidden;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_subtitles .fluid_subtitles_list,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_video_source .fluid_video_sources_list,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_video_playback_rates {\n    position: absolute;\n    bottom: 25px;\n    right: 3px;\n    z-index: 888888;\n    opacity: 99%;\n    background-color: rgba(0, 0, 0, 1);\n    border-radius: 2px;\n    color: #ffffff;\n    font-size: 13px;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    font-weight: normal;\n    white-space: nowrap;\n    text-align: start;\n    width: max-content;\n    padding: 0.5em;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_subtitles .fluid_subtitles_list .fluid_subtitle_list_item,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_video_source .fluid_video_sources_list .fluid_video_source_list_item {\n    padding: 12px 34px 12px 24px;\n    line-height: 15px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_video_source .fluid_video_sources_list .fluid_video_source_list_item:hover,\n.fluid_video_playback_rates_item:hover,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_subtitles .fluid_subtitles_list .fluid_subtitle_list_item:hover {\n    background-color: #3a3a3a;\n}\n\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_control_volume_container,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button.fluid_button_volume,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button.fluid_button_mute {\n    position: absolute;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button.fluid_button_volume,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button.fluid_button_mute {\n    left: -10px;\n}\n\n/* Button Icons */\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_play,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_pause,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_skip_back,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_skip_forward,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_volume,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_mute,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_video_source,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_fullscreen,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_fullscreen_exit,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_playback_rate,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_download,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_theatre,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_subtitles,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_cardboard,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_mini_player {\n    display: inline-block;\n    text-align: left;\n    height: 24px;\n    width: 24px;\n    position: relative;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_play:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_pause:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_skip_back:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_skip_forward:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_volume:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_mute:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_video_source:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_fullscreen:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_fullscreen_exit:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_playback_rate:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_download:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_theatre:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_subtitles:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_cardboard:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_mini_player:before{\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") no-repeat;\n    position: absolute;\n    height: 24px;\n    width: 24px;\n    top: 1px;\n    left: 5px;\n    content: \"\";\n    opacity: 0.8;\n    -webkit-transition: opacity 0.3s ease-in-out;\n    -moz-transition: opacity 0.3s ease-in-out;\n    -ms-transition: opacity 0.3s ease-in-out;\n    -o-transition: opacity 0.3s ease-in-out;\n    transition: opacity 0.3s ease-in-out;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_play:before {\n    background-position: -15px -19px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_pause:before {\n    background-position: -15px -57px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_volume:before {\n    background-position: -52px -19px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_mute:before {\n    background-position: -52px -57px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_fullscreen:before {\n    background-position: -88px -19px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_fullscreen_exit:before {\n    background-position: -88px -57px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_video_source:before {\n    background-position: -122px -19px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_playback_rate:before {\n    background-position: -232px -19px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_download:before {\n    background-position: -194px -18px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_theatre:before {\n    background-position: -195px -56px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_subtitles:before {\n    background-position: -269px -19px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_cardboard:before {\n    background-position: -269px -56px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_skip_back:before {\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ") no-repeat;\n    background-position: -2px -2px;\n}\n\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_skip_forward:before {\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ") no-repeat;\n    background-position: -2px -2px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_mini_player:before {\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ") no-repeat 0 0;\n    background-size: 20px;\n}\n\n.fluid_video_wrapper.fluid_mini_player_mode .fluid_controls_container .fluid_button.fluid_button_mini_player:before {\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_6___ + ") no-repeat 0 0;\n    background-size: 20px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_skip_back {\n    margin-left: 5px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_video_source:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_fullscreen_exit:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_fullscreen:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_mute:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_volume:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_pause:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_play:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_skip_back:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_skip_forward:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_playback_rate:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_download:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_theatre:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_subtitles:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_cardboard:hover:before,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_mini_player:hover:before {\n    opacity: 1;\n}\n\n.fp_title {\n    position: absolute;\n    top: 10px;\n    left: 10px;\n    color: #ffffff;\n    font-size: 15px;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    font-weight: normal;\n    white-space: nowrap;\n}\n\n/* Pulse class and keyframe animation */\n.transform-active {\n    animation: flash 1s infinite;\n    display: inline-block !important;\n    opacity: 0;\n}\n\n@-webkit-keyframes flash {\n    0% {\n        opacity: 0.6;\n        -webkit-box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.5);\n    }\n    70% {\n        -webkit-box-shadow: 0 0 0 20px rgba(255, 255, 255, 0);\n    }\n    100% {\n        opacity: 0;\n        display: none;\n        -webkit-box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);\n    }\n}\n\n@keyframes flash {\n    0% {\n        opacity: 0.6;\n        -moz-box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.5);\n        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.6);\n    }\n    70% {\n        -moz-box-shadow: 0 0 0 20px rgba(255, 255, 255, 0);\n        box-shadow: 0 0 0 20px rgba(255, 255, 255, 0);\n    }\n    100% {\n        opacity: 0;\n        display: none;\n        -moz-box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);\n        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);\n    }\n}\n\n.fluid_nonLinear_top, .fluid_nonLinear_middle, .fluid_nonLinear_bottom {\n    flex-direction: column;\n    align-items: center;\n    cursor: pointer;\n    display: flex;\n    vertical-align: middle;\n    align-content: center;\n    border: 1px solid #777777;\n    position: absolute;\n    left: 50%;\n    margin-right: -50%;\n    background-color: rgba(0, 0, 0, 0.7);\n}\n\n.fluid_nonLinear_top {\n    top: 20px;\n    transform: translate(-50%);\n}\n\n.fluid_nonLinear_middle {\n    top: 50%;\n    transform: translate(-50%, -50%);\n}\n\n.fluid_nonLinear_bottom {\n    bottom: 50px;\n    transform: translate(-50%);\n}\n\n.fluid_vpaidNonLinear_top, .fluid_vpaidNonLinear_middle, .fluid_vpaidNonLinear_bottom {\n    flex-direction: column;\n    align-items: center;\n    cursor: pointer;\n    vertical-align: middle;\n    align-content: center;\n    position: absolute;\n    display: flex;\n}\n\n.fluid_vpaidNonLinear_frame {\n    margin: auto;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\n.fluid_vpaidNonLinear_top {\n    top: 20px;\n}\n\n.fluid_vpaidNonLinear_middle {\n    top: 50%;\n}\n\n.fluid_vpaidNonLinear_bottom {\n    bottom: 50px;\n}\n\n.add_icon_clickthrough {\n    color: #F2C94C;\n    line-height: 18px;\n    text-overflow: ellipsis;\n    max-width: 100%;\n    white-space: nowrap;\n    overflow: hidden;\n    display: inline-block;\n}\n\n.add_icon_clickthrough:before {\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") no-repeat;\n    height: 18px;\n    width: 18px;\n    top: 30px;\n    padding: 3px 22px 0 0;\n    content: \"\";\n    background-position: -162px -57px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_theatre,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_playback_rate,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_video_source,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_download,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_subtitles,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_cardboard {\n    float: right;\n    padding-right: 5px;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_theatre,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_playback_rate,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_video_source,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_download,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_subtitles,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_button.fluid_button_cardboard {\n    display: none;\n}\n\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_subtitles .fluid_subtitles_list,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_button_video_source .fluid_video_sources_list,\n.fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_video_playback_rates {\n    z-index: 888888 !important;\n    opacity: 0.9 !important;\n}\n\n.fluid_video_playback_rates_item {\n    padding: 9px 25px 9px 25px;\n    line-height: 15px;\n    text-align: center;\n}\n\n.fluid_theatre_mode {\n    position: fixed;\n    float: left;\n    top: 0;\n    z-index: 10;\n    box-shadow: 0px 15px 25px rgba(0, 0, 0, 0.8);\n}\n\n.fluid_mini_player_mode {\n    position: fixed;\n    bottom: 10px;\n    right: 10px;\n    z-index: 10;\n}\n\n.source_button_icon {\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") no-repeat;\n    float: left;\n    cursor: pointer;\n    height: 18px;\n    width: 18px;\n    background-position: -164px -21px;\n    opacity: 0;\n}\n\n.subtitle_button_icon {\n    background: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") no-repeat;\n    float: left;\n    cursor: pointer;\n    height: 18px;\n    width: 18px;\n    background-position: -164px -21px;\n    opacity: 0;\n}\n\n.source_selected {\n    opacity: 1 !important;\n}\n\n.subtitle_selected {\n    opacity: 1 !important;\n}\n\n@media only screen and (min-device-width: 375px) {\n    .fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_fluid_control_duration {\n        left: 105px;\n    }\n\n    .fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container.no_volume_bar .fluid_fluid_control_duration {\n        left: 32px;\n    }\n\n    .fluid_video_wrapper.fluid_player_layout_default .fluid_controls_container .fluid_controls_right .fluid_control_volume_container {\n        display: block;\n    }\n}\n\n.fp_logo {\n    visibility: hidden;\n    opacity: 0;\n    -webkit-transition: visibility 0.3s ease-in-out, opacity 0.3s ease-in-out;\n    -moz-transition: visibility 0.3s ease-in-out, opacity 0.3s ease-in-out;\n    -ms-transition: visibility 0.3s ease-in-out, opacity 0.3s ease-in-out;\n    -o-transition: visibility 0.3s ease-in-out, opacity 0.3s ease-in-out;\n    transition: visibility 0.3s ease-in-out, opacity 0.3s ease-in-out;\n}\n\n.fp_hd_source::before {\n    font-weight: bolder;\n    font-size: 6pt;\n    content: 'HD';\n    padding-left: 3px;\n}\n\n/** MiniPlayer */\n\n.fluid_video_wrapper.fluid_player_layout_default .mini-player-close-button-wrapper {\n    display: none;\n}\n\n.fluid_video_wrapper.fluid_mini_player_mode .mini-player-close-button-wrapper {\n    position: absolute;\n    background: rgb(0,0,0);\n    background: linear-gradient(45deg, rgba(0,0,0,0) 90%, rgba(0,0,0,0.6) 110%);\n    height: 100%;\n    width: 100%;\n    top: 0;\n    right: 0;\n    z-index: 31;\n    display: block;\n    opacity: 0;\n    -webkit-transition: opacity 0.3s ease-in-out;\n    -moz-transition: opacity 0.3s ease-in-out;\n    -ms-transition: opacity 0.3s ease-in-out;\n    -o-transition: opacity 0.3s ease-in-out;\n    transition: opacity 0.3s ease-in-out;\n    pointer-events: none;\n}\n\n.fluid_video_wrapper.fluid_mini_player_mode .mini-player-close-button {\n    position: absolute;\n    background: transparent url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") no-repeat scroll center center;\n    height: 22px;\n    width: 22px;\n    top: 6px;\n    right: 6px;\n    background-size: 22px;\n    cursor: pointer;\n    z-index: 32;\n    display: block;\n    pointer-events: all;\n}\n\n.fluid_video_wrapper.fluid_mini_player_mode:hover .mini-player-close-button-wrapper {\n    opacity: 1;\n}\n\n.fluid_video_wrapper.fluid_mini_player_mode .disable-mini-player-mobile {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: none;\n}\n\n.fluidplayer-miniplayer-player-placeholder {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: #fff;\n    font-size: 1.5rem;\n    font-family: -apple-system, BlinkMacSystemFont, 'segoe ui', roboto, oxygen-sans, ubuntu, cantarell, 'helvetica neue', 'arial', sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';\n    background: #000 url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ") no-repeat 50% calc(50% - 48px);\n    background-size: 48px;\n    cursor: pointer;\n}\n\n.fluid_video_wrapper.fluid_mini_player_mode.fluid_video_wrapper.fluid_mini_player_mode--top-left {\n    top: 10px;\n    left: 10px;\n}\n\n.fluid_video_wrapper.fluid_mini_player_mode.fluid_video_wrapper.fluid_mini_player_mode--top-right {\n    top: 10px;\n    right: 10px;\n}\n\n.fluid_video_wrapper.fluid_mini_player_mode.fluid_video_wrapper.fluid_mini_player_mode--bottom-left {\n    bottom: 10px;\n    left: 10px;\n}\n\n.fluid_video_wrapper.fluid_mini_player_mode.fluid_video_wrapper.fluid_mini_player_mode--bottom-right {\n    bottom: 10px;\n    right: 10px;\n}\n\n@media screen and (max-width: 768px) {\n    .fluid_video_wrapper.fluid_mini_player_mode > *:not(video, .ad_countdown, .fluid_nonLinear_ad, .disable-mini-player-mobile) {\n        display: none;\n    }\n\n    .fluid_video_wrapper.fluid_mini_player_mode .fluid_nonLinear_ad {\n        z-index: 100;\n    }\n\n    .fluid_video_wrapper.fluid_mini_player_mode .fluid_nonLinear_bottom {\n        bottom: 16px;\n    }\n\n    .fluid_video_wrapper.fluid_mini_player_mode .fluid_nonLinear_top {\n        top: 16px;\n    }\n\n    .fluid_video_wrapper.fluid_mini_player_mode .ad_countdown {\n        display: inline-block !important;\n    }\n\n    .fluid_video_wrapper.fluid_mini_player_mode .disable-mini-player-mobile {\n        display: block;\n        touch-action: none;\n    }\n\n    .fluidplayer-miniplayer-player-placeholder {\n        font-size: 1.25rem !important;\n        background-size: 32px !important;\n        background-position-y: calc(50% - 32px) !important;\n    }\n}\n\n.fluid_video_wrapper .fluid_player_skip_offset {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    pointer-events: none;\n}\n\n.fluid_video_wrapper .fluid_player_skip_offset__backward {\n    display: flex;\n    align-items: center;\n    margin: 10% 10% 10% 0;\n}\n\n.fluid_video_wrapper .fluid_player_skip_offset__backward-icon {\n    background: rgba(0, 0, 0, .5) url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ") no-repeat -2px 3px;\n    width: 150px;\n    height: 150px;\n    background-size: contain;\n    opacity: 0;\n    transition: opacity 400ms ease-in;\n    border-radius: 150px;\n    margin-left: 20%;\n    pointer-events: none;\n    background-origin: content-box;\n    padding: 10px;\n}\n\n.fluid_video_wrapper .fluid_player_skip_offset__forward {\n    display: flex;\n    align-items: center;\n    flex-direction: row-reverse;\n    margin: 10% 0 10% 10%;\n}\n\n.fluid_video_wrapper .fluid_player_skip_offset__forward-icon {\n    background: rgba(0, 0, 0, .5) url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ") no-repeat -2px 3px;\n    width: 150px;\n    height: 150px;\n    background-size: cover;\n    opacity: 0;\n    transition: opacity 400ms ease-in;\n    border-radius: 150px;\n    margin-right: 20%;\n    pointer-events: none;\n    background-origin: content-box;\n    padding: 10px;\n}\n\n.fluid_video_wrapper .fluid_player_skip_offset__backward-icon.animate,\n.fluid_video_wrapper .fluid_player_skip_offset__forward-icon.animate {\n    opacity: 1;\n    transition: opacity 150ms ease-out;\n}\n\n@media screen and (max-width: 768px) {\n    .fluid_video_wrapper .fluid_player_skip_offset__backward-icon,\n    .fluid_video_wrapper .fluid_player_skip_offset__forward-icon {\n        width: 50px;\n        height: 50px;\n        border-radius: 50px;\n        background-position-x: 0;\n        background-position-y: 0;\n        padding: 5px;\n    }\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__["Z"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 414:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(645);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".suggested_tile_grid {\n    --thumbnail-height: 120px;\n  }\n\n.suggested_tile_grid {\n    position: absolute;\n    left: 0;\n    width: 100%;\n    z-index: 100;\n    display: flex;\n    height: var(--thumbnail-height);\n    overflow-x: auto;\n    overflow-y: hidden;\n    justify-content: flex-start;\n    bottom: 53px;\n    top: initial;\n    column-gap: 10px;\n    row-gap: 10px;\n    white-space: nowrap;\n}\n\n.suggested_tile {\n    aspect-ratio: 16/9;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    position: relative;\n    border-radius: 2px;\n    flex-shrink: 0;\n    width: calc(var(--thumbnail-height) * (16/9));\n    height: var(--thumbnail-height);\n\n    img {\n        height: -webkit-fill-available;\n    }\n}\n\n.suggested_tile_image {\n    max-width: 100%;\n    max-height: 100%;\n}\n\n.suggested_tile:first-child {\n    margin-left: 20px;\n}\n\n.suggested_tile:last-child {\n    margin-right: 20px;\n}\n\n.suggested_tile_overlay {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.6);\n    color: #ffffff;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    transition: opacity 0.25s;\n}\n\n.suggested_tile_overlay .suggested_tile_title {\n    position: absolute;\n    bottom: 0px;\n    left: 10px;\n}\n\n.suggested_tile_overlay--blur {\n    backdrop-filter: blur(5px);\n}\n\n.suggested_tile_overlay>* {\n    transform: translateY(20px);\n    transition: transform 0.25s;\n}\n\n.suggested_tile_overlay:hover {\n    opacity: 1;\n}\n\n.suggested_tile_overlay:hover>* {\n    transform: translateY(0);\n}\n\n.suggested_tile:hover {\n    cursor: pointer;\n}\n\n@media only screen and (max-width: 600px) and (orientation: portrait) {\n    .suggested_tile_grid {\n        display: none;\n    }\n}\n\n/* Medium devices like tablet portrait */\n@media only screen and (min-width: 992px) {\n    .suggested_tile_grid {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: calc(100% - 53px);\n        display: grid;\n        grid-template-columns: repeat(3, 20%);\n        grid-template-rows: min-content min-content;\n        column-gap: 40px;\n        row-gap: 10px;\n        z-index: 100;\n        align-content: center;\n        justify-content: center;\n    }\n\n    /* hide the last 6 video tiles */\n    .suggested_tile:nth-child(n+7) {\n      display: none;\n    }\n\n    .suggested_tile:first-child {\n        margin-left: 0px;\n    }\n\n    .suggested_tile:last-child {\n        margin-right: 0px;\n    }\n}\n\n/* Desktop */\n@media only screen and (min-width: 1200px) {\n    .suggested_tile_grid {\n        grid-template-columns: repeat(4, 20%);\n        column-gap: 10px;\n    }\n    .suggested_tile {\n        width: initial;\n        height: initial;\n    }\n    .suggested_tile:nth-child(n+7) {\n        display: flex;\n    }\n}\n", ""]);
// Exports
/* harmony default export */ __webpack_exports__["Z"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 645:
/***/ (function(module) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 667:
/***/ (function(module) {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ 81:
/***/ (function(module) {

"use strict";


module.exports = function (i) {
  return i[1];
};

/***/ }),

/***/ 702:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof __webpack_require__.g !== 'undefined') {
    local = __webpack_require__.g;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map


/***/ }),

/***/ 379:
/***/ (function(module) {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 569:
/***/ (function(module) {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ 216:
/***/ (function(module) {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ 565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 795:
/***/ (function(module) {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ 589:
/***/ (function(module) {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ 373:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGIiBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8cGF0aCBkPSJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyeiIvPgogICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgo8L3N2Zz4K";

/***/ }),

/***/ 924:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "player_icons.svg";

/***/ }),

/***/ 858:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ibGRzLWVjbGlwc2UiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiBzdHlsZT0iYmFja2dyb3VuZDowIDAiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIgogICAgIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogICAgPHBhdGggZD0iTTY4LjA5NSA1OS41NzhBMjAgMjAgMCAwMDMxLjE0IDQ0LjI3YTIyIDIwLTY3LjUgMDEzNi45NTUgMTUuMzA4IiBmaWxsPSIjZmZmIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIGJlZ2luPSIwcyIgY2FsY01vZGU9ImxpbmVhciIgZHVyPSIwLjhzIiBrZXlUaW1lcz0iMDsxIgogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiB0eXBlPSJyb3RhdGUiIHZhbHVlcz0iMCA1MCA1MTszNjAgNTAgNTEiLz4KICAgIDwvcGF0aD4KPC9zdmc+Cg==";

/***/ }),

/***/ 276:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTMuNSAyMEMzLjEgMjAgMi43NSAxOS44NSAyLjQ1IDE5LjU1QzIuMTUgMTkuMjUgMiAxOC45IDIgMTguNVYxMUgzLjVWMTguNUgyMC41VjUuNUgxMVY0SDIwLjVDMjAuOSA0IDIxLjI1IDQuMTUgMjEuNTUgNC40NUMyMS44NSA0Ljc1IDIyIDUuMSAyMiA1LjVWMTguNUMyMiAxOC45IDIxLjg1IDE5LjI1IDIxLjU1IDE5LjU1QzIxLjI1IDE5Ljg1IDIwLjkgMjAgMjAuNSAyMEgzLjVaTTE3LjQyNSAxNi41TDE4LjUgMTUuNDI1TDE0LjcyNSAxMS42NzVIMTcuNjc1VjEwLjE3NUgxMi4xNzVWMTUuNjc1SDEzLjY3NVYxMi43NUwxNy40MjUgMTYuNVpNMiA5LjVWNEg5LjVWOS41SDJaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K";

/***/ }),

/***/ 46:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0yLjAwMDA1IDExVjlINS42MDAwNUwxLjMwMDA1IDQuN0wyLjcwMDA1IDMuM0w3LjAwMDA1IDcuNlY0SDkuMDAwMDVWMTFIMi4wMDAwNVpNNC4wMDAwNSAyMEMzLjQ1MDA1IDIwIDIuOTc5MjIgMTkuODA0MiAyLjU4NzU1IDE5LjQxMjVDMi4xOTU4OCAxOS4wMjA4IDIuMDAwMDUgMTguNTUgMi4wMDAwNSAxOFYxM0g0LjAwMDA1VjE4SDEyVjIwSDQuMDAwMDVaTTIwIDEzVjZIMTFWNEgyMEMyMC41NSA0IDIxLjAyMDkgNC4xOTU4MyAyMS40MTI1IDQuNTg3NUMyMS44MDQyIDQuOTc5MTcgMjIgNS40NSAyMiA2VjEzSDIwWk0xNCAyMFYxNUgyMlYyMEgxNFoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=";

/***/ }),

/***/ 212:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiPgogICAgPHBhdGggZD0iTTAgMGgyNHYyNEgwVjB6IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aAogICAgICAgIGQ9Ik0xMS45OSA1VjFsLTUgNSA1IDVWN2MzLjMxIDAgNiAyLjY5IDYgNnMtMi42OSA2LTYgNi02LTIuNjktNi02aC0yYzAgNC40MiAzLjU4IDggOCA4czgtMy41OCA4LTgtMy41OC04LTgtOHptLTEuMSAxMWgtLjg1di0zLjI2bC0xLjAxLjMxdi0uNjlsMS43Ny0uNjNoLjA5VjE2em00LjI4LTEuNzZjMCAuMzItLjAzLjYtLjEuODJzLS4xNy40Mi0uMjkuNTctLjI4LjI2LS40NS4zMy0uMzcuMS0uNTkuMS0uNDEtLjAzLS41OS0uMS0uMzMtLjE4LS40Ni0uMzMtLjIzLS4zNC0uMy0uNTctLjExLS41LS4xMS0uODJ2LS43NGMwLS4zMi4wMy0uNi4xLS44MnMuMTctLjQyLjI5LS41Ny4yOC0uMjYuNDUtLjMzLjM3LS4xLjU5LS4xLjQxLjAzLjU5LjEuMzMuMTguNDYuMzMuMjMuMzQuMy41Ny4xMS41LjExLjgydi43NHptLS44NS0uODZjMC0uMTktLjAxLS4zNS0uMDQtLjQ4cy0uMDctLjIzLS4xMi0uMzEtLjExLS4xNC0uMTktLjE3LS4xNi0uMDUtLjI1LS4wNS0uMTguMDItLjI1LjA1LS4xNC4wOS0uMTkuMTctLjA5LjE4LS4xMi4zMS0uMDQuMjktLjA0LjQ4di45N2MwIC4xOS4wMS4zNS4wNC40OHMuMDcuMjQuMTIuMzIuMTEuMTQuMTkuMTcuMTYuMDUuMjUuMDUuMTgtLjAyLjI1LS4wNS4xNC0uMDkuMTktLjE3LjA5LS4xOS4xMS0uMzIuMDQtLjI5LjA0LS40OHYtLjk3eiIvPgo8L3N2Zz4K";

/***/ }),

/***/ 928:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI0IDI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9IndoaXRlIiB3aWR0aD0iMjRweCIKICAgICBoZWlnaHQ9IjI0cHgiPgogICAgPGc+CiAgICAgICAgPHJlY3QgZmlsbD0ibm9uZSIgaGVpZ2h0PSIyNCIgd2lkdGg9IjI0Ii8+CiAgICAgICAgPHJlY3QgZmlsbD0ibm9uZSIgaGVpZ2h0PSIyNCIgd2lkdGg9IjI0Ii8+CiAgICAgICAgPHJlY3QgZmlsbD0ibm9uZSIgaGVpZ2h0PSIyNCIgd2lkdGg9IjI0Ii8+CiAgICA8L2c+CiAgICA8Zz4KICAgICAgICA8Zy8+CiAgICAgICAgPGc+CiAgICAgICAgICAgIDxwYXRoCiAgICAgICAgICAgICAgICBkPSJNMTgsMTNjMCwzLjMxLTIuNjksNi02LDZzLTYtMi42OS02LTZzMi42OS02LDYtNnY0bDUtNWwtNS01djRjLTQuNDIsMC04LDMuNTgtOCw4YzAsNC40MiwzLjU4LDgsOCw4czgtMy41OCw4LThIMTh6Ii8+CiAgICAgICAgICAgIDxwb2x5Z29uIHBvaW50cz0iMTAuOSwxNiAxMC45LDExLjczIDEwLjgxLDExLjczIDkuMDQsMTIuMzYgOS4wNCwxMy4wNSAxMC4wNSwxMi43NCAxMC4wNSwxNiIvPgogICAgICAgICAgICA8cGF0aAogICAgICAgICAgICAgICAgZD0iTTE0LjMyLDExLjc4Yy0wLjE4LTAuMDctMC4zNy0wLjEtMC41OS0wLjFzLTAuNDEsMC4wMy0wLjU5LDAuMXMtMC4zMywwLjE4LTAuNDUsMC4zM3MtMC4yMywwLjM0LTAuMjksMC41NyBzLTAuMSwwLjUtMC4xLDAuODJ2MC43NGMwLDAuMzIsMC4wNCwwLjYsMC4xMSwwLjgyczAuMTcsMC40MiwwLjMsMC41N3MwLjI4LDAuMjYsMC40NiwwLjMzczAuMzcsMC4xLDAuNTksMC4xczAuNDEtMC4wMywwLjU5LTAuMSBzMC4zMy0wLjE4LDAuNDUtMC4zM3MwLjIyLTAuMzQsMC4yOS0wLjU3czAuMS0wLjUsMC4xLTAuODJWMTMuNWMwLTAuMzItMC4wNC0wLjYtMC4xMS0wLjgycy0wLjE3LTAuNDItMC4zLTAuNTcgUzE0LjQ5LDExLjg1LDE0LjMyLDExLjc4eiBNMTQuMzMsMTQuMzVjMCwwLjE5LTAuMDEsMC4zNS0wLjA0LDAuNDhzLTAuMDYsMC4yNC0wLjExLDAuMzJzLTAuMTEsMC4xNC0wLjE5LDAuMTcgcy0wLjE2LDAuMDUtMC4yNSwwLjA1cy0wLjE4LTAuMDItMC4yNS0wLjA1cy0wLjE0LTAuMDktMC4xOS0wLjE3cy0wLjA5LTAuMTktMC4xMi0wLjMycy0wLjA0LTAuMjktMC4wNC0wLjQ4di0wLjk3IGMwLTAuMTksMC4wMS0wLjM1LDAuMDQtMC40OHMwLjA2LTAuMjMsMC4xMi0wLjMxczAuMTEtMC4xNCwwLjE5LTAuMTdzMC4xNi0wLjA1LDAuMjUtMC4wNXMwLjE4LDAuMDIsMC4yNSwwLjA1IHMwLjE0LDAuMDksMC4xOSwwLjE3czAuMDksMC4xOCwwLjEyLDAuMzFzMC4wNCwwLjI5LDAuMDQsMC40OFYxNC4zNXoiLz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPgo=";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	!function() {
/******/ 		var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });
/******/ 			}
/******/ 			def['default'] = function() { return value; };
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	!function() {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = function(chunkId) {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "" + ({"112":"dashjs","366":"panolens","490":"webvtt","602":"hlsjs","721":"vttjs"}[chunkId] || chunkId) + ".js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	!function() {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "fluid-player:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = function(url, done, key, chunkId) {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = function(prev, event) {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach(function(fn) { return fn(event); });
/******/ 				if(prev) return prev(event);
/******/ 			};
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "/watch/external/";
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			772: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = function(chunkId, promises) {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = function(event) {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkfluid_player"] = self["webpackChunkfluid_player"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	!function() {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";

// EXTERNAL MODULE: ./node_modules/es6-promise/dist/es6-promise.js
var es6_promise = __webpack_require__(702);
var es6_promise_default = /*#__PURE__*/__webpack_require__.n(es6_promise);
;// CONCATENATED MODULE: ./src/polyfills.js


// Object.assign polyfill
if (typeof Object.assign != 'function') {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, 'assign', {
    value: function assign(target, varArgs) {
      // .length of function is 2
      'use strict';

      if (target == null) {
        // TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
      }
      var to = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];
        if (nextSource != null) {
          // Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}

// CustomEvent polyfill
(function () {
  if (typeof globalThis.CustomEvent === 'function') return false;
  function CustomEvent(event, params) {
    params = params || {
      bubbles: false,
      cancelable: false,
      detail: undefined
    };
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }
  CustomEvent.prototype = globalThis.Event.prototype;
  globalThis.CustomEvent = CustomEvent;
})();

// .remove() polyfill
if (typeof globalThis.Element !== 'undefined' && typeof globalThis.CharacterData !== 'undefined' && typeof globalThis.DocumentType !== 'undefined') {
  (function (arr) {
    arr.forEach(function (item) {
      if (item.hasOwnProperty('remove')) {
        return;
      }
      Object.defineProperty(item, 'remove', {
        configurable: true,
        enumerable: true,
        writable: true,
        value: function remove() {
          if (this.parentNode === null) {
            return;
          }
          this.parentNode.removeChild(this);
        }
      });
    });
  })([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
}
es6_promise_default().polyfill();
;// CONCATENATED MODULE: ./src/modules/vpaid.js
// VPAID support module
/* harmony default export */ function vpaid(playerInstance, options) {
  var callbacks = {
    AdStarted: function AdStarted() {
      return playerInstance.onStartVpaidAd;
    },
    AdStopped: function AdStopped() {
      return playerInstance.onStopVpaidAd;
    },
    AdSkipped: function AdSkipped() {
      return playerInstance.onSkipVpaidAd;
    },
    AdLoaded: function AdLoaded() {
      return playerInstance.onVpaidAdLoaded;
    },
    AdLinearChange: function AdLinearChange() {
      return playerInstance.onVpaidAdLinearChange;
    },
    AdSizeChange: function AdSizeChange() {
      return playerInstance.onVpaidAdSizeChange;
    },
    AdExpandedChange: function AdExpandedChange() {
      return playerInstance.onVpaidAdExpandedChange;
    },
    AdSkippableStateChange: function AdSkippableStateChange() {
      return playerInstance.onVpaidAdSkippableStateChange;
    },
    AdDurationChange: function AdDurationChange() {
      return playerInstance.onVpaidAdDurationChange;
    },
    AdRemainingTimeChange: function AdRemainingTimeChange() {
      return playerInstance.onVpaidAdRemainingTimeChange;
    },
    AdVolumeChange: function AdVolumeChange() {
      return playerInstance.onVpaidAdVolumeChange;
    },
    AdImpression: function AdImpression() {
      return playerInstance.onVpaidAdImpression;
    },
    AdClickThru: function AdClickThru() {
      return playerInstance.onVpaidAdClickThru;
    },
    AdInteraction: function AdInteraction() {
      return playerInstance.onVpaidAdInteraction;
    },
    AdVideoStart: function AdVideoStart() {
      return playerInstance.onVpaidAdVideoStart;
    },
    AdVideoFirstQuartile: function AdVideoFirstQuartile() {
      return playerInstance.onVpaidAdVideoFirstQuartile;
    },
    AdVideoMidpoint: function AdVideoMidpoint() {
      return playerInstance.onVpaidAdVideoMidpoint;
    },
    AdVideoThirdQuartile: function AdVideoThirdQuartile() {
      return playerInstance.onVpaidAdVideoThirdQuartile;
    },
    AdVideoComplete: function AdVideoComplete() {
      return playerInstance.onVpaidAdVideoComplete;
    },
    AdUserAcceptInvitation: function AdUserAcceptInvitation() {
      return playerInstance.onVpaidAdUserAcceptInvitation;
    },
    AdUserMinimize: function AdUserMinimize() {
      return playerInstance.onVpaidAdUserMinimize;
    },
    AdUserClose: function AdUserClose() {
      return playerInstance.onVpaidAdUserClose;
    },
    AdPaused: function AdPaused() {
      return playerInstance.onVpaidAdPaused;
    },
    AdPlaying: function AdPlaying() {
      return playerInstance.onVpaidAdPlaying;
    },
    AdError: function AdError() {
      return playerInstance.onVpaidAdError;
    },
    AdLog: function AdLog() {
      return playerInstance.onVpaidAdLog;
    }
  };
  playerInstance.checkVPAIDInterface = function (vpaidAdUnit) {
    var VPAIDCreative = vpaidAdUnit;
    // checks if all the mandatory params present
    return !!(VPAIDCreative.handshakeVersion && typeof VPAIDCreative.handshakeVersion == "function" && VPAIDCreative.initAd && typeof VPAIDCreative.initAd == "function" && VPAIDCreative.startAd && typeof VPAIDCreative.startAd == "function" && VPAIDCreative.stopAd && typeof VPAIDCreative.stopAd == "function" && VPAIDCreative.skipAd && typeof VPAIDCreative.skipAd == "function" && VPAIDCreative.resizeAd && typeof VPAIDCreative.resizeAd == "function" && VPAIDCreative.pauseAd && typeof VPAIDCreative.pauseAd == "function" && VPAIDCreative.resumeAd && typeof VPAIDCreative.resumeAd == "function" && VPAIDCreative.expandAd && typeof VPAIDCreative.expandAd == "function" && VPAIDCreative.collapseAd && typeof VPAIDCreative.collapseAd == "function" && VPAIDCreative.subscribe && typeof VPAIDCreative.subscribe == "function" && VPAIDCreative.unsubscribe && typeof VPAIDCreative.unsubscribe == "function");
  };

  // Callback for AdPaused
  playerInstance.onVpaidAdPaused = function () {
    playerInstance.vpaidTimeoutTimerClear();
    playerInstance.debugMessage("onAdPaused");
  };

  // Callback for AdPlaying
  playerInstance.onVpaidAdPlaying = function () {
    playerInstance.vpaidTimeoutTimerClear();
    playerInstance.debugMessage("onAdPlaying");
  };

  // Callback for AdError
  playerInstance.onVpaidAdError = function (message) {
    playerInstance.debugMessage("onAdError: " + message);
    playerInstance.vpaidTimeoutTimerClear();
    playerInstance.onVpaidEnded();
  };

  // Callback for AdLog
  playerInstance.onVpaidAdLog = function (message) {
    playerInstance.debugMessage("onAdLog: " + message);
  };

  // Callback for AdUserAcceptInvitation
  playerInstance.onVpaidAdUserAcceptInvitation = function () {
    playerInstance.debugMessage("onAdUserAcceptInvitation");
  };

  // Callback for AdUserMinimize
  playerInstance.onVpaidAdUserMinimize = function () {
    playerInstance.debugMessage("onAdUserMinimize");
  };

  // Callback for AdUserClose
  playerInstance.onVpaidAdUserClose = function () {
    playerInstance.debugMessage("onAdUserClose");
  };

  // Callback for AdUserClose
  playerInstance.onVpaidAdSkippableStateChange = function () {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.debugMessage("Ad Skippable State Changed to: " + playerInstance.vpaidAdUnit.getAdSkippableState());
  };

  // Callback for AdUserClose
  playerInstance.onVpaidAdExpandedChange = function () {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.debugMessage("Ad Expanded Changed to: " + playerInstance.vpaidAdUnit.getAdExpanded());
  };

  // Pass through for getAdExpanded
  playerInstance.getVpaidAdExpanded = function () {
    playerInstance.debugMessage("getAdExpanded");
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    return playerInstance.vpaidAdUnit.getAdExpanded();
  };

  // Pass through for getAdSkippableState
  playerInstance.getVpaidAdSkippableState = function () {
    playerInstance.debugMessage("getAdSkippableState");
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    return playerInstance.vpaidAdUnit.getAdSkippableState();
  };

  // Callback for AdSizeChange
  playerInstance.onVpaidAdSizeChange = function () {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.debugMessage("Ad size changed to: w=" + playerInstance.vpaidAdUnit.getAdWidth() + " h=" + playerInstance.vpaidAdUnit.getAdHeight());
  };

  // Callback for AdDurationChange
  playerInstance.onVpaidAdDurationChange = function () {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.debugMessage("Ad Duration Changed to: " + playerInstance.vpaidAdUnit.getAdDuration());
  };

  // Callback for AdRemainingTimeChange
  playerInstance.onVpaidAdRemainingTimeChange = function () {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.debugMessage("Ad Remaining Time Changed to: " + playerInstance.vpaidAdUnit.getAdRemainingTime());
  };

  // Pass through for getAdRemainingTime
  playerInstance.getVpaidAdRemainingTime = function () {
    playerInstance.debugMessage("getAdRemainingTime");
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    return playerInstance.vpaidAdUnit.getAdRemainingTime();
  };

  // Callback for AdImpression
  playerInstance.onVpaidAdImpression = function () {
    playerInstance.debugMessage("Ad Impression");

    //Announce the impressions
    playerInstance.trackSingleEvent('impression');
  };

  // Callback for AdClickThru
  playerInstance.onVpaidAdClickThru = function (url, id, playerHandles) {
    playerInstance.debugMessage("Clickthrough portion of the ad was clicked");

    // if playerHandles flag is set to true
    // then player need to open click thorough url in new window
    if (playerHandles) {
      window.open(playerInstance.vastOptions.clickthroughUrl);
    }
    playerInstance.pauseVpaidAd();
    // fire click tracking
    playerInstance.callUris(playerInstance.vastOptions.clicktracking);
  };

  // Callback for AdInteraction
  playerInstance.onVpaidAdInteraction = function (id) {
    playerInstance.debugMessage("A non-clickthrough event has occured");
  };

  // Callback for AdVideoStart
  playerInstance.onVpaidAdVideoStart = function () {
    playerInstance.debugMessage("Video 0% completed");
    playerInstance.trackSingleEvent('start');
  };

  // Callback for AdUserClose
  playerInstance.onVpaidAdVideoFirstQuartile = function () {
    playerInstance.debugMessage("Video 25% completed");
    playerInstance.trackSingleEvent('firstQuartile');
  };

  // Callback for AdUserClose
  playerInstance.onVpaidAdVideoMidpoint = function () {
    playerInstance.debugMessage("Video 50% completed");
    playerInstance.trackSingleEvent('midpoint');
  };

  // Callback for AdUserClose
  playerInstance.onVpaidAdVideoThirdQuartile = function () {
    playerInstance.debugMessage("Video 75% completed");
    playerInstance.trackSingleEvent('thirdQuartile');
  };

  // Callback for AdVideoComplete
  playerInstance.onVpaidAdVideoComplete = function () {
    playerInstance.debugMessage("Video 100% completed");
    playerInstance.trackSingleEvent('complete');
  };

  // Callback for AdLinearChange
  playerInstance.onVpaidAdLinearChange = function () {
    var vpaidNonLinearSlot = playerInstance.domRef.wrapper.getElementsByClassName("fluid_vpaidNonLinear_ad")[0];
    var closeBtn = playerInstance.domRef.wrapper.querySelector('.close_button');
    var adListId = vpaidNonLinearSlot.getAttribute('adlistid');
    playerInstance.debugMessage("Ad linear has changed: " + playerInstance.vpaidAdUnit.getAdLinear());
    if (!playerInstance.vpaidAdUnit.getAdLinear()) {
      return;
    }
    playerInstance.backupMainVideoContentTime(adListId.split('_')[0]);
    playerInstance.isCurrentlyPlayingAd = true;
    if (closeBtn) {
      closeBtn.remove();
    }
    vpaidNonLinearSlot.className = 'fluid_vpaid_slot';
    playerInstance.domRef.player.loop = false;
    playerInstance.domRef.player.removeAttribute('controls');
    var progressbarContainer = playerInstance.domRef.player.parentNode.getElementsByClassName('fluid_controls_currentprogress');
    for (var i = 0; i < progressbarContainer.length; i++) {
      progressbarContainer[i].style.backgroundColor = playerInstance.displayOptions.layoutControls.adProgressColor;
    }
    playerInstance.toggleLoader(false);
  };

  // Pass through for getAdLinear
  playerInstance.getVpaidAdLinear = function () {
    playerInstance.debugMessage("getAdLinear");
    return playerInstance.vpaidAdUnit.getAdLinear();
  };

  // Pass through for startAd()
  playerInstance.startVpaidAd = function () {
    playerInstance.debugMessage("startAd");
    playerInstance.vpaidTimeoutTimerStart();
    playerInstance.vpaidAdUnit.startAd();
  };

  // Callback for AdLoaded
  playerInstance.onVpaidAdLoaded = function () {
    playerInstance.debugMessage("ad has been loaded");
    // start the video play as vpaid is loaded successfully
    playerInstance.vpaidTimeoutTimerClear();
    playerInstance.startVpaidAd();
  };

  // Callback for StartAd()
  playerInstance.onStartVpaidAd = function () {
    playerInstance.debugMessage("Ad has started");
    playerInstance.vpaidTimeoutTimerClear();
  };

  // Pass through for stopAd()
  playerInstance.stopVpaidAd = function () {
    playerInstance.vpaidTimeoutTimerStart();
    playerInstance.vpaidAdUnit.stopAd();
  };

  // Hard Pass through for stopAd() excluding deleteOtherVpaidAdsApart
  playerInstance.hardStopVpaidAd = function (ad) {
    // this is hard stop of vpaid ads
    // we delete all the vpaid assets so the new one can be loaded
    // delete all assets apart from the ad from deleteOtherVpaidAdsApart
    if (playerInstance.vpaidAdUnit) {
      playerInstance.vpaidAdUnit.stopAd();
      playerInstance.vpaidAdUnit = null;
    }
    var vpaidIframes = playerInstance.domRef.wrapper.getElementsByClassName("fluid_vpaid_iframe");
    var vpaidSlots = playerInstance.domRef.wrapper.getElementsByClassName("fluid_vpaid_slot");
    var vpaidNonLinearSlots = playerInstance.domRef.wrapper.getElementsByClassName("fluid_vpaidNonLinear_ad");
    for (var i = 0; i < vpaidIframes.length; i++) {
      if (vpaidIframes[i].getAttribute('adListId') !== ad.id) {
        vpaidIframes[i].remove();
      }
    }
    for (var j = 0; j < vpaidSlots.length; j++) {
      if (vpaidSlots[j].getAttribute('adListId') !== ad.id) {
        vpaidSlots[j].remove();
      }
    }
    for (var k = 0; k < vpaidNonLinearSlots.length; k++) {
      if (vpaidNonLinearSlots[k].getAttribute('adListId') !== ad.id) {
        vpaidNonLinearSlots[k].remove();
      }
    }
  };

  // Callback for AdUserClose
  playerInstance.onStopVpaidAd = function () {
    playerInstance.debugMessage("Ad has stopped");
    playerInstance.vpaidTimeoutTimerClear();
    playerInstance.onVpaidEnded();
  };

  // Callback for AdUserClose
  playerInstance.onSkipVpaidAd = function () {
    playerInstance.debugMessage("Ad was skipped");
    playerInstance.vpaidTimeoutTimerClear();
    playerInstance.onVpaidEnded();
  };

  // Passthrough for skipAd
  playerInstance.skipVpaidAd = function () {
    playerInstance.vpaidTimeoutTimerStart();
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.vpaidAdUnit.skipAd();
    playerInstance.vpaidTimeoutTimerClear();
    playerInstance.onVpaidEnded();
  };

  // Passthrough for setAdVolume
  playerInstance.setVpaidAdVolume = function (val) {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.vpaidAdUnit.setAdVolume(val);
  };

  // Passthrough for getAdVolume
  playerInstance.getVpaidAdVolume = function () {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    return playerInstance.vpaidAdUnit.getAdVolume();
  };

  // Callback for AdVolumeChange
  playerInstance.onVpaidAdVolumeChange = function () {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.debugMessage("Ad Volume has changed to - " + playerInstance.vpaidAdUnit.getAdVolume());
  };
  playerInstance.resizeVpaidAuto = function () {
    if (playerInstance.vastOptions !== null && playerInstance.vastOptions.vpaid && playerInstance.vastOptions.linear) {
      var adWidth = playerInstance.domRef.player.offsetWidth;
      var adHeight = playerInstance.domRef.player.offsetHeight;
      var mode = playerInstance.fullscreenMode ? 'fullscreen' : 'normal';
      playerInstance.resizeVpaidAd(adWidth, adHeight, mode);
    }
  };

  // Passthrough for resizeAd
  playerInstance.resizeVpaidAd = function (width, height, viewMode) {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.vpaidAdUnit.resizeAd(width, height, viewMode);
  };

  // Passthrough for pauseAd()
  playerInstance.pauseVpaidAd = function () {
    playerInstance.vpaidTimeoutTimerStart();
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.vpaidAdUnit.pauseAd();
  };

  // Passthrough for resumeAd()
  playerInstance.resumeVpaidAd = function () {
    playerInstance.vpaidTimeoutTimerStart();
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.vpaidAdUnit.resumeAd();
  };

  // Passthrough for expandAd()
  playerInstance.expandVpaidAd = function () {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.vpaidAdUnit.expandAd();
  };

  // Passthrough for collapseAd()
  playerInstance.collapseVpaidAd = function () {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    playerInstance.vpaidAdUnit.collapseAd();
  };
  playerInstance.vpaidTimeoutTimerClear = function () {
    if (playerInstance.vpaidTimer) {
      clearTimeout(playerInstance.vpaidTimer);
    }
  };

  // placeholder for timer function
  playerInstance.vpaidTimeoutTimerStart = function () {
    // clear previous timer if any
    playerInstance.vpaidTimeoutTimerClear();
    playerInstance.vpaidTimer = setTimeout(function () {
      playerInstance.announceLocalError('901');
      playerInstance.onVpaidEnded();
    }, playerInstance.displayOptions.vastOptions.vpaidTimeout);
  };
  playerInstance.vpaidCallbackListenersAttach = function () {
    // The key of the object is the event name and the value is a reference to the callback function that is registered with the creative
    // Looping through the object and registering each of the callbacks with the creative
    for (var eventName in callbacks) {
      playerInstance.vpaidAdUnit.subscribe(callbacks[eventName](), eventName, playerInstance);
    }
  };
  playerInstance.vpaidCallbackListenersDetach = function () {
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    for (var eventName in callbacks) {
      playerInstance.vpaidAdUnit.unsubscribe(callbacks[eventName](), eventName, playerInstance);
    }
  };
  playerInstance.loadVpaid = function (ad, vpaidJsUrl) {
    var vpaidIframe = document.createElement('iframe');
    vpaidIframe.id = "fp_" + ad.id + "_fluid_vpaid_iframe";
    vpaidIframe.className = 'fluid_vpaid_iframe';
    vpaidIframe.setAttribute('adListId', ad.id);
    vpaidIframe.setAttribute('frameborder', '0');
    playerInstance.domRef.player.parentNode.insertBefore(vpaidIframe, playerInstance.domRef.player.nextSibling);
    var vpaidJsScriptElement = document.createElement('script');
    vpaidJsScriptElement.src = vpaidJsUrl;
    vpaidIframe.contentWindow.document.head.append(vpaidJsScriptElement);

    // set interval with timeout
    playerInstance.tempVpaidCounter = 0;
    playerInstance.getVPAIDAdInterval = setInterval(function () {
      if (vpaidIframe && vpaidIframe.contentWindow) {
        var fn = vpaidIframe.contentWindow['getVPAIDAd'];

        // check if JS is loaded fully in iframe
        if (fn && typeof fn == 'function') {
          if (playerInstance.vpaidAdUnit) {
            playerInstance.hardStopVpaidAd(ad);
          }
          playerInstance.vpaidAdUnit = fn();
          clearInterval(playerInstance.getVPAIDAdInterval);
          if (playerInstance.checkVPAIDInterface(playerInstance.vpaidAdUnit)) {
            if (playerInstance.getVpaidAdLinear()) {
              playerInstance.isCurrentlyPlayingAd = true;
              playerInstance.switchPlayerToVpaidMode(ad);
            } else {
              playerInstance.debugMessage('non linear vpaid ad is loaded');
              playerInstance.loadVpaidNonlinearAssets(ad);
            }
          }
        } else {
          // video player will wait for 2seconds if vpaid is not loaded, then it will declare vast error and move ahead
          playerInstance.tempVpaidCounter++;
          if (playerInstance.tempVpaidCounter >= 20) {
            clearInterval(playerInstance.getVPAIDAdInterval);
            playerInstance.rollsById[ad.rollListId].error = true;
            playerInstance.playMainVideoWhenVpaidFails(403);
            return false;
          } else {
            playerInstance.debugMessage(playerInstance.tempVpaidCounter);
          }
        }
      }
    }, 100);
    playerInstance.destructors.push(function () {
      return clearInterval(playerInstance.getVPAIDAdInterval);
    });
  };
  playerInstance.onVpaidEnded = function (event) {
    if (event) {
      event.stopImmediatePropagation();
    }
    if (!playerInstance.vpaidAdUnit) {
      return;
    }
    var vpaidSlot = playerInstance.domRef.wrapper.querySelector('.fluid_vpaid_slot');
    playerInstance.vpaidCallbackListenersDetach();
    playerInstance.vpaidAdUnit = null;
    clearInterval(playerInstance.getVPAIDAdInterval);
    if (!!vpaidSlot) {
      vpaidSlot.remove();
    }
    playerInstance.checkForNextAd();
  };
  playerInstance.playMainVideoWhenVpaidFails = function (errorCode) {
    var vpaidSlot = playerInstance.domRef.wrapper.querySelector('.fluid_vpaid_slot');
    if (vpaidSlot) {
      vpaidSlot.remove();
    }
    clearInterval(playerInstance.getVPAIDAdInterval);
    playerInstance.playMainVideoWhenVastFails(errorCode);
  };
}
;// CONCATENATED MODULE: ./src/modules/vast.js
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// VAST support module

/* Type declarations */

/**
 * @typedef {Object} RawAdTree
 * @property {Array<RawAdTree>} children
 * @property {XMLDocument} data
 * @property {'inLine'|'wrapper'} tagType
 * @property {boolean|undefined} fallbackOnNoAd
 * @property {Array<XMLDocument> | undefined} wrappers
*/

/**
 * @typedef {Object} RawAd
 * @property {XMLDocument} data
 * @property {Array<XMLDocument>} wrappers
 * @property {'inLine' | 'wrapper'} tagType
 */

/**
 * @typedef {Object & RawAd} Ad
 * @property {Array<string>} clicktracking
 * @property {string} errorUrl
 * @property {Array<string>} impressions
 * @property {Array<string>} viewImpression
 * @property {Array<any>} stopTracking
 * @property {Array<any>} tracking
 * @property {number|null} sequence
 * @property {number} duration
 * @property {boolean} played
 */

/* harmony default export */ function vast(playerInstance, options) {
  /**
   * Gets CTA parameters from VAST and sets them on tempOptions
   *
   * Fallbacks to any value that is filled on the TitleCTA extension, but needs at least an url and a text
   *
   * @param {HTMLElement} titleCtaElement
   *
   * @param {any} tmpOptions
   */
  playerInstance.setCTAFromVast = function (titleCtaElement, tmpOptions) {
    if (playerInstance.displayOptions.vastOptions.adCTATextVast && titleCtaElement) {
      var mobileText = playerInstance.extractNodeDataByTagName(titleCtaElement, 'MobileText');
      var desktopText = playerInstance.extractNodeDataByTagName(titleCtaElement, 'PCText');
      var link = playerInstance.extractNodeDataByTagName(titleCtaElement, 'DisplayUrl') || playerInstance.extractNodeDataByTagName(titleCtaElement, 'Link');
      var tracking = playerInstance.extractNodeDataByTagName(titleCtaElement, 'Tracking');
      var isMobile = window.matchMedia('(max-width: 768px)').matches;
      if ((desktopText || mobileText) && tracking) {
        tmpOptions.titleCTA = {
          text: isMobile ? mobileText || desktopText : desktopText || mobileText,
          link: link || null,
          tracking: tracking
        };
      }
    }
  };
  playerInstance.getClickThroughUrlFromLinear = function (linear) {
    var videoClicks = linear.getElementsByTagName('VideoClicks');
    if (videoClicks.length) {
      //There should be exactly 1 node
      var clickThroughs = videoClicks[0].getElementsByTagName('ClickThrough');
      if (clickThroughs.length) {
        return playerInstance.extractNodeData(clickThroughs[0]);
      }
    }
    return false;
  };
  playerInstance.getVastAdTagUriFromWrapper = function (xmlResponse) {
    var wrapper = xmlResponse.getElementsByTagName('Wrapper');
    if (typeof wrapper !== 'undefined' && wrapper.length) {
      var vastAdTagURI = wrapper[0].getElementsByTagName('VASTAdTagURI');
      if (vastAdTagURI.length) {
        return playerInstance.extractNodeData(vastAdTagURI[0]);
      }
    }
    return false;
  };
  playerInstance.hasInLine = function (xmlResponse) {
    var inLine = xmlResponse.getElementsByTagName('InLine');
    return typeof inLine !== 'undefined' && inLine.length;
  };
  playerInstance.hasVastAdTagUri = function (xmlResponse) {
    var vastAdTagURI = xmlResponse.getElementsByTagName('VASTAdTagURI');
    return typeof vastAdTagURI !== 'undefined' && vastAdTagURI.length;
  };
  playerInstance.getClickThroughUrlFromNonLinear = function (nonLinear) {
    var result = '';
    var nonLinears = nonLinear.getElementsByTagName('NonLinear');
    if (nonLinears.length) {
      //There should be exactly 1 node
      var nonLinearClickThrough = nonLinear.getElementsByTagName('NonLinearClickThrough');
      if (nonLinearClickThrough.length) {
        result = playerInstance.extractNodeData(nonLinearClickThrough[0]);
      }
    }
    return result;
  };
  playerInstance.getTrackingFromLinear = function (linear) {
    var trackingEvents = linear.getElementsByTagName('TrackingEvents');
    if (trackingEvents.length) {
      //There should be no more than one node
      return trackingEvents[0].getElementsByTagName('Tracking');
    }
    return [];
  };
  playerInstance.getDurationFromLinear = function (linear) {
    var duration = linear.getElementsByTagName('Duration');
    if (duration.length && typeof duration[0].childNodes[0] !== 'undefined') {
      var nodeDuration = playerInstance.extractNodeData(duration[0]);
      return playerInstance.convertTimeStringToSeconds(nodeDuration);
    }
    return false;
  };
  playerInstance.getDurationFromNonLinear = function (tag) {
    var result = 0;
    var nonLinear = tag.getElementsByTagName('NonLinear');
    if (nonLinear.length && typeof nonLinear[0].getAttribute('minSuggestedDuration') !== 'undefined') {
      result = playerInstance.convertTimeStringToSeconds(nonLinear[0].getAttribute('minSuggestedDuration'));
    }
    return result;
  };
  playerInstance.getDimensionFromNonLinear = function (tag) {
    var result = {
      'width': null,
      'height': null
    };
    var nonLinear = tag.getElementsByTagName('NonLinear');
    if (nonLinear.length) {
      if (typeof nonLinear[0].getAttribute('width') !== 'undefined') {
        result.width = nonLinear[0].getAttribute('width');
      }
      if (typeof nonLinear[0].getAttribute('height') !== 'undefined') {
        result.height = nonLinear[0].getAttribute('height');
      }
    }
    return result;
  };
  playerInstance.getCreativeTypeFromStaticResources = function (tag) {
    var result = '';
    var nonLinears = tag.getElementsByTagName('NonLinear');
    if (nonLinears.length && typeof nonLinears[0].childNodes[0] !== 'undefined') {
      //There should be exactly 1 StaticResource node
      result = nonLinears[0].getElementsByTagName('StaticResource')[0].getAttribute('creativeType');
    }
    return result.toLowerCase();
  };
  playerInstance.getMediaFilesFromLinear = function (linear) {
    var mediaFiles = linear.getElementsByTagName('MediaFiles');
    if (mediaFiles.length) {
      //There should be exactly 1 MediaFiles node
      return mediaFiles[0].getElementsByTagName('MediaFile');
    }
    return [];
  };
  playerInstance.getStaticResourcesFromNonLinear = function (linear) {
    var result = [];
    var nonLinears = linear.getElementsByTagName('NonLinear');
    if (nonLinears.length) {
      //There should be exactly 1 StaticResource node
      result = nonLinears[0].getElementsByTagName('StaticResource');
    }
    return result;
  };

  /**
   * Gets the first element found by tag name, and returns the element data
   *
   * @param {HTMLElement} parentNode
   *
   * @param {string} tagName
   *
   * @returns {string|null}
   */
  playerInstance.extractNodeDataByTagName = function (parentNode, tagName) {
    var element = parentNode.getElementsByTagName(tagName);
    if (element && element.length) {
      return playerInstance.extractNodeData(element[0]);
    } else {
      return null;
    }
  };
  playerInstance.extractNodeData = function (parentNode) {
    var contentAsString = "";
    for (var n = 0; n < parentNode.childNodes.length; n++) {
      var child = parentNode.childNodes[n];
      if (child.nodeType === 8 || child.nodeType === 3 && /^\s*$/.test(child.nodeValue)) {
        // Comments or text with no content
      } else {
        contentAsString += child.nodeValue;
      }
    }
    return contentAsString.replace(/(^\s+|\s+$)/g, '');
  };
  playerInstance.getAdParametersFromLinear = function (linear) {
    var adParameters = linear.getElementsByTagName('AdParameters');
    var adParametersData = null;
    if (adParameters.length) {
      adParametersData = playerInstance.extractNodeData(adParameters[0]);
    }
    return adParametersData;
  };
  playerInstance.getMediaFileListFromLinear = function (linear) {
    var mediaFileList = [];
    var mediaFiles = playerInstance.getMediaFilesFromLinear(linear);
    if (!mediaFiles.length) {
      return mediaFileList;
    }
    for (var n = 0; n < mediaFiles.length; n++) {
      var mediaType = mediaFiles[n].getAttribute('mediaType');
      if (!mediaType) {
        // if there is no mediaType attribute then the video is 2D
        mediaType = '2D';
      }

      // get all the attributes of media file
      mediaFileList.push({
        'src': playerInstance.extractNodeData(mediaFiles[n]),
        'type': mediaFiles[n].getAttribute('type'),
        'apiFramework': mediaFiles[n].getAttribute('apiFramework'),
        'codec': mediaFiles[n].getAttribute('codec'),
        'id': mediaFiles[n].getAttribute('codec'),
        'fileSize': mediaFiles[n].getAttribute('fileSize'),
        'delivery': mediaFiles[n].getAttribute('delivery'),
        'width': mediaFiles[n].getAttribute('width'),
        'height': mediaFiles[n].getAttribute('height'),
        'mediaType': mediaType.toLowerCase()
      });
    }
    return mediaFileList;
  };
  playerInstance.getIconClickThroughFromLinear = function (linear) {
    var iconClickThrough = linear.getElementsByTagName('IconClickThrough');
    if (iconClickThrough.length) {
      return playerInstance.extractNodeData(iconClickThrough[0]);
    }
    return '';
  };
  playerInstance.getStaticResourceFromNonLinear = function (linear) {
    var fallbackStaticResource;
    var staticResources = playerInstance.getStaticResourcesFromNonLinear(linear);
    for (var i = 0; i < staticResources.length; i++) {
      if (!staticResources[i].getAttribute('type')) {
        fallbackStaticResource = playerInstance.extractNodeData(staticResources[i]);
      }
      if (staticResources[i].getAttribute('type') === playerInstance.displayOptions.staticResource) {
        return playerInstance.extractNodeData(staticResources[i]);
      }
    }
    return fallbackStaticResource;
  };
  playerInstance.registerTrackingEvents = function (creativeLinear, tmpOptions) {
    var trackingEvents = playerInstance.getTrackingFromLinear(creativeLinear);
    var eventType = '';
    var oneEventOffset = 0;
    for (var i = 0; i < trackingEvents.length; i++) {
      eventType = trackingEvents[i].getAttribute('event');
      switch (eventType) {
        case 'start':
        case 'firstQuartile':
        case 'midpoint':
        case 'thirdQuartile':
        case 'complete':
          if (typeof tmpOptions.tracking[eventType] === 'undefined') {
            tmpOptions.tracking[eventType] = [];
          }
          if (typeof tmpOptions.stopTracking[eventType] === 'undefined') {
            tmpOptions.stopTracking[eventType] = [];
          }
          tmpOptions.tracking[eventType].push(trackingEvents[i].textContent.trim());
          tmpOptions.stopTracking[eventType] = false;
          break;
        case 'progress':
          if (typeof tmpOptions.tracking[eventType] === 'undefined') {
            tmpOptions.tracking[eventType] = [];
          }
          oneEventOffset = playerInstance.convertTimeStringToSeconds(trackingEvents[i].getAttribute('offset'));
          if (typeof tmpOptions.tracking[eventType][oneEventOffset] === 'undefined') {
            tmpOptions.tracking[eventType][oneEventOffset] = {
              elements: [],
              stopTracking: false
            };
          }
          tmpOptions.tracking[eventType][oneEventOffset].elements.push(trackingEvents[i].textContent.trim());
          break;
        default:
          break;
      }
    }
  };
  playerInstance.registerClickTracking = function (clickTrackingTag, tmpOptions) {
    if (!clickTrackingTag || !clickTrackingTag.length) {
      return;
    }
    for (var i = 0; i < clickTrackingTag.length; i++) {
      if (clickTrackingTag[i] === '') {
        continue;
      }
      tmpOptions.clicktracking.push(clickTrackingTag[i]);
    }
  };
  playerInstance.registerViewableImpressionEvents = function (viewableImpressionTags, tmpOptions) {
    if (!viewableImpressionTags.length) {
      return;
    }
    for (var i = 0; i < viewableImpressionTags.length; i++) {
      var viewableImpressionEvent = playerInstance.extractNodeData(viewableImpressionTags[i]);
      tmpOptions.viewImpression.push(viewableImpressionEvent);
    }
  };
  playerInstance.registerImpressionEvents = function (impressionTags, tmpOptions) {
    if (!impressionTags.length) {
      return;
    }
    for (var i = 0; i < impressionTags.length; i++) {
      var impressionEvent = playerInstance.extractNodeData(impressionTags[i]);
      tmpOptions.impression.push(impressionEvent);
    }
  };
  playerInstance.registerErrorEvents = function (errorTags, tmpOptions) {
    if (typeof errorTags !== 'undefined' && errorTags !== null && errorTags.length === 1 &&
    //Only 1 Error tag is expected
    errorTags[0].childNodes.length === 1) {
      tmpOptions.errorUrl = errorTags[0].childNodes[0].nodeValue;
    }
  };
  playerInstance.announceError = function (code) {
    if (typeof playerInstance.vastOptions.errorUrl === 'undefined' || !playerInstance.vastOptions.errorUrl) {
      return;
    }
    var parsedCode = typeof code !== 'undefined' ? parseInt(code) : 900;
    var errorUrl = playerInstance.vastOptions.errorUrl.replace('[ERRORCODE]', parsedCode);

    //Send the error request
    playerInstance.callUris([errorUrl]);
  };
  playerInstance.getClickTrackingEvents = function (linear) {
    var result = [];
    var videoClicks = linear.getElementsByTagName('VideoClicks');

    //There should be exactly 1 node
    if (!videoClicks.length) {
      return;
    }
    var clickTracking = videoClicks[0].getElementsByTagName('ClickTracking');
    if (!clickTracking.length) {
      return;
    }
    for (var i = 0; i < clickTracking.length; i++) {
      var clickTrackingEvent = playerInstance.extractNodeData(clickTracking[i]);
      result.push(clickTrackingEvent);
    }
    return result;
  };
  playerInstance.getNonLinearClickTrackingEvents = function (nonLinear) {
    var result = [];
    var nonLinears = nonLinear.getElementsByTagName('NonLinear');
    if (!nonLinears.length) {
      return;
    }
    var clickTracking = nonLinear.getElementsByTagName('NonLinearClickTracking');
    if (!clickTracking.length) {
      return;
    }
    for (var i = 0; i < clickTracking.length; i++) {
      var NonLinearClickTracking = playerInstance.extractNodeData(clickTracking[i]);
      result.push(NonLinearClickTracking);
    }
    return result;
  };

  // TODO: ???
  playerInstance.callUris = function (uris) {
    for (var i = 0; i < uris.length; i++) {
      new Image().src = uris[i];
    }
  };
  playerInstance.recalculateAdDimensions = function () {
    var videoPlayer = playerInstance.domRef.player;
    var divClickThrough = playerInstance.domRef.wrapper.querySelector('.vast_clickthrough_layer');
    if (divClickThrough) {
      divClickThrough.style.width = videoPlayer.offsetWidth + 'px';
      divClickThrough.style.height = videoPlayer.offsetHeight + 'px';
    }
    var requestFullscreenFunctionNames = playerInstance.checkFullscreenSupport();
    var fullscreenButton = playerInstance.domRef.wrapper.querySelector('.fluid_control_fullscreen');
    var menuOptionFullscreen = playerInstance.domRef.wrapper.querySelector('.context_option_fullscreen');
    if (requestFullscreenFunctionNames) {
      // this will go other way around because we already exited full screen
      if (document[requestFullscreenFunctionNames.isFullscreen] === null) {
        // Exit fullscreen
        playerInstance.fullscreenOff(fullscreenButton, menuOptionFullscreen);
      } else {
        // Go fullscreen
        playerInstance.fullscreenOn(fullscreenButton, menuOptionFullscreen);
      }
    } else {
      // TODO: I am fairly certain this fallback does not work...
      //The browser does not support the Fullscreen API, so a pseudo-fullscreen implementation is used
      var fullscreenTag = playerInstance.domRef.wrapper;
      if (fullscreenTag.className.search(/\bpseudo_fullscreen\b/g) !== -1) {
        fullscreenTag.className += ' pseudo_fullscreen';
        playerInstance.fullscreenOn(fullscreenButton, menuOptionFullscreen);
      } else {
        fullscreenTag.className = fullscreenTag.className.replace(/\bpseudo_fullscreen\b/g, '');
        playerInstance.fullscreenOff(fullscreenButton, menuOptionFullscreen);
      }
    }
  };

  /**
   * Prepares VAST for instant ads
   *
   * @param roll
   */
  playerInstance.prepareVast = function (roll) {
    var list = playerInstance.findRoll(roll);
    for (var i = 0; i < list.length; i++) {
      var rollListId = list[i];
      if (!(playerInstance.rollsById[rollListId].vastLoaded !== true && playerInstance.rollsById[rollListId].error !== true)) {
        continue;
      }
      playerInstance.processVastWithRetries(playerInstance.rollsById[rollListId]);
    }
  };
  playerInstance.playMainVideoWhenVastFails = function (errorCode) {
    playerInstance.debugMessage('playMainVideoWhenVastFails called');
    playerInstance.domRef.player.removeEventListener('loadedmetadata', playerInstance.switchPlayerToVastMode);
    playerInstance.domRef.player.pause();
    playerInstance.toggleLoader(false);
    playerInstance.displayOptions.vastOptions.vastAdvanced.noVastVideoCallback();
    if (!playerInstance.vastOptions || typeof playerInstance.vastOptions.errorUrl === 'undefined') {
      playerInstance.announceLocalError(errorCode);
    } else {
      playerInstance.announceError(errorCode);
    }
    playerInstance.switchToMainVideo();
  };

  // TODO: ???
  playerInstance.switchPlayerToVastMode = function () {};

  /**
   * Process the XML response
   *
   * @param ad
   */
  function processAdCreatives(ad) {
    var adElement = ad.data;
    if (!adElement) {
      return;
    }
    var creativeElements = Array.from(adElement.getElementsByTagName('Creative'));
    if (creativeElements.length) {
      for (var i = 0; i < creativeElements.length; i++) {
        var creativeElement = creativeElements[i];
        try {
          if (ad.adType === 'linear') {
            var linearCreatives = creativeElement.getElementsByTagName('Linear');
            var creativeLinear = linearCreatives[0];

            //Extract the Ad data if it is actually the Ad (!wrapper)
            if (!playerInstance.hasVastAdTagUri(adElement) && playerInstance.hasInLine(adElement)) {
              //Set initial values
              ad.adFinished = false;
              ad.vpaid = false;

              //Extract the necessary data from the Linear node
              ad.skipoffset = playerInstance.convertTimeStringToSeconds(creativeLinear.getAttribute('skipoffset'));
              ad.clickthroughUrl = playerInstance.getClickThroughUrlFromLinear(creativeLinear);
              ad.duration = playerInstance.getDurationFromLinear(creativeLinear);
              ad.mediaFileList = playerInstance.getMediaFileListFromLinear(creativeLinear);
              ad.adParameters = playerInstance.getAdParametersFromLinear(creativeLinear);
              ad.iconClick = ad.iconClick || playerInstance.getIconClickThroughFromLinear(creativeLinear);
              if (ad.adParameters) {
                ad.vpaid = true;
              }
            }
          }
          if (ad.adType === 'nonLinear') {
            var nonLinearCreatives = creativeElement.getElementsByTagName('NonLinearAds');
            var creativeNonLinear = nonLinearCreatives[0];

            //Extract the Ad data if it is actually the Ad (!wrapper)
            if (!playerInstance.hasVastAdTagUri(adElement) && playerInstance.hasInLine(adElement)) {
              //Set initial values
              ad.vpaid = false;

              //Extract the necessary data from the NonLinear node
              ad.clickthroughUrl = playerInstance.getClickThroughUrlFromNonLinear(creativeNonLinear);
              ad.duration = playerInstance.getDurationFromNonLinear(creativeNonLinear); // VAST version < 4.0
              ad.dimension = playerInstance.getDimensionFromNonLinear(creativeNonLinear); // VAST version < 4.0
              ad.staticResource = playerInstance.getStaticResourceFromNonLinear(creativeNonLinear);
              ad.creativeType = playerInstance.getCreativeTypeFromStaticResources(creativeNonLinear);
              ad.adParameters = playerInstance.getAdParametersFromLinear(creativeNonLinear);
              if (ad.adParameters) {
                ad.vpaid = true;
              }
            }
          }

          // Current support is for only one creative element
          // break the loop if creative was successful
          break;
        } catch (err) {
          if (creativeElement.firstElementChild && !(creativeElement.firstElementChild.tagName === 'Linear' || creativeElement.firstElementChild.tagName === 'NonLinearAds')) {
            console.warn('Skipping ' + creativeElement.firstElementChild.tagName + ', this might not be supported yet.');
          }
          console.error(err);
        }
      }
      ;
    }
    return ad;
  }

  /**
   * Parse the VAST Tag
   *
   * @param vastObj
   */
  playerInstance.processVastWithRetries = function (vastObj) {
    var vastTag = vastObj.vastTag;
    var rollListId = vastObj.id;
    playerInstance.domRef.player.addEventListener('adId_' + rollListId, playerInstance[vastObj.roll]);
    var handleVastResult = function handleVastResult(pass, adOptionsList) {
      if (pass && Array.isArray(adOptionsList) && !playerInstance.displayOptions.vastOptions.allowVPAID && adOptionsList.some(function (adOptions) {
        return adOptions.vpaid;
      })) {
        adOptionsList = adOptionsList.filter(function (adOptions) {
          return adOptions.vpaid !== true;
        });
        playerInstance.announceLocalError('103', 'VPAID not allowed, so skipping this VAST tag.');
      }
      if (pass && Array.isArray(adOptionsList) && adOptionsList.length) {
        playerInstance.adPool[rollListId] = [];
        adOptionsList.forEach(function (tmpOptions, index) {
          tmpOptions.id = rollListId + '_AD' + index;
          tmpOptions.rollListId = rollListId;
          if (tmpOptions.adType === 'linear') {
            if (typeof tmpOptions.iconClick !== 'undefined' && tmpOptions.iconClick !== null && tmpOptions.iconClick.length) {
              tmpOptions.landingPage = tmpOptions.iconClick;
            }
            var selectedMediaFile = playerInstance.getSupportedMediaFileObject(tmpOptions.mediaFileList);
            if (selectedMediaFile) {
              tmpOptions.mediaType = selectedMediaFile.mediaType;
            }
          }
          tmpOptions.adType = tmpOptions.adType ? tmpOptions.adType : 'unknown';
          playerInstance.adPool[rollListId].push(Object.assign({}, tmpOptions));
          if (playerInstance.hasTitle()) {
            var title = playerInstance.domRef.wrapper.querySelector('.fp_title');
            title.style.display = 'none';
          }
          playerInstance.rollsById[rollListId].ads.push(tmpOptions);
        });
        playerInstance.rollsById[rollListId].vastLoaded = true;
        var event = document.createEvent('Event');
        event.initEvent('adId_' + rollListId, false, true);
        playerInstance.domRef.player.dispatchEvent(event);
        playerInstance.displayOptions.vastOptions.vastAdvanced.vastLoadedCallback();
      } else {
        // when vast failed
        playerInstance.announceLocalError('101');
        if (vastObj.hasOwnProperty('fallbackVastTags') && vastObj.fallbackVastTags.length > 0) {
          vastTag = vastObj.fallbackVastTags.shift();
          playerInstance.processUrl(vastTag, handleVastResult, rollListId);
        } else {
          if (vastObj.roll === 'preRoll') {
            playerInstance.preRollFail(vastObj);
          }
          playerInstance.rollsById[rollListId].error = true;
        }
      }
    };
    playerInstance.processUrl(vastTag, handleVastResult, rollListId);
  };
  playerInstance.processUrl = function (vastTag, callBack, rollListId) {
    var numberOfRedirects = 0;
    var tmpOptions = {
      tracking: [],
      stopTracking: [],
      impression: [],
      viewImpression: [],
      clicktracking: [],
      vastLoaded: false
    };
    playerInstance.resolveVastTag(vastTag, numberOfRedirects, tmpOptions, callBack, rollListId);
  };

  /**
   * Gets first stand-alone ad
   *
   * @param {Array<RawAdTree>} ads
   * @returns {Array<RawAdTree>}
   */
  function getFirstStandAloneAd(ads) {
    var _iterator = _createForOfIteratorHelper(ads),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var ad = _step.value;
        var isAdPod = ad.data.attributes.sequence !== undefined;
        if (!isAdPod) {
          return [ad];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return [];
  }

  /**
   * Resolves ad requests recursively and returns a tree of "Ad" and "Wrapper" elements
   *
   * @param {string} url vast resource url
   * @param {number} maxDepth depth of recursive calls (wrapper depth)
   * @param {Partial<RawAdTree>} baseNode used for recursive calls as base node
   * @param {number} currentDepth used internally to track depth
   * @param {boolean} followAdditionalWrappers used internally to track nested wrapper calls
   * @returns {Promise<RawAdTree>}
   */
  function resolveAdTreeRequests(_x, _x2) {
    return _resolveAdTreeRequests.apply(this, arguments);
  }
  /**
   * Transforms an Ad Tree to a 1-dimensional array of Ads with wrapper data attached to each ad
   *
   * @param {RawAdTree} root
   * @param {Array<RawAd>} ads
   * @param {Array<XMLDocument>} wrappers
   * @returns {Array<RawAd>}
   */
  function _resolveAdTreeRequests() {
    _resolveAdTreeRequests = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, maxDepth) {
      var baseNode,
        currentDepth,
        followAdditionalWrappers,
        adTree,
        _yield$playerInstance,
        responseXML,
        adElements,
        _i2,
        _adElements,
        adElement,
        vastAdTagUri,
        isAdPod,
        adNode,
        _adElement$getElement,
        _adElement$getElement2,
        wrapperElement,
        disableAdditionalWrappers,
        allowMultipleAds,
        fallbackOnNoAd,
        wrapperResponse,
        _args = arguments;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            baseNode = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
            currentDepth = _args.length > 3 && _args[3] !== undefined ? _args[3] : 0;
            followAdditionalWrappers = _args.length > 4 && _args[4] !== undefined ? _args[4] : true;
            adTree = _objectSpread(_objectSpread({}, baseNode), {}, {
              children: []
            });
            _context.next = 6;
            return playerInstance.sendRequestAsync(url, true, playerInstance.displayOptions.vastOptions.vastTimeout);
          case 6:
            _yield$playerInstance = _context.sent;
            responseXML = _yield$playerInstance.responseXML;
            adElements = Array.from(responseXML.getElementsByTagName('Ad'));
            _i2 = 0, _adElements = adElements;
          case 10:
            if (!(_i2 < _adElements.length)) {
              _context.next = 39;
              break;
            }
            adElement = _adElements[_i2];
            vastAdTagUri = playerInstance.getVastAdTagUriFromWrapper(adElement);
            isAdPod = adElement.attributes.sequence !== undefined;
            adNode = {
              data: adElement
            };
            if (!(vastAdTagUri && currentDepth <= maxDepth && followAdditionalWrappers)) {
              _context.next = 35;
              break;
            }
            _adElement$getElement = adElement.getElementsByTagName('Wrapper'), _adElement$getElement2 = _slicedToArray(_adElement$getElement, 1), wrapperElement = _adElement$getElement2[0];
            disableAdditionalWrappers = wrapperElement.attributes.followAdditionalWrappers && ["false", "0"].includes(wrapperElement.attributes.followAdditionalWrappers.value); // See VAST Wrapper spec
            allowMultipleAds = wrapperElement.attributes.allowMultipleAds && ["true", "1"].includes(wrapperElement.attributes.allowMultipleAds.value); // See VAST Wrapper spec
            fallbackOnNoAd = wrapperElement.attributes.fallbackOnNoAd && ["true", "1"].includes(wrapperElement.attributes.fallbackOnNoAd.value);
            _context.prev = 20;
            _context.next = 23;
            return resolveAdTreeRequests(vastAdTagUri, maxDepth, _objectSpread(_objectSpread({
              tagType: 'wrapper'
            }, adNode), {}, {
              fallbackOnNoAd: fallbackOnNoAd
            }), currentDepth + 1, !disableAdditionalWrappers);
          case 23:
            wrapperResponse = _context.sent;
            wrapperResponse.fallbackOnNoAd = fallbackOnNoAd;
            if (!allowMultipleAds || isAdPod) {
              wrapperResponse.children = getFirstStandAloneAd(wrapperResponse.children);
            }
            adTree.children.push(wrapperResponse);
            _context.next = 33;
            break;
          case 29:
            _context.prev = 29;
            _context.t0 = _context["catch"](20);
            adTree.children.push({
              tagType: "wrapper",
              fallbackOnNoAd: fallbackOnNoAd,
              httpError: true
            });
            playerInstance.debugMessage("Error when loading Wrapper, will trigger fallback if available", _context.t0);
          case 33:
            _context.next = 36;
            break;
          case 35:
            if (!vastAdTagUri) {
              adTree.children.push(_objectSpread({
                tagType: 'inLine'
              }, adNode));
            }
          case 36:
            _i2++;
            _context.next = 10;
            break;
          case 39:
            return _context.abrupt("return", adTree);
          case 40:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[20, 29]]);
    }));
    return _resolveAdTreeRequests.apply(this, arguments);
  }
  function flattenAdTree(root) {
    var ads = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var wrappers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var currentWrappers = [].concat(_toConsumableArray(wrappers), [root.data]);
    if (Array.isArray(root.children) && root.children.length) {
      root.children.forEach(function (child) {
        return flattenAdTree(child, ads, currentWrappers);
      });
    }
    if (root.tagType === 'inLine') {
      ads.push(_objectSpread(_objectSpread({}, root), {}, {
        wrappers: currentWrappers.filter(Boolean)
      }));
    }
    return ads;
  }

  /**
   * Register Ad element properties to an Ad based on its data and its wrapper data if available
   *
   * @param {RawAd} rawAd
   * @param {{ tracking: Array, stopTracking: Array, impression: Array, viewImpression: Array, clicktracking: Array }} options
   * @returns {Ad}
   */
  function registerAdProperties(rawAd, options) {
    var ad = _objectSpread(_objectSpread({}, rawAd), JSON.parse(JSON.stringify(options)));
    ad.adType = ad.data.getElementsByTagName('Linear').length && 'linear' || ad.data.getElementsByTagName('NonLinearAds').length && 'nonLinear' || 'unknown';
    [].concat(_toConsumableArray(ad.wrappers || []), [ad.data]).filter(Boolean).forEach(function (dataSource) {
      // Register impressions
      var impression = dataSource.getElementsByTagName('Impression');
      if (impression !== null) {
        playerInstance.registerImpressionEvents(impression, ad);
      }

      // Register viewable impressions
      var viewableImpression = dataSource.getElementsByTagName('Viewable');
      if (viewableImpression !== null) {
        playerInstance.registerViewableImpressionEvents(viewableImpression, ad);
      }

      // Get the error tag, if any
      var errorTags = dataSource.getElementsByTagName('Error');
      if (errorTags !== null) {
        playerInstance.registerErrorEvents(errorTags, ad);
      }

      // Sets CTA from vast
      var _dataSource$getElemen = dataSource.getElementsByTagName('TitleCTA'),
        _dataSource$getElemen2 = _slicedToArray(_dataSource$getElemen, 1),
        titleCta = _dataSource$getElemen2[0];
      if (titleCta) {
        playerInstance.setCTAFromVast(titleCta, ad);
      }

      // Register tracking events
      playerInstance.registerTrackingEvents(dataSource, ad);
      var clickTracks = ad.adType === 'linear' ? playerInstance.getClickTrackingEvents(dataSource) : playerInstance.getNonLinearClickTrackingEvents(dataSource);
      playerInstance.registerClickTracking(clickTracks, ad);
    });
    ad.sequence = ad.data.attributes.sequence ? Number(ad.data.attributes.sequence.value) : null;
    ad.played = false;
    return ad;
  }

  /**
   * Handles selection of ad pod or standalone ad to be played
   *
   * @param {Array<Ad>} ads
   * @param {number} maxDuration
   * @param {number} maxQuantity
   * @param {boolean} forceStandAloneAd
   */
  function getPlayableAds(ads, maxDuration, maxQuantity, forceStandAloneAd) {
    var _ads$filter$sort$redu = ads.filter(function (ad) {
        return Boolean(ad.sequence);
      }).sort(function (adX, adY) {
        return adX.sequence - adY.sequence;
      }).reduce(function (playableAds, ad) {
        if (playableAds.adPod.length < maxQuantity && playableAds.totalDuration + ad.duration <= maxDuration) {
          playableAds.adPod.push(ad);
        }
        return playableAds;
      }, {
        adPod: [],
        totalDuration: 0
      }),
      adPod = _ads$filter$sort$redu.adPod;
    var adBuffet = ads.filter(function (ad) {
      return !Boolean(ad.sequence) && ad.duration < maxDuration;
    });
    var isValidAdPodFormats = adPod.map(function (ad) {
      return ad.adType;
    }).slice(0, -1).every(function (adType) {
      return adType === 'linear';
    });
    if (adPod.length > 0 && !forceStandAloneAd && isValidAdPodFormats) {
      playerInstance.debugMessage('Playing valid adPod', adPod);
      return adPod;
    } else {
      playerInstance.debugMessage('Trying to play single ad, adBuffet:', adBuffet);
      return adBuffet.length > 0 ? [adBuffet[0]] : [];
    }
  }

  /**
   * @param vastTag
   * @param numberOfRedirects
   * @param tmpOptions
   * @param callback
   * @param rollListId
   */
  playerInstance.resolveVastTag = function (vastTag, numberOfRedirects, tmpOptions, callback, rollListId) {
    if (!vastTag || vastTag === '') {
      return callback(false);
    }
    resolveAdTreeRequests(vastTag, playerInstance.displayOptions.vastOptions.maxAllowedVastTagRedirects).then(function (result) {
      try {
        /** @see VAST 4.0 Wrapper.fallbackOnNoAd */
        var triggerFallbackOnNoAd = result.children.some(function (ad) {
          return ad.tagType === 'wrapper' && ad.fallbackOnNoAd && (!/"tagType":"ad"/.test(JSON.stringify(ad)) || ad.httpError);
        });
        if (triggerFallbackOnNoAd) {
          playerInstance.debugMessage('Error on VAST Wrapper, triggering fallbackOnNoAd. Ad tree:', result);
        }
        result = flattenAdTree(result).map(function (ad) {
          return processAdCreatives(registerAdProperties(ad, tmpOptions));
        });
        var playableAds = getPlayableAds(result, playerInstance.rollsById[rollListId].maxTotalDuration || Number.MAX_SAFE_INTEGER, playerInstance.rollsById[rollListId].maxTotalQuantity || Number.MAX_SAFE_INTEGER, triggerFallbackOnNoAd);
        playableAds && playableAds.length ? callback(true, playableAds) : callback(false);
      } catch (error) {
        callback(false);
      }
    }).catch(function () {
      return callback(false);
    });
  };
  playerInstance.setVastList = function () {
    var rolls = {};
    var rollsGroupedByType = {
      preRoll: [],
      postRoll: [],
      midRoll: [],
      onPauseRoll: []
    };
    var def = {
      id: null,
      roll: null,
      vastLoaded: false,
      error: false,
      adText: null,
      adTextPosition: null
    };
    var idPart = 0;
    var validateVastList = function validateVastList(item) {
      var hasError = false;
      if (item.roll === 'midRoll') {
        if (typeof item.timer === 'undefined') {
          hasError = true;
        }
      }
      return hasError;
    };
    var validateRequiredParams = function validateRequiredParams(item) {
      var hasError = false;
      if (!item.vastTag) {
        playerInstance.announceLocalError(102, '"vastTag" property is missing from adList.');
        hasError = true;
      }
      if (!item.roll) {
        playerInstance.announceLocalError(102, '"roll" is missing from adList.');
        hasError = true;
      }
      if (playerInstance.availableRolls.indexOf(item.roll) === -1) {
        playerInstance.announceLocalError(102, 'Only ' + playerInstance.availableRolls.join(',') + ' rolls are supported.');
        hasError = true;
      }
      if (item.size && playerInstance.supportedNonLinearAd.indexOf(item.size) === -1) {
        playerInstance.announceLocalError(102, 'Only ' + playerInstance.supportedNonLinearAd.join(',') + ' size are supported.');
        hasError = true;
      }
      return hasError;
    };
    if (playerInstance.displayOptions.vastOptions.hasOwnProperty('adList')) {
      for (var key in playerInstance.displayOptions.vastOptions.adList) {
        var rollItem = playerInstance.displayOptions.vastOptions.adList[key];
        if (validateRequiredParams(rollItem)) {
          playerInstance.announceLocalError(102, 'Wrong adList parameters.');
          continue;
        }
        var id = 'ID' + idPart;
        rolls[id] = Object.assign({}, def);
        rolls[id] = Object.assign(rolls[id], playerInstance.displayOptions.vastOptions.adList[key]);
        if (rollItem.roll === 'midRoll') {
          rolls[id].error = validateVastList('midRoll', rollItem);
        }
        rolls[id].id = id;
        rolls[id].ads = [];
        idPart++;
      }
    }

    // group the ads by roll
    // pushing object references and forming json
    Object.keys(rolls).map(function (e) {
      switch (rolls[e].roll.toLowerCase()) {
        case 'preRoll'.toLowerCase():
          rollsGroupedByType.preRoll.push(rolls[e]);
          break;
        case 'midRoll'.toLowerCase():
          rollsGroupedByType.midRoll.push(rolls[e]);
          break;
        case 'postRoll'.toLowerCase():
          rollsGroupedByType.postRoll.push(rolls[e]);
          break;
        case 'onPauseRoll'.toLowerCase():
          rollsGroupedByType.onPauseRoll.push(rolls[e]);
          break;
        default:
          console.error("".concat(rolls[e].roll.toLowerCase(), " is not a recognized roll"));
          break;
      }
    });
    playerInstance.adGroupedByRolls = rollsGroupedByType;
    playerInstance.rollsById = rolls;
  };
  playerInstance.onVastAdEnded = function (event) {
    if (event) {
      event.stopImmediatePropagation();
    }
    playerInstance.vastOptions.adFinished = true;
    //"this" is the HTML5 video tag, because it dispatches the "ended" event
    playerInstance.deleteVastAdElements();
    playerInstance.checkForNextAd();
  };
  playerInstance.vastLogoBehaviour = function (vastPlaying) {
    if (!playerInstance.displayOptions.layoutControls.logo.showOverAds) {
      var logoHolder = playerInstance.domRef.wrapper.querySelector('.logo_holder');
      if (!logoHolder) {
        return;
      }
      logoHolder.style.display = vastPlaying ? 'none' : 'inline';
    }
  };
  playerInstance.deleteVastAdElements = function () {
    playerInstance.removeClickthrough();
    playerInstance.removeSkipButton();
    playerInstance.removeAdCountdown();
    playerInstance.removeAdPlayingText();
    playerInstance.removeCTAButton();
    playerInstance.vastLogoBehaviour(false);
  };
}
;// CONCATENATED MODULE: ./src/modules/cardboard.js
/* harmony default export */ function cardboard(playerInstance, options) {
  playerInstance.createCardboardJoystickButton = function (identity) {
    var vrJoystickPanel = playerInstance.domRef.wrapper.querySelector('.fluid_vr_joystick_panel');
    var joystickButton = document.createElement('div');
    joystickButton.className = 'fluid_vr_button fluid_vr_joystick_' + identity;
    vrJoystickPanel.appendChild(joystickButton);
    return joystickButton;
  };
  playerInstance.cardboardRotateLeftRight = function (param /* 0 - right, 1 - left */) {
    var go = playerInstance.vrROTATION_POSITION;
    var back = -playerInstance.vrROTATION_POSITION;
    var pos = param < 1 ? go : back;
    var easing = {
      val: pos
    };
    var tween = new TWEEN.Tween(easing).to({
      val: 0
    }, playerInstance.vrROTATION_SPEED).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(function () {
      playerInstance.vrViewer.OrbitControls.rotateLeft(easing.val);
    }).start();
  };
  playerInstance.cardboardRotateUpDown = function (param /* 0 - down, 1- up */) {
    var go = playerInstance.vrROTATION_POSITION;
    var back = -playerInstance.vrROTATION_POSITION;
    var pos = param < 1 ? go : back;
    var easing = {
      val: pos
    };
    var tween = new TWEEN.Tween(easing).to({
      val: 0
    }, playerInstance.vrROTATION_SPEED).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(function () {
      playerInstance.vrViewer.OrbitControls.rotateUp(easing.val);
    }).start();
  };
  playerInstance.createCardboardJoystick = function () {
    var vrContainer = playerInstance.domRef.wrapper.querySelector('.fluid_vr_container');

    // Create a JoyStick and append to VR container
    var vrJoystickPanel = document.createElement('div');
    vrJoystickPanel.className = 'fluid_vr_joystick_panel';
    vrContainer.appendChild(vrJoystickPanel);

    // Create Joystick buttons
    var upButton = playerInstance.createCardboardJoystickButton('up');
    var leftButton = playerInstance.createCardboardJoystickButton('left');
    var rightButton = playerInstance.createCardboardJoystickButton('right');
    var downButton = playerInstance.createCardboardJoystickButton('down');
    var zoomDefaultButton = playerInstance.createCardboardJoystickButton('zoomdefault');
    var zoomInButton = playerInstance.createCardboardJoystickButton('zoomin');
    var zoomOutButton = playerInstance.createCardboardJoystickButton('zoomout');

    // Camera movement buttons
    upButton.addEventListener('click', function () {
      //player.vrViewer.OrbitControls.rotateUp(-0.1);
      playerInstance.cardboardRotateUpDown(1);
    });
    downButton.addEventListener('click', function () {
      //player.vrViewer.OrbitControls.rotateUp(0.1);
      playerInstance.cardboardRotateUpDown(0);
    });
    rightButton.addEventListener('click', function () {
      //player.vrViewer.OrbitControls.rotateLeft(0.1);
      playerInstance.cardboardRotateLeftRight(0);
    });
    leftButton.addEventListener('click', function () {
      //player.vrViewer.OrbitControls.rotateLeft(-0.1);
      playerInstance.cardboardRotateLeftRight(1);
    });
    zoomDefaultButton.addEventListener('click', function () {
      playerInstance.vrViewer.camera.fov = 60;
      playerInstance.vrViewer.camera.updateProjectionMatrix();
    });

    // Camera Zoom buttons
    zoomOutButton.addEventListener('click', function () {
      playerInstance.vrViewer.camera.fov *= 1.1;
      playerInstance.vrViewer.camera.updateProjectionMatrix();
    });
    zoomInButton.addEventListener('click', function () {
      playerInstance.vrViewer.camera.fov *= 0.9;
      playerInstance.vrViewer.camera.updateProjectionMatrix();
    });
  };
  playerInstance.cardBoardResize = function () {
    playerInstance.domRef.player.removeEventListener('theatreModeOn', handleWindowResize);
    playerInstance.domRef.player.addEventListener('theatreModeOn', handleWindowResize);
    playerInstance.domRef.player.removeEventListener('theatreModeOff', handleWindowResize);
    playerInstance.domRef.player.addEventListener('theatreModeOff', handleWindowResize);
  };
  function handleWindowResize() {
    playerInstance.vrViewer.onWindowResize();
  }
  playerInstance.cardBoardSwitchToNormal = function () {
    var vrJoystickPanel = playerInstance.domRef.wrapper.querySelector('.fluid_vr_joystick_panel');
    var controlBar = playerInstance.domRef.wrapper.querySelector('.fluid_controls_container');
    var videoPlayerTag = playerInstance.domRef.player;
    playerInstance.vrViewer.enableEffect(PANOLENS.MODES.NORMAL);
    playerInstance.vrViewer.onWindowResize();
    playerInstance.vrMode = false;

    // remove dual control bar
    var newControlBar = videoPlayerTag.parentNode.getElementsByClassName('fluid_vr2_controls_container')[0];
    videoPlayerTag.parentNode.removeChild(newControlBar);
    if (playerInstance.displayOptions.layoutControls.showCardBoardJoystick && vrJoystickPanel) {
      vrJoystickPanel.style.display = "block";
    }
    controlBar.classList.remove("fluid_vr_controls_container");

    // show volume control bar
    var volumeContainer = playerInstance.domRef.wrapper.getElementById('.fluid_control_volume_container');
    volumeContainer.style.display = "block";

    // show all ads overlays if any
    var adCountDownTimerText = playerInstance.domRef.wrapper.querySelector('.ad_countdown');
    var ctaButton = playerInstance.domRef.wrapper.querySelector('.fluid_ad_cta');
    var addAdPlayingTextOverlay = playerInstance.domRef.wrapper.querySelector('.fluid_ad_playing');
    var skipBtn = playerInstance.domRef.wrapper.querySelector('.skip_button');
    if (adCountDownTimerText) {
      adCountDownTimerText.style.display = 'block';
    }
    if (ctaButton) {
      ctaButton.style.display = 'block';
    }
    if (addAdPlayingTextOverlay) {
      addAdPlayingTextOverlay.style.display = 'block';
    }
    if (skipBtn) {
      skipBtn.style.display = 'block';
    }
  };
  playerInstance.cardBoardHideDefaultControls = function () {
    var vrJoystickPanel = playerInstance.domRef.wrapper.querySelector('.fluid_vr_joystick_panel');
    var initialPlay = playerInstance.domRef.wrapper.querySelector('.fluid_initial_play');
    var volumeContainer = playerInstance.domRef.wrapper.querySelector('.fluid_control_volume_container');

    // hide the joystick in VR mode
    if (playerInstance.displayOptions.layoutControls.showCardBoardJoystick && vrJoystickPanel) {
      vrJoystickPanel.style.display = "none";
    }

    // hide big play icon
    if (initialPlay) {
      playerInstance.domRef.wrapper.querySelector('.fluid_initial_play').style.display = "none";
      playerInstance.domRef.wrapper.querySelector('.fluid_initial_play_button_container').style.opacity = "1";
    }

    // hide volume control bar
    volumeContainer.style.display = "none";
  };
  playerInstance.cardBoardCreateVRControls = function () {
    var controlBar = playerInstance.domRef.wrapper.querySelector('.fluid_controls_container');

    // create and append dual control bar
    var newControlBar = controlBar.cloneNode(true);
    newControlBar.removeAttribute('id');
    newControlBar.querySelectorAll('*').forEach(function (node) {
      node.removeAttribute('id');
    });
    newControlBar.classList.add("fluid_vr2_controls_container");
    playerInstance.domRef.player.parentNode.insertBefore(newControlBar, playerInstance.domRef.player.nextSibling);
    playerInstance.copyEvents(newControlBar);
  };
  playerInstance.cardBoardSwitchToVR = function () {
    var controlBar = playerInstance.domRef.wrapper.querySelector('.fluid_controls_container');
    playerInstance.vrViewer.enableEffect(PANOLENS.MODES.CARDBOARD);
    playerInstance.vrViewer.onWindowResize();
    playerInstance.vrViewer.disableReticleControl();
    playerInstance.vrMode = true;
    controlBar.classList.add("fluid_vr_controls_container");
    playerInstance.cardBoardHideDefaultControls();
    playerInstance.cardBoardCreateVRControls();

    // hide all ads overlays
    var adCountDownTimerText = playerInstance.domRef.wrapper.querySelector('.ad_countdown');
    var ctaButton = playerInstance.domRef.wrapper.querySelector('.fluid_ad_cta');
    var addAdPlayingTextOverlay = playerInstance.domRef.wrapper.querySelector('.fluid_ad_playing');
    var skipBtn = playerInstance.domRef.wrapper.querySelector('.skip_button');
    if (adCountDownTimerText) {
      adCountDownTimerText.style.display = 'none';
    }
    if (ctaButton) {
      ctaButton.style.display = 'none';
    }
    if (addAdPlayingTextOverlay) {
      addAdPlayingTextOverlay.style.display = 'none';
    }
    if (skipBtn) {
      skipBtn.style.display = 'none';
    }
  };
  playerInstance.cardBoardMoveTimeInfo = function () {
    var timePlaceholder = playerInstance.domRef.wrapper.querySelector('.fluid_control_duration');
    var controlBar = playerInstance.domRef.wrapper.querySelector('.fluid_controls_container');
    timePlaceholder.classList.add("cardboard_time");
    controlBar.appendChild(timePlaceholder);

    // override the time display function for this instance
    playerInstance.controlDurationUpdate = function () {
      var currentPlayTime = playerInstance.formatTime(playerInstance.domRef.player.currentTime);
      var totalTime = playerInstance.formatTime(playerInstance.currentVideoDuration);
      var timePlaceholder = playerInstance.domRef.player.parentNode.getElementsByClassName('fluid_control_duration');
      var durationText = '';
      if (playerInstance.isCurrentlyPlayingAd) {
        durationText = "<span class='ad_timer_prefix'>AD : </span>" + currentPlayTime + ' / ' + totalTime;
        for (var i = 0; i < timePlaceholder.length; i++) {
          timePlaceholder[i].classList.add("ad_timer_prefix");
        }
      } else {
        durationText = currentPlayTime + ' / ' + totalTime;
        for (var _i = 0; _i < timePlaceholder.length; _i++) {
          timePlaceholder[_i].classList.remove("ad_timer_prefix");
        }
      }
      for (var _i2 = 0; _i2 < timePlaceholder.length; _i2++) {
        timePlaceholder[_i2].innerHTML = durationText;
      }
    };
  };
  playerInstance.cardBoardAlterDefaultControls = function () {
    playerInstance.cardBoardMoveTimeInfo();
  };
  playerInstance.createCardboardView = function () {
    // Create a container for 360degree
    var vrContainer = document.createElement('div');
    vrContainer.className = 'fluid_vr_container';
    playerInstance.domRef.player.parentNode.insertBefore(vrContainer, playerInstance.domRef.player.nextSibling);

    // OverRide some conflicting functions from panolens
    PANOLENS.VideoPanorama.prototype.pauseVideo = function () {};
    PANOLENS.VideoPanorama.prototype.playVideo = function () {};
    playerInstance.vrPanorama = new PANOLENS.VideoPanorama('', {
      videoElement: playerInstance.domRef.player,
      autoplay: playerInstance.displayOptions.layoutControls.autoPlay,
      loop: !!playerInstance.displayOptions.layoutControls.loop
    });
    playerInstance.vrViewer = new PANOLENS.Viewer({
      container: vrContainer,
      controlBar: true,
      controlButtons: [],
      enableReticle: false
    });
    playerInstance.vrViewer.add(playerInstance.vrPanorama);
    playerInstance.vrViewer.enableEffect(PANOLENS.MODES.NORMAL);
    playerInstance.vrViewer.onWindowResize();

    // if Mobile device then enable controls using gyroscope
    if (playerInstance.getMobileOs().userOs === 'Android' || playerInstance.getMobileOs().userOs === 'iOS') {
      playerInstance.vrViewer.enableControl(1);
    }

    // Make Changes for default skin
    playerInstance.cardBoardAlterDefaultControls();

    // resize on toggle theater mode
    playerInstance.cardBoardResize();

    // Store initial camera position
    playerInstance.vrViewer.initialCameraPosition = JSON.parse(JSON.stringify(playerInstance.vrViewer.camera.position));
    if (playerInstance.displayOptions.layoutControls.showCardBoardJoystick) {
      if (!(playerInstance.getMobileOs().userOs === 'Android' || playerInstance.getMobileOs().userOs === 'iOS')) {
        playerInstance.createCardboardJoystick();
      }
      // Disable zoom if showing joystick
      playerInstance.vrViewer.OrbitControls.noZoom = true;
    }
    playerInstance.trackEvent(playerInstance.domRef.player.parentNode, 'click', '.fluid_control_cardboard', function () {
      if (playerInstance.vrMode) {
        playerInstance.cardBoardSwitchToNormal();
      } else {
        playerInstance.cardBoardSwitchToVR();
      }
    });
  };
  playerInstance.createCardboard = function () {
    if (!playerInstance.displayOptions.layoutControls.showCardBoardView) {
      return;
    }
    playerInstance.domRef.wrapper.querySelector('.fluid_control_cardboard').style.display = 'inline-block';
    if (!window.PANOLENS) {
      __webpack_require__.e(/* import() | panolens */ 366).then(__webpack_require__.bind(__webpack_require__, 372)).then(function (it) {
        window.PANOLENS = it;
        playerInstance.createCardboardView();
      });
    } else {
      playerInstance.createCardboardView();
    }
  };
}
;// CONCATENATED MODULE: ./src/modules/subtitles.js
/* harmony default export */ function subtitles(playerInstance, options) {
  playerInstance.subtitleFetchParse = function (subtitleItem) {
    playerInstance.sendRequest(subtitleItem.url, true, playerInstance.displayOptions.vastOptions.vastTimeout, function () {
      var convertVttRawData = function convertVttRawData(vttRawData) {
        if (!(typeof vttRawData.cues !== 'undefined' && vttRawData.cues.length)) {
          return [];
        }
        var result = [];
        for (var i = 0; i < vttRawData.cues.length; i++) {
          var tempThumbnailData = vttRawData.cues[i].text.split('#');
          result.push({
            startTime: vttRawData.cues[i].startTime,
            endTime: vttRawData.cues[i].endTime,
            text: vttRawData.cues[i].text,
            cue: vttRawData.cues[i]
          });
        }
        return result;
      };
      var xmlHttpReq = this;
      if (xmlHttpReq.readyState === 4 && xmlHttpReq.status !== 200) {
        //The response returned an error.
        return;
      }
      if (!(xmlHttpReq.readyState === 4 && xmlHttpReq.status === 200)) {
        return;
      }
      var textResponse = xmlHttpReq.responseText;
      var parser = new WebVTT.Parser(window, WebVTT.StringDecoder());
      var cues = [];
      var regions = []; // TODO: unused?
      parser.oncue = function (cue) {
        cues.push(cue);
      };
      parser.onregion = function (region) {
        regions.push(region);
      };
      parser.parse(textResponse);
      parser.flush();
      playerInstance.subtitlesData = cues;
    });
  };
  playerInstance.createSubtitlesSwitch = function () {
    var subtitlesOff = 'OFF';
    playerInstance.subtitlesData = [];
    if (!playerInstance.displayOptions.layoutControls.subtitlesEnabled) {
      // No other video subtitles
      playerInstance.domRef.wrapper.querySelector('.fluid_control_subtitles').style.display = 'none';
      return;
    }
    var tracks = [];
    tracks.push({
      'label': subtitlesOff,
      'url': 'na',
      'lang': subtitlesOff
    });
    var tracksList = playerInstance.domRef.player.querySelectorAll('track');
    [].forEach.call(tracksList, function (track) {
      if (track.kind === 'metadata' && track.src) {
        tracks.push({
          'label': track.label,
          'url': track.src,
          'lang': track.srclang,
          'default': track.default
        });
      }
    });
    playerInstance.subtitlesTracks = tracks;
    var subtitlesChangeButton = playerInstance.domRef.wrapper.querySelector('.fluid_control_subtitles');
    subtitlesChangeButton.style.display = 'inline-block';
    var appendSubtitleChange = false;
    var subtitlesChangeList = document.createElement('div');
    subtitlesChangeList.className = 'fluid_subtitles_list';
    subtitlesChangeList.style.display = 'none';
    var hasSelectedSubtitle = false;
    var hasDefault = !!playerInstance.subtitlesTracks.find(function (track) {
      return track.default;
    });
    playerInstance.subtitlesTracks.forEach(function (subtitle) {
      var subtitleSelected = '';
      var subtitlesOnByDefault = playerInstance.displayOptions.layoutControls.subtitlesOnByDefault;
      if (!hasSelectedSubtitle && (subtitlesOnByDefault && subtitle.default || !hasDefault && subtitle.label !== subtitlesOff || playerInstance.subtitlesTracks.length === 1) || !subtitlesOnByDefault && subtitle.label === subtitlesOff) {
        subtitleSelected = 'subtitle_selected';
        playerInstance.subtitleFetchParse(subtitle);
        hasSelectedSubtitle = true;
      }
      var subtitlesChangeDiv = document.createElement('div');
      subtitlesChangeDiv.className = 'fluid_subtitle_list_item';
      subtitlesChangeDiv.innerHTML = '<span class="subtitle_button_icon ' + subtitleSelected + '"></span>' + subtitle.label;
      subtitlesChangeDiv.addEventListener('click', function (event) {
        event.stopPropagation();
        var subtitleChangedTo = this;
        var subtitleIcons = playerInstance.domRef.wrapper.getElementsByClassName('subtitle_button_icon');
        for (var i = 0; i < subtitleIcons.length; i++) {
          subtitleIcons[i].className = subtitleIcons[i].className.replace("subtitle_selected", "");
        }
        subtitleChangedTo.firstChild.className += ' subtitle_selected';
        playerInstance.subtitlesTracks.forEach(function (subtitle) {
          if (subtitle.label === subtitleChangedTo.innerText.replace(/(\r\n\t|\n|\r\t)/gm, "")) {
            if (subtitle.label === subtitlesOff) {
              playerInstance.subtitlesData = [];
            } else {
              playerInstance.subtitleFetchParse(subtitle);
            }
          }
        });
        playerInstance.openCloseSubtitlesSwitch();
      });
      subtitlesChangeList.appendChild(subtitlesChangeDiv);
      appendSubtitleChange = true;
    });
    if (appendSubtitleChange) {
      subtitlesChangeButton.appendChild(subtitlesChangeList);
      subtitlesChangeButton.removeEventListener('click', handleSubtitlesChange);
      subtitlesChangeButton.addEventListener('click', handleSubtitlesChange);
    } else {
      // Didn't give any subtitle options
      playerInstance.domRef.wrapper.querySelector('.fluid_control_subtitles').style.display = 'none';
    }
    playerInstance.domRef.player.removeEventListener('timeupdate', videoPlayerSubtitlesUpdate);
    playerInstance.domRef.player.addEventListener('timeupdate', videoPlayerSubtitlesUpdate);
  };
  function handleSubtitlesChange() {
    playerInstance.openCloseSubtitlesSwitch();
  }

  //attach subtitles to show based on time
  //this function is for rendering of subtitles when content is playing
  function videoPlayerSubtitlesUpdate() {
    playerInstance.renderSubtitles();
  }
  playerInstance.renderSubtitles = function () {
    var videoPlayer = playerInstance.domRef.player;

    //if content is playing then no subtitles
    var currentTime = Math.floor(videoPlayer.currentTime);
    var subtitlesAvailable = false;
    var subtitlesContainer = playerInstance.domRef.wrapper.querySelector('.fluid_subtitles_container');
    if (playerInstance.isCurrentlyPlayingAd) {
      subtitlesContainer.innerHTML = '';
      return;
    }
    for (var i = 0; i < playerInstance.subtitlesData.length; i++) {
      if (currentTime >= playerInstance.subtitlesData[i].startTime && currentTime <= playerInstance.subtitlesData[i].endTime) {
        subtitlesContainer.innerHTML = '';
        subtitlesContainer.appendChild(WebVTT.convertCueToDOMTree(window, playerInstance.subtitlesData[i].text));
        subtitlesAvailable = true;
      }
    }
    if (!subtitlesAvailable) {
      subtitlesContainer.innerHTML = '';
    }
  };
  playerInstance.openCloseSubtitlesSwitch = function () {
    var subtitleChangeList = playerInstance.domRef.wrapper.querySelector('.fluid_subtitles_list');
    if (playerInstance.isCurrentlyPlayingAd) {
      subtitleChangeList.style.display = 'none';
      return;
    }
    if (subtitleChangeList.style.display === 'none') {
      subtitleChangeList.style.display = 'block';
      var mouseOut = function mouseOut(event) {
        subtitleChangeList.removeEventListener('mouseleave', mouseOut);
        subtitleChangeList.style.display = 'none';
      };
      subtitleChangeList.addEventListener('mouseleave', mouseOut);
    } else {
      subtitleChangeList.style.display = 'none';
    }
  };
  playerInstance.createSubtitles = function () {
    var divSubtitlesContainer = document.createElement('div');
    divSubtitlesContainer.className = 'fluid_subtitles_container';
    playerInstance.domRef.player.parentNode.insertBefore(divSubtitlesContainer, playerInstance.domRef.player.nextSibling);
    if (!playerInstance.displayOptions.layoutControls.subtitlesEnabled) {
      return;
    }
    Promise.all(/* import() | vttjs */[__webpack_require__.e(407), __webpack_require__.e(721)]).then(__webpack_require__.t.bind(__webpack_require__, 407, 23)).then(function (it) {
      window.WebVTT = it.WebVTT;
      playerInstance.createSubtitlesSwitch();
    });
  };
}
;// CONCATENATED MODULE: ./src/modules/timeline.js
function timeline_typeof(obj) { "@babel/helpers - typeof"; return timeline_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, timeline_typeof(obj); }
/* harmony default export */ function timeline(playerInstance, options) {
  playerInstance.setupThumbnailPreviewVtt = function () {
    playerInstance.sendRequest(playerInstance.displayOptions.layoutControls.timelinePreview.file, true, playerInstance.displayOptions.vastOptions.vastTimeout, function () {
      var convertVttRawData = function convertVttRawData(vttRawData) {
        if (!(typeof vttRawData.cues !== 'undefined' && vttRawData.cues.length)) {
          return [];
        }
        var result = [];
        var tempThumbnailData = null;
        var tempThumbnailCoordinates = null;
        for (var i = 0; i < vttRawData.cues.length; i++) {
          tempThumbnailData = vttRawData.cues[i].text.split('#');
          var xCoords = 0,
            yCoords = 0,
            wCoords = 122.5,
            hCoords = 69;

          // .vtt file contains sprite corrdinates
          if (tempThumbnailData.length === 2 && tempThumbnailData[1].indexOf('xywh=') === 0) {
            tempThumbnailCoordinates = tempThumbnailData[1].substring(5);
            tempThumbnailCoordinates = tempThumbnailCoordinates.split(',');
            if (tempThumbnailCoordinates.length === 4) {
              playerInstance.displayOptions.layoutControls.timelinePreview.spriteImage = true;
              xCoords = parseInt(tempThumbnailCoordinates[0]);
              yCoords = parseInt(tempThumbnailCoordinates[1]);
              wCoords = parseInt(tempThumbnailCoordinates[2]);
              hCoords = parseInt(tempThumbnailCoordinates[3]);
            }
          }
          var imageUrl = void 0;
          if (playerInstance.displayOptions.layoutControls.timelinePreview.spriteRelativePath && playerInstance.displayOptions.layoutControls.timelinePreview.file.indexOf('/') !== -1 && (typeof playerInstance.displayOptions.layoutControls.timelinePreview.sprite === 'undefined' || playerInstance.displayOptions.layoutControls.timelinePreview.sprite === '')) {
            imageUrl = playerInstance.displayOptions.layoutControls.timelinePreview.file.substring(0, playerInstance.displayOptions.layoutControls.timelinePreview.file.lastIndexOf('/'));
            imageUrl += '/' + tempThumbnailData[0];
          } else {
            imageUrl = playerInstance.displayOptions.layoutControls.timelinePreview.sprite ? playerInstance.displayOptions.layoutControls.timelinePreview.sprite : tempThumbnailData[0];
          }
          result.push({
            startTime: vttRawData.cues[i].startTime,
            endTime: vttRawData.cues[i].endTime,
            image: imageUrl,
            x: xCoords,
            y: yCoords,
            w: wCoords,
            h: hCoords
          });
        }
        return result;
      };
      var xmlHttpReq = this;
      if (xmlHttpReq.readyState === 4 && xmlHttpReq.status !== 200) {
        //The response returned an error.
        return;
      }
      if (!(xmlHttpReq.readyState === 4 && xmlHttpReq.status === 200)) {
        return;
      }
      var textResponse = xmlHttpReq.responseText;
      var webVttParser = new window.WebVTTParser();
      var vttRawData = webVttParser.parse(textResponse);
      playerInstance.timelinePreviewData = convertVttRawData(vttRawData);
    });
  };
  playerInstance.generateTimelinePreviewTags = function () {
    var progressContainer = playerInstance.domRef.wrapper.querySelector('.fluid_controls_progress_container');
    var previewContainer = document.createElement('div');
    previewContainer.className = 'fluid_timeline_preview_container';
    previewContainer.style.display = 'none';
    previewContainer.style.position = 'absolute';
    progressContainer.appendChild(previewContainer);

    //Shadow is needed to not trigger mouseleave event, that stops showing thumbnails, in case one scrubs a bit too fast and leaves current thumb before new one drawn.
    var previewContainerShadow = document.createElement('div');
    previewContainerShadow.className = 'fluid_timeline_preview_container_shadow';
    previewContainerShadow.style.position = 'absolute';
    previewContainerShadow.style.display = 'none';
    previewContainerShadow.style.opacity = 1;
    progressContainer.appendChild(previewContainerShadow);
  };
  playerInstance.getThumbnailCoordinates = function (second) {
    if (playerInstance.timelinePreviewData.length) {
      for (var i = 0; i < playerInstance.timelinePreviewData.length; i++) {
        if (second >= playerInstance.timelinePreviewData[i].startTime && second <= playerInstance.timelinePreviewData[i].endTime) {
          return playerInstance.timelinePreviewData[i];
        }
      }
    }
    return false;
  };
  playerInstance.drawTimelinePreview = function (event) {
    var timelinePreviewTag = playerInstance.domRef.wrapper.querySelector('.fluid_timeline_preview_container');
    var timelinePreviewShadow = playerInstance.domRef.wrapper.querySelector('.fluid_timeline_preview_container_shadow');
    var progressContainer = playerInstance.domRef.wrapper.querySelector('.fluid_controls_progress_container');
    var totalWidth = progressContainer.clientWidth;
    if (playerInstance.isCurrentlyPlayingAd) {
      if (timelinePreviewTag.style.display !== 'none') {
        timelinePreviewTag.style.display = 'none';
      }
      return;
    }

    //get the hover position
    var hoverX = playerInstance.getEventOffsetX(event, progressContainer);
    var hoverSecond = null;
    if (totalWidth) {
      hoverSecond = playerInstance.currentVideoDuration * hoverX / totalWidth;

      //get the corresponding thumbnail coordinates
      var thumbnailCoordinates = playerInstance.getThumbnailCoordinates(hoverSecond);
      timelinePreviewShadow.style.width = totalWidth + 'px';
      timelinePreviewShadow.style.display = 'block';
      if (thumbnailCoordinates !== false) {
        timelinePreviewTag.style.width = thumbnailCoordinates.w + 'px';
        timelinePreviewTag.style.height = thumbnailCoordinates.h + 'px';
        timelinePreviewShadow.style.height = thumbnailCoordinates.h + 'px';
        timelinePreviewTag.style.background = 'url(' + thumbnailCoordinates.image + ') no-repeat scroll -' + thumbnailCoordinates.x + 'px -' + thumbnailCoordinates.y + 'px';
        timelinePreviewTag.style.left = hoverX - thumbnailCoordinates.w / 2 + 'px';
        timelinePreviewTag.style.display = 'block';
        if (!playerInstance.displayOptions.layoutControls.timelinePreview.spriteImage) {
          timelinePreviewTag.style.backgroundSize = 'contain';
        }
      } else {
        timelinePreviewTag.style.display = 'none';
      }
    }
  };
  playerInstance.setupThumbnailPreview = function () {
    var timelinePreview = playerInstance.displayOptions.layoutControls.timelinePreview;
    if (!timelinePreview || !timelinePreview.type) {
      return;
    }
    var eventOn = 'mousemove';
    var eventOff = 'mouseleave';
    if (playerInstance.mobileInfo.userOs) {
      eventOn = 'touchmove';
      eventOff = 'touchend';
    }
    playerInstance.domRef.wrapper.querySelector('.fluid_controls_progress_container').addEventListener(eventOn, playerInstance.drawTimelinePreview.bind(playerInstance), false);
    playerInstance.domRef.wrapper.querySelector('.fluid_controls_progress_container').addEventListener(eventOff, function (event) {
      var progress = playerInstance.domRef.wrapper.querySelector('.fluid_controls_progress_container');
      if (typeof event.clientX !== 'undefined' && progress.contains(document.elementFromPoint(event.clientX, event.clientY))) {
        //False positive (Chrome bug when fast click causes leave event)
        return;
      }
      playerInstance.domRef.wrapper.querySelector('.fluid_timeline_preview_container').style.display = 'none';
      playerInstance.domRef.wrapper.querySelector('.fluid_timeline_preview_container_shadow').style.display = 'none';
    }, false);
    playerInstance.generateTimelinePreviewTags();
    if ('VTT' === timelinePreview.type && typeof timelinePreview.file === 'string') {
      __webpack_require__.e(/* import() | webvtt */ 490).then(__webpack_require__.bind(__webpack_require__, 840)).then(function (it) {
        window.WebVTTParser = it.default;
        playerInstance.setupThumbnailPreviewVtt();
      });
    } else if ('static' === timelinePreview.type && timeline_typeof(timelinePreview.frames) === 'object') {
      timelinePreview.spriteImage = true;
      playerInstance.timelinePreviewData = timelinePreview.frames;
    } else {
      throw 'Invalid thumbnail-preview - type must be VTT or static';
    }
    playerInstance.showTimeOnHover = false;
  };
}
;// CONCATENATED MODULE: ./src/modules/adsupport.js
function adsupport_toConsumableArray(arr) { return adsupport_arrayWithoutHoles(arr) || adsupport_iterableToArray(arr) || adsupport_unsupportedIterableToArray(arr) || adsupport_nonIterableSpread(); }
function adsupport_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function adsupport_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function adsupport_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return adsupport_arrayLikeToArray(arr); }
function adsupport_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = adsupport_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function adsupport_slicedToArray(arr, i) { return adsupport_arrayWithHoles(arr) || adsupport_iterableToArrayLimit(arr, i) || adsupport_unsupportedIterableToArray(arr, i) || adsupport_nonIterableRest(); }
function adsupport_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function adsupport_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return adsupport_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return adsupport_arrayLikeToArray(o, minLen); }
function adsupport_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function adsupport_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function adsupport_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
/* harmony default export */ function adsupport(playerInstance, options) {
  var VPAID_VERSION = '2.0';
  playerInstance.renderLinearAd = function (ad, backupTheVideoTime) {
    playerInstance.toggleLoader(false);

    //get the proper ad
    playerInstance.vastOptions = ad;
    if (backupTheVideoTime) {
      playerInstance.backupMainVideoContentTime(ad.rollListId);
    }
    var playVideoPlayer = function playVideoPlayer(ad) {
      playerInstance.switchPlayerToVpaidMode = function (ad) {
        playerInstance.debugMessage('starting function switchPlayerToVpaidMode');
        var vpaidIframe = "fp_" + ad.id + "_fluid_vpaid_iframe";
        var creativeData = {};
        creativeData.AdParameters = ad.adParameters;
        var slotElement = document.createElement('div');
        slotElement.className = 'fluid_vpaid_slot';
        slotElement.setAttribute('adListId', ad.id);
        playerInstance.domRef.player.parentNode.insertBefore(slotElement, vpaidIframe.nextSibling);
        var environmentVars = {
          slot: slotElement,
          videoSlot: playerInstance.domRef.player,
          videoSlotCanAutoPlay: true
        };

        // calls this functions after ad unit is loaded in iframe
        var ver = playerInstance.vpaidAdUnit.handshakeVersion(VPAID_VERSION);
        var compare = playerInstance.compareVersion(VPAID_VERSION, ver);
        if (compare === 1) {
          //VPAID version of ad is lower than we need
          ad.error = true;
          playerInstance.playMainVideoWhenVpaidFails(403);
          return false;
        }
        if (playerInstance.vastOptions.skipoffset !== false) {
          playerInstance.addSkipButton();
        }
        playerInstance.domRef.player.loop = false;
        playerInstance.domRef.player.removeAttribute('controls'); //Remove the default Controls

        playerInstance.vpaidCallbackListenersAttach();
        var mode = playerInstance.fullscreenMode ? 'fullscreen' : 'normal';
        var adWidth = playerInstance.domRef.player.offsetWidth;
        var adHeight = playerInstance.domRef.player.offsetHeight;
        playerInstance.vpaidAdUnit.initAd(adWidth, adHeight, mode, 3000, creativeData, environmentVars);
        var progressbarContainer = playerInstance.domRef.player.parentNode.getElementsByClassName('fluid_controls_currentprogress');
        for (var i = 0; i < progressbarContainer.length; i++) {
          progressbarContainer[i].style.backgroundColor = playerInstance.displayOptions.layoutControls.adProgressColor;
        }
        playerInstance.toggleLoader(false);
        ad.played = true;
        playerInstance.adFinished = false;
      };
      playerInstance.switchPlayerToVastMode = function () {
        // Get the actual duration from the video file if it is not present in the VAST XML
        if (!playerInstance.vastOptions.duration) {
          playerInstance.vastOptions.duration = selectedMediaFile.delivery === 'streaming' ? Infinity : playerInstance.domRef.player.duration;
        }
        if (playerInstance.displayOptions.layoutControls.showCardBoardView) {
          if (!ad.landingPage) {
            playerInstance.addCTAButton(ad.clickthroughUrl);
          } else {
            playerInstance.addCTAButton(ad.landingPage);
          }
        } else {
          var idAdClickable = [undefined, true].includes(playerInstance.displayOptions.vastOptions.adClickable);
          if (playerInstance.rollsById[ad.rollListId].adClickable !== undefined) {
            idAdClickable = playerInstance.rollsById[ad.rollListId].adClickable;
          }
          if (idAdClickable) {
            playerInstance.addClickthroughLayer();
          }
          playerInstance.addCTAButton(ad.landingPage);
        }
        if (playerInstance.vastOptions.skipoffset !== false) {
          playerInstance.addSkipButton();
        }
        playerInstance.domRef.player.loop = false;
        playerInstance.addAdCountdown();
        playerInstance.domRef.player.removeAttribute('controls'); //Remove the default Controls

        playerInstance.vastLogoBehaviour(true);
        var progressbarContainer = playerInstance.domRef.player.parentNode.getElementsByClassName('fluid_controls_currentprogress');
        for (var i = 0; i < progressbarContainer.length; i++) {
          progressbarContainer[i].style.backgroundColor = playerInstance.displayOptions.layoutControls.adProgressColor;
        }
        if (playerInstance.rollsById[ad.rollListId].adText || ad.adText) {
          var adTextToShow = ad.adText ? ad.adText : playerInstance.rollsById[ad.rollListId].adText;
          playerInstance.addAdPlayingText(adTextToShow);
        }
        playerInstance.positionTextElements(ad);
        playerInstance.toggleLoader(false);
        ad.played = true;
        playerInstance.adFinished = false;
        playerInstance.domRef.player.play();

        //Announce the impressions
        playerInstance.trackSingleEvent('impression');
        playerInstance.domRef.player.removeEventListener('loadedmetadata', playerInstance.switchPlayerToVastMode);

        // if in vr mode then do not show
        if (playerInstance.vrMode) {
          var adCountDownTimerText = playerInstance.domRef.wrapper.querySelector('.ad_countdown');
          var ctaButton = playerInstance.domRef.wrapper.querySelector('.fluid_ad_cta');
          var addAdPlayingTextOverlay = playerInstance.domRef.wrapper.querySelector('.fluid_ad_playing');
          var skipBtn = playerInstance.domRef.wrapper.querySelector('.skip_button');
          if (adCountDownTimerText) {
            adCountDownTimerText.style.display = 'none';
          }
          if (ctaButton) {
            ctaButton.style.display = 'none';
          }
          if (addAdPlayingTextOverlay) {
            addAdPlayingTextOverlay.style.display = 'none';
          }
          if (skipBtn) {
            skipBtn.style.display = 'none';
          }
        }
      };
      playerInstance.domRef.player.pause();

      // Remove the streaming objects to prevent errors on the VAST content
      playerInstance.detachStreamers();

      // Try to load multiple
      var selectedMediaFile = playerInstance.getSupportedMediaFileObject(playerInstance.vastOptions.mediaFileList);

      // if player in cardboard mode then, linear ads media type should be a '360' video
      if (playerInstance.displayOptions.layoutControls.showCardBoardView && ad.mediaType !== '360') {
        ad.error = true;
        playerInstance.playMainVideoWhenVastFails(403);
        return false;
      }
      var isVpaid = playerInstance.vastOptions.vpaid;
      if (!isVpaid && selectedMediaFile.isUnsuportedHls) {
        __webpack_require__.e(/* import() | hlsjs */ 602).then(__webpack_require__.bind(__webpack_require__, 41)).then(function (it) {
          window.Hls = it.default;
          var hls = new Hls({
            debug:  true && false === true,
            p2pConfig: {
              logLevel: false
            },
            enableWebVTT: false,
            enableCEA708Captions: false
          });
          hls.attachMedia(playerInstance.domRef.player);
          hls.loadSource(selectedMediaFile.src);
          playerInstance.isCurrentlyPlayingAd = true;
          playerInstance.hlsPlayer = hls;
          playerInstance.domRef.player.addEventListener('loadedmetadata', playerInstance.switchPlayerToVastMode);
          playerInstance.domRef.player.addEventListener('ended', function () {
            hls.detachMedia();
            hls.destroy();
            playerInstance.hlsPlayer = false;
            playerInstance.onVastAdEnded();
          });
          playerInstance.domRef.player.play();
        });
      } else if (!isVpaid) {
        if (selectedMediaFile.src === false) {
          // Couldn’t find MediaFile that is supported by this video player, based on the attributes of the MediaFile element.
          ad.error = true;
          playerInstance.playMainVideoWhenVastFails(403);
          return false;
        }
        playerInstance.domRef.player.addEventListener('loadedmetadata', playerInstance.switchPlayerToVastMode);
        playerInstance.domRef.player.src = selectedMediaFile.src;
        playerInstance.isCurrentlyPlayingAd = true;
        if (playerInstance.displayOptions.vastOptions.showProgressbarMarkers) {
          playerInstance.hideAdMarkers();
        }
        playerInstance.domRef.player.load();

        //Handle the ending of the Pre-Roll ad
        playerInstance.domRef.player.addEventListener('ended', playerInstance.onVastAdEnded);
      } else {
        playerInstance.loadVpaid(ad, selectedMediaFile.src);
        if (playerInstance.displayOptions.vastOptions.showProgressbarMarkers) {
          playerInstance.hideAdMarkers();
        }
      }
    };

    /**
     * Sends requests to the tracking URIs
     */
    var videoPlayerTimeUpdate = function videoPlayerTimeUpdate() {
      if (playerInstance.adFinished) {
        playerInstance.domRef.player.removeEventListener('timeupdate', videoPlayerTimeUpdate);
        return;
      }
      var currentTime = Math.floor(playerInstance.domRef.player.currentTime);
      if (playerInstance.vastOptions.duration !== 0) {
        playerInstance.scheduleTrackingEvent(currentTime, playerInstance.vastOptions.duration);
      }
      if (currentTime >= playerInstance.vastOptions.duration - 1 && playerInstance.vastOptions.duration !== 0) {
        playerInstance.domRef.player.removeEventListener('timeupdate', videoPlayerTimeUpdate);
        playerInstance.adFinished = true;
      }
    };
    playVideoPlayer(ad);
    playerInstance.domRef.player.addEventListener('timeupdate', videoPlayerTimeUpdate);
  };
  playerInstance.playRoll = function (adList) {
    // register all the ad pods
    var newPods = [];
    for (var i = 0; i < adList.length; i++) {
      newPods.push(adList[i]);
    }
    playerInstance.temporaryAdPods = newPods;
    if (playerInstance.vastOptions !== null && playerInstance.vastOptions.adType.toLowerCase() === 'linear') {
      return;
    }
    var adToPlay = playerInstance.getNextAdPod();
    if (adToPlay !== null) {
      playerInstance.renderLinearAd(adToPlay, true);
    }
  };
  playerInstance.backupMainVideoContentTime = function (rollListId) {
    var roll = playerInstance.rollsById[rollListId].roll;

    //spec configs by roll
    switch (roll) {
      case 'midRoll':
        playerInstance.domRef.player.mainVideoCurrentTime = playerInstance.domRef.player.currentTime - 1;
        break;
      case 'postRoll':
        playerInstance.domRef.player.mainVideoCurrentTime = playerInstance.mainVideoDuration;
        playerInstance.autoplayAfterAd = false;
        playerInstance.domRef.player.currentTime = playerInstance.mainVideoDuration;
        break;
      case 'preRoll':
        if (playerInstance.domRef.player.currentTime > 0) {
          playerInstance.domRef.player.mainVideoCurrentTime = playerInstance.domRef.player.currentTime - 1;
        }
        break;
    }
  };
  playerInstance.getSupportedMediaFileObject = function (mediaFiles) {
    var selectedMediaFile = null;
    var adSupportedType = false;
    if (mediaFiles.length) {
      for (var i = 0; i < mediaFiles.length; i++) {
        if (mediaFiles[i].apiFramework !== 'VPAID') {
          var supportLevel = playerInstance.getMediaFileTypeSupportLevel(mediaFiles[i]['type']);
          if (supportLevel === 'maybe' || supportLevel === 'probably') {
            selectedMediaFile = mediaFiles[i];
            adSupportedType = true;
          }

          //one of the best(s) option, no need to seek more
          if (supportLevel === 'probably') {
            break;
          }
          if (supportLevel === 'no' && mediaFiles[i].delivery === 'streaming' && (mediaFiles[i].type === 'application/vnd.apple.mpegurl' || mediaFiles[i].type === 'application/x-mpegURL')) {
            selectedMediaFile = mediaFiles[i];
            selectedMediaFile.isUnsuportedHls = true;
            adSupportedType = true;
          }
        } else {
          selectedMediaFile = mediaFiles[i];
          adSupportedType = true;
          break;
        }
      }
    }
    if (adSupportedType === false) {
      return false;
    }
    return selectedMediaFile;
  };

  /**
   * Reports how likely it is that the current browser will be able to play media of a given MIME type.
   * @return string|null "probably", "maybe", "no" or null
   */
  playerInstance.getMediaFileTypeSupportLevel = function (mediaType) {
    if (null === mediaType) {
      return null;
    }
    var tmpVideo = document.createElement('video');
    var response = tmpVideo.canPlayType(mediaType);
    return !response ? "no" : response;
  };
  playerInstance.scheduleTrackingEvent = function (currentTime, duration) {
    if (currentTime === 0) {
      playerInstance.trackSingleEvent('start');
      playerInstance.observe();
      playerInstance.domRef.player.timeInView = 0;
    }

    // View Impression is defined by IAB as: Watching at least 2 seconds of the video where at least 50% of the ad’s pixels are visible on the screen
    if (playerInstance.domRef.player.inView) {
      if (playerInstance.domRef.player.timeInView > 2) {
        playerInstance.trackSingleEvent('viewImpression');
      } else {
        playerInstance.domRef.player.timeInView += currentTime;
      }
    }
    if (typeof playerInstance.vastOptions.tracking['progress'] !== 'undefined' && playerInstance.vastOptions.tracking['progress'].length && typeof playerInstance.vastOptions.tracking['progress'][currentTime] !== 'undefined') {
      playerInstance.trackSingleEvent('progress', currentTime);
    }
    if (currentTime === Math.floor(duration / 4)) {
      playerInstance.trackSingleEvent('firstQuartile');
    }
    if (currentTime === Math.floor(duration / 2)) {
      playerInstance.trackSingleEvent('midpoint');
    }
    if (currentTime === Math.floor(duration * 3 / 4)) {
      playerInstance.trackSingleEvent('thirdQuartile');
    }
    if (currentTime >= duration - 1) {
      playerInstance.trackSingleEvent('complete');
    }
  };

  // ADS
  playerInstance.trackSingleEvent = function (eventType, eventSubType) {
    if (typeof playerInstance.vastOptions === 'undefined' || playerInstance.vastOptions === null) {
      return;
    }
    var trackingUris = [];
    trackingUris.length = 0;
    switch (eventType) {
      case 'start':
      case 'firstQuartile':
      case 'midpoint':
      case 'thirdQuartile':
      case 'complete':
        if (playerInstance.vastOptions.stopTracking[eventType] === false) {
          if (playerInstance.vastOptions.tracking[eventType] !== null) {
            trackingUris = playerInstance.vastOptions.tracking[eventType];
          }
          playerInstance.vastOptions.stopTracking[eventType] = true;
        }
        break;
      case 'progress':
        playerInstance.vastOptions.tracking['progress'][eventSubType].elements.forEach(function (currentValue, index) {
          if (playerInstance.vastOptions.tracking['progress'][eventSubType].stopTracking === false && playerInstance.vastOptions.tracking['progress'][eventSubType].elements.length) {
            trackingUris = playerInstance.vastOptions.tracking['progress'][eventSubType].elements;
          }
          playerInstance.vastOptions.tracking['progress'][eventSubType].stopTracking = true;
        });
        break;
      case 'impression':
        if (typeof playerInstance.vastOptions.impression !== 'undefined' && playerInstance.vastOptions.impression !== null && typeof playerInstance.vastOptions.impression.length !== 'undefined') {
          trackingUris = playerInstance.vastOptions.impression;
        }
        break;
      case 'viewImpression':
        if (playerInstance.vastOptions.stopTracking['viewImpression'] === true) {
          break;
        }
        if (typeof playerInstance.vastOptions.viewImpression !== 'undefined' && playerInstance.vastOptions.viewImpression !== null && typeof playerInstance.vastOptions.viewImpression.length !== 'undefined') {
          trackingUris = playerInstance.vastOptions.viewImpression;
          playerInstance.vastOptions.stopTracking['viewImpression'] = true;
        }
        break;
      default:
        break;
    }
    playerInstance.callUris(trackingUris);
  };

  // ADS
  playerInstance.completeNonLinearStatic = function (ad) {
    playerInstance.closeNonLinear(ad.id);
    if (playerInstance.adFinished === false) {
      playerInstance.adFinished = true;
      playerInstance.trackSingleEvent('complete');
    }
    clearInterval(playerInstance.nonLinearTracking);
  };

  // ADS
  /**
   * Show up a nonLinear static creative
   */
  playerInstance.createNonLinearStatic = function (ad) {
    //get the proper ad
    playerInstance.vastOptions = ad;
    playerInstance.createBoard(ad);
    if (playerInstance.rollsById[ad.rollListId].error === true || ad.error === true) {
      playerInstance.announceLocalError(101);
      return;
    }
    playerInstance.adFinished = false;
    var duration = playerInstance.rollsById[ad.rollListId].nonLinearDuration ? playerInstance.rollsById[ad.rollListId].nonLinearDuration : false;
    if (!playerInstance.vastOptions.vpaid) {
      playerInstance.trackSingleEvent('start');
      duration = duration || playerInstance.vastOptions.duration;
      playerInstance.nonLinearTracking = setInterval(function () {
        if (playerInstance.adFinished === true) {
          return;
        }
        var currentTime = Math.floor(playerInstance.domRef.player.currentTime);
        playerInstance.scheduleTrackingEvent(currentTime, duration);
        if (currentTime >= duration - 1) {
          playerInstance.adFinished = true;
        }
      }, 400);
      playerInstance.destructors.push(function () {
        return clearInterval(playerInstance.nonLinearTracking);
      });
    }
    var time = parseInt(playerInstance.getCurrentTime()) + parseInt(duration);
    playerInstance.scheduleTask({
      time: time,
      closeStaticAd: ad,
      rollListId: ad.rollListId
    });
  };

  // ADS
  playerInstance.createVpaidNonLinearBoard = function (ad) {
    // create iframe
    // pass the js

    playerInstance.loadVpaidNonlinearAssets = function (ad) {
      playerInstance.vastOptions = ad;
      playerInstance.debugMessage('starting function switchPlayerToVpaidMode');
      var vAlign = ad.vAlign ? ad.vAlign : playerInstance.nonLinearVerticalAlign;
      var showCloseButton = ad.vpaidNonLinearCloseButton ? ad.vpaidNonLinearCloseButton : playerInstance.vpaidNonLinearCloseButton;
      var vpaidIframe = "fp_" + ad.id + "_fluid_vpaid_iframe";
      var creativeData = {};
      creativeData.AdParameters = ad.adParameters;
      var slotWrapper = document.createElement('div');
      slotWrapper.id = 'fluid_vpaidNonLinear_' + ad.id;
      slotWrapper.className = 'fluid_vpaidNonLinear_' + vAlign;
      slotWrapper.className += ' fluid_vpaidNonLinear_ad';
      slotWrapper.setAttribute('adListId', ad.id);

      // Default values in case nothing defined in VAST data or ad settings
      var adWidth = Math.min(468, playerInstance.domRef.player.offsetWidth);
      var adHeight = Math.min(60, Math.floor(playerInstance.domRef.player.offsetHeight / 4));
      if (typeof ad.size !== 'undefined') {
        var dimensions = ad.size.split('x');
        adWidth = dimensions[0];
        adHeight = dimensions[1];
      } else if (ad.dimension.width && ad.dimension.height) {
        adWidth = ad.dimension.width;
        adHeight = ad.dimension.height;
      }
      slotWrapper.style.width = '100%';
      slotWrapper.style.height = adHeight + 'px';
      var slotFrame;
      if (showCloseButton) {
        var _slotFrame = document.createElement('div');
        _slotFrame.className = 'fluid_vpaidNonLinear_frame';
        _slotFrame.style.width = adWidth + 'px';
        _slotFrame.style.height = adHeight + 'px';
        slotWrapper.appendChild(_slotFrame);
        var closeBtn = document.createElement('div');
        closeBtn.className = 'close_button';
        closeBtn.innerHTML = '';
        closeBtn.title = playerInstance.displayOptions.layoutControls.closeButtonCaption;
        var _ad$id$split = ad.id.split('_'),
          _ad$id$split2 = adsupport_slicedToArray(_ad$id$split, 1),
          tempadListId = _ad$id$split2[0];
        closeBtn.onclick = function (event) {
          playerInstance.hardStopVpaidAd('');
          if (typeof event.stopImmediatePropagation !== 'undefined') {
            event.stopImmediatePropagation();
          }
          playerInstance.adFinished = true;

          //if any other onPauseRoll then render it
          if (playerInstance.rollsById[tempadListId].roll === 'onPauseRoll' && playerInstance.onPauseRollAdPods[0]) {
            var getNextOnPauseRollAd = playerInstance.onPauseRollAdPods[0];
            playerInstance.createBoard(getNextOnPauseRollAd);
            playerInstance.currentOnPauseRollAd = playerInstance.onPauseRollAdPods[0];
            delete playerInstance.onPauseRollAdPods[0];
          }
          return false;
        };
        _slotFrame.appendChild(closeBtn);
      }
      var slotIframe = document.createElement('iframe');
      slotIframe.id = playerInstance.videoPlayerId + 'non_linear_vapid_slot_iframe';
      slotIframe.className = 'fluid_vpaid_nonlinear_slot_iframe';
      slotIframe.setAttribute('width', adWidth + 'px');
      slotIframe.setAttribute('height', adHeight + 'px');
      slotIframe.setAttribute('sandbox', 'allow-forms allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts');
      slotIframe.setAttribute('frameborder', '0');
      slotIframe.setAttribute('scrolling', 'no');
      slotIframe.setAttribute('marginwidth', '0');
      slotIframe.setAttribute('marginheight', '0');
      slotWrapper.appendChild(slotIframe);
      playerInstance.domRef.player.parentNode.insertBefore(slotWrapper, vpaidIframe.nextSibling);
      var slotElement = slotIframe.contentWindow.document.createElement('div');
      slotIframe.contentWindow.document.body.appendChild(slotElement);
      playerInstance.vastOptions.slotIframe = slotIframe;
      playerInstance.vastOptions.slotFrame = slotFrame;
      var environmentVars = {
        slot: slotElement,
        videoSlot: playerInstance.domRef.player,
        videoSlotCanAutoPlay: true
      };
      playerInstance.debugMessage(ad);

      // calls this functions after ad unit is loaded in iframe
      var ver = playerInstance.vpaidAdUnit.handshakeVersion(VPAID_VERSION);
      var compare = playerInstance.compareVersion(VPAID_VERSION, ver);
      if (compare === 1) {
        //VPAID version of ad is lower than we need
        ad.error = true;
        playerInstance.playMainVideoWhenVpaidFails(403);
        return false;
      }
      playerInstance.domRef.player.loop = false;
      playerInstance.domRef.player.removeAttribute('controls'); //Remove the default Controls

      playerInstance.vpaidCallbackListenersAttach();
      var mode = playerInstance.fullscreenMode ? 'fullscreen' : 'normal';
      playerInstance.vpaidAdUnit.initAd(adWidth, adHeight, mode, 3000, creativeData, environmentVars);
      playerInstance.toggleLoader(false);
      ad.played = true;
      playerInstance.adFinished = false;
    };
    playerInstance.loadVpaid(ad, ad.staticResource);
    playerInstance.debugMessage('create non linear vpaid');
  };

  // ADS
  playerInstance.createNonLinearBoard = function (ad) {
    ad.played = true;
    var board = document.createElement('div');
    var vAlign = playerInstance.rollsById[ad.rollListId].vAlign ? playerInstance.rollsById[ad.rollListId].vAlign : playerInstance.nonLinearVerticalAlign;
    var creative = new Image();
    creative.src = ad.staticResource;
    creative.id = 'fluid_nonLinear_imgCreative_' + ad.id + '_' + playerInstance.videoPlayerId;
    creative.onerror = function () {
      playerInstance.rollsById[ad.rollListId].error = true;
      playerInstance.announceError(500);
    };
    creative.onload = function () {
      var playerWidth = playerInstance.domRef.player.clientWidth;
      var origWidth;
      var origHeight;
      var newBannerWidth;
      var newBannerHeight;

      //Set banner size based on the below priority
      // 1. adList -> roll -> size
      // 2. VAST XML width/height attriubute (VAST 3.)
      // 3. VAST XML static resource dimension
      if (typeof playerInstance.rollsById[ad.rollListId].size !== 'undefined') {
        origWidth = playerInstance.rollsById[ad.rollListId].size.split('x')[0];
        origHeight = playerInstance.rollsById[ad.rollListId].size.split('x')[1];
      } else if (ad.dimension.width && ad.dimension.height) {
        origWidth = ad.dimension.width;
        origHeight = ad.dimension.height;
      } else {
        origWidth = creative.width;
        origHeight = creative.height;
      }
      if (origWidth > playerWidth) {
        newBannerWidth = playerWidth - 5;
        newBannerHeight = origHeight * newBannerWidth / origWidth;
      } else {
        newBannerWidth = origWidth;
        newBannerHeight = origHeight;
      }
      if (playerInstance.rollsById[ad.rollListId].roll !== 'onPauseRoll') {
        //Show the board only if media loaded
        var nonLinear = playerInstance.domRef.wrapper.querySelector('#fluid_nonLinear_' + ad.id);
        if (nonLinear) {
          nonLinear.style.display = '';
        }
      }
      var img = playerInstance.domRef.wrapper.querySelector('#' + creative.id);
      img.width = newBannerWidth;
      img.height = newBannerHeight;
      playerInstance.trackSingleEvent('impression');
    };
    board.id = 'fluid_nonLinear_' + ad.id;
    board.className = 'fluid_nonLinear_' + vAlign;
    board.className += ' fluid_nonLinear_ad';
    board.innerHTML = creative.outerHTML;
    board.style.display = 'none';

    //Bind the Onclick event
    board.onclick = function () {
      if (typeof ad.clickthroughUrl !== 'undefined') {
        window.open(ad.clickthroughUrl);
      }

      //Tracking the NonLinearClickTracking events
      if (typeof ad.clicktracking !== 'undefined') {
        playerInstance.callUris([ad.clicktracking]);
      }
    };
    if (typeof ad.clickthroughUrl !== 'undefined') {
      board.style.cursor = 'pointer';
    }
    var closeBtn = document.createElement('div');
    closeBtn.className = 'close_button';
    closeBtn.innerHTML = '';
    closeBtn.title = playerInstance.displayOptions.layoutControls.closeButtonCaption;
    var tempRollListId = ad.rollListId;
    closeBtn.onclick = function (event) {
      this.parentElement.remove();
      if (typeof event.stopImmediatePropagation !== 'undefined') {
        event.stopImmediatePropagation();
      }
      playerInstance.adFinished = true;
      clearInterval(playerInstance.nonLinearTracking);

      //if any other onPauseRoll then render it
      if (playerInstance.rollsById[tempRollListId].roll === 'onPauseRoll' && playerInstance.onPauseRollAdPods[0]) {
        var getNextOnPauseRollAd = playerInstance.onPauseRollAdPods[0];
        playerInstance.createBoard(getNextOnPauseRollAd);
        playerInstance.currentOnPauseRollAd = playerInstance.onPauseRollAdPods[0];
        delete playerInstance.onPauseRollAdPods[0];
      }
      return false;
    };
    board.appendChild(closeBtn);
    playerInstance.domRef.player.parentNode.insertBefore(board, playerInstance.domRef.player.nextSibling);
  };

  // ADS
  /**
   * Adds a nonLinear static Image banner
   *
   * currently only image/gif, image/jpeg, image/png supported
   */
  playerInstance.createBoard = function (ad) {
    // create nonLinear Vpaid
    // create nonLinear regular
    if (ad.vpaid) {
      playerInstance.hardStopVpaidAd('');
      playerInstance.createVpaidNonLinearBoard(ad);
    } else {
      if (typeof ad.staticResource === 'undefined' || playerInstance.supportedStaticTypes.indexOf(ad.creativeType) === -1) {
        // Couldn’t find NonLinear resource with supported type.
        ad.error = true;
        if (!playerInstance.vastOptions || typeof playerInstance.vastOptions.errorUrl === 'undefined') {
          playerInstance.announceLocalError(503);
        } else {
          playerInstance.announceError(503);
        }
        return;
      }
      playerInstance.createNonLinearBoard(ad);
    }
  };
  playerInstance.closeNonLinear = function (adId) {
    var element = playerInstance.domRef.wrapper.querySelector('#fluid_nonLinear_' + adId + ', #fluid_vpaidNonLinear_' + adId);
    if (element) {
      element.remove();
    }
  };
  playerInstance.rollGroupContainsLinear = function (groupedRolls) {
    var found = false;
    for (var i = 0; i < groupedRolls.length; i++) {
      if (playerInstance.rollsById[groupedRolls[i].id].adType && playerInstance.rollsById[groupedRolls[i].id].adType === 'linear') {
        found = true;
        break;
      }
    }
    return found;
  };
  playerInstance.rollGroupContainsNonlinear = function (groupedRolls) {
    var found = false;
    for (var i = 0; i < groupedRolls.length; i++) {
      if (playerInstance.rollsById[groupedRolls[i].id].adType.toLowerCase() === 'nonlinear') {
        found = true;
        break;
      }
    }
    return found;
  };
  playerInstance.preRollFail = function () {
    var preRollsLength = playerInstance.preRollAdPodsLength;
    playerInstance.preRollVastResolved++;
    if (playerInstance.preRollVastResolved === preRollsLength) {
      playerInstance.preRollAdsPlay();
    }
  };
  playerInstance.preRollSuccess = function () {
    var preRollsLength = playerInstance.preRollAdPodsLength;
    playerInstance.preRollVastResolved++;
    if (playerInstance.preRollVastResolved === preRollsLength) {
      playerInstance.preRollAdsPlay();
    }
  };
  playerInstance.preRollAdsPlay = function () {
    var time = 0;
    var rollListIds = playerInstance.preRollAdPods;
    var adsByType = {
      linear: [],
      nonLinear: []
    };
    playerInstance.firstPlayLaunched = true;
    for (var index = 0; index < rollListIds.length; index++) {
      playerInstance.rollsById[rollListIds[index]].ads.forEach(function (ad) {
        if (ad.played === true) {
          return;
        }
        if (ad.adType === 'linear') {
          adsByType.linear.push(ad);
        }
        if (ad.adType === 'nonLinear') {
          adsByType.nonLinear.push(ad);
          playerInstance.scheduleTask({
            time: time,
            playRoll: 'midRoll',
            rollListId: ad.rollListId
          });
        }
      });
    }
    if (adsByType.linear.length > 0) {
      playerInstance.toggleLoader(false);
      playerInstance.playRoll(adsByType.linear);
    } else {
      playerInstance.playMainVideoWhenVastFails(900);
    }
  };
  playerInstance.preRoll = function (event) {
    var vastObj = event.vastObj;
    playerInstance.domRef.player.removeEventListener(event.type, playerInstance.preRoll);
    var rollListIds = [];
    rollListIds[0] = event.type.replace('adId_', '');
    var time = 0;
    if (playerInstance.rollsById[rollListIds[0]].played === true) {
      return;
    }
    playerInstance.preRollAdPods.push(rollListIds[0]);
    playerInstance.preRollSuccess(vastObj);
  };
  playerInstance.createAdMarker = function (adListId, time) {
    var markersHolder = playerInstance.domRef.wrapper.querySelector('.fluid_controls_ad_markers_holder');
    var adMarker = document.createElement('div');
    adMarker.className = 'fluid_controls_ad_marker fluid_controls_ad_marker_' + adListId;
    adMarker.dataset.adListId = adListId;
    adMarker.style.left = time / playerInstance.mainVideoDuration * 100 + '%';
    if (playerInstance.isCurrentlyPlayingAd) {
      adMarker.style.display = 'none';
    }
    markersHolder.appendChild(adMarker);
  };
  playerInstance.hideAdMarker = function (adListId) {
    var element = playerInstance.domRef.wrapper.querySelector('fluid_controls_ad_marker_' + adListId);
    if (element) {
      element.style.display = 'none';
    }
  };
  playerInstance.showAdMarkers = function () {
    var markersHolder = playerInstance.domRef.wrapper.querySelector('.fluid_controls_ad_markers_holder');
    var adMarkers = markersHolder.getElementsByClassName('fluid_controls_ad_marker');
    for (var i = 0; i < adMarkers.length; ++i) {
      var item = adMarkers[i];
      var rollListId = item.dataset.adListId;
      if (playerInstance.rollsById[rollListId].played === false) {
        item.style.display = '';
      }
    }
  };
  playerInstance.hideAdMarkers = function () {
    var markersHolder = playerInstance.domRef.wrapper.querySelector('.fluid_controls_ad_markers_holder');
    var adMarkers = markersHolder.getElementsByClassName('fluid_controls_ad_marker');
    for (var i = 0; i < adMarkers.length; ++i) {
      var item = adMarkers[i];
      item.style.display = 'none';
    }
  };
  playerInstance.midRoll = function (event) {
    playerInstance.domRef.player.removeEventListener(event.type, playerInstance.midRoll);
    var rollListId = event.type.replace('adId_', '');
    if (playerInstance.rollsById[rollListId].played === true) {
      return;
    }
    var time = playerInstance.rollsById[rollListId].timer;
    if (typeof time == 'string' && time.indexOf("%") !== -1) {
      time = time.replace('%', '');
      time = Math.floor(playerInstance.mainVideoDuration / 100 * time);
    }
    if (playerInstance.displayOptions.vastOptions.showProgressbarMarkers && playerInstance.rollsById[rollListId].adType === "nonLinear") {
      playerInstance.createAdMarker(rollListId, time);
    }
    playerInstance.scheduleTask({
      time: time,
      playRoll: 'midRoll',
      rollListId: rollListId
    });
  };
  playerInstance.postRoll = function (event) {
    playerInstance.domRef.player.removeEventListener(event.type, playerInstance.postRoll);
    var rollListId = event.type.replace('adId_', '');
    playerInstance.scheduleTask({
      time: Math.floor(playerInstance.mainVideoDuration),
      playRoll: 'postRoll',
      rollListId: rollListId
    });
  };
  playerInstance.onPauseRoll = function (event) {
    playerInstance.domRef.player.removeEventListener(event.type, playerInstance.onPauseRoll);
    var rollListId = event.type.replace('adId_', '');
    playerInstance.rollsById[rollListId].ads.forEach(function (ad) {
      if (ad.adType === 'nonLinear') {
        if (playerInstance.rollsById[ad.rollListId].error === true || ad.error === true) {
          playerInstance.announceLocalError(101);
          return;
        }
        var nonLinearAdExists = playerInstance.domRef.wrapper.getElementsByClassName('fluid_nonLinear_ad')[0];
        if (!nonLinearAdExists) {
          playerInstance.createBoard(ad);
          playerInstance.currentOnPauseRollAd = rollListId;
          var onPauseAd = '';
          var _iterator = adsupport_createForOfIteratorHelper(playerInstance.domRef.wrapper.children),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var child = _step.value;
              if (child.id === 'fluid_nonLinear_' + rollListId) {
                onPauseAd = child;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (onPauseAd) {
            onPauseAd.style.display = 'none';
          }
        } else {
          playerInstance.onPauseRollAdPods.push(rollListId);
        }
      }
    });
  };

  /**
   * Check if player has a valid nonLinear onPause Ad
   */
  playerInstance.hasValidOnPauseAd = function () {
    // TODO should be only one. Add validator to allow only one onPause roll
    var onPauseAd = playerInstance.findRoll('onPauseRoll');
    return onPauseAd.length !== 0 && playerInstance.rollsById[onPauseAd[0]] && playerInstance.rollsById[onPauseAd[0]].error === false && playerInstance.rollsById[onPauseAd[0]].ads.length && playerInstance.rollsById[onPauseAd[0]].ads[0].error !== true;
  };

  /**
   * Hide/show nonLinear onPause Ad
   */
  playerInstance.toggleOnPauseAd = function () {
    playerInstance.toggleLoader(false);
    if (playerInstance.hasValidOnPauseAd() && !playerInstance.isCurrentlyPlayingAd) {
      var onPauseRoll = playerInstance.findRoll('onPauseRoll');
      var ad = playerInstance.rollsById[onPauseRoll].ads[0];
      playerInstance.vastOptions = ad;
      var onPauseAd = '';
      var _iterator2 = adsupport_createForOfIteratorHelper(playerInstance.domRef.wrapper.children),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;
          if (child.id === 'fluid_nonLinear_' + ad.id) {
            onPauseAd = child;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (onPauseAd && playerInstance.domRef.player.paused) {
        setTimeout(function () {
          onPauseAd.style.display = 'flex';
          ad.played = false;
          playerInstance.trackingOnPauseNonLinearAd(ad, 'start');
        }, 500);
      } else if (onPauseAd && !playerInstance.domRef.player.paused) {
        onPauseAd.style.display = 'none';
        playerInstance.adFinished = true;
        playerInstance.trackingOnPauseNonLinearAd(ad, 'complete');
      }
    }
  };

  /**
   * Helper function for tracking onPause Ads
   */
  playerInstance.trackingOnPauseNonLinearAd = function (ad, status) {
    if (playerInstance.rollsById[ad.rollListId].error === true || ad.error === true) {
      playerInstance.announceLocalError(101);
      return;
    }
    playerInstance.vastOptions = ad;
    playerInstance.trackSingleEvent(status);
  };
  playerInstance.getLinearAdsFromKeyTime = function (keyTimeLinearObj) {
    var adListIds = [];
    for (var i = 0; i < keyTimeLinearObj.length; i++) {
      if (playerInstance.rollsById[keyTimeLinearObj[i].adListId].played === false) {
        adListIds.push(keyTimeLinearObj[i].adListId);
      }
    }
    return adListIds;
  };

  /**
   * Handle scheduled tasks for a given key time
   *
   * @param keyTime key time in seconds
   */
  playerInstance.adKeytimePlay = function (keyTime) {
    if (!playerInstance.timerPool[keyTime] || playerInstance.isCurrentlyPlayingAd) {
      return;
    }
    var timerPoolKeytimeCloseStaticAdsLength = playerInstance.timerPool[keyTime]['closeStaticAd'].length;
    var timerPoolKeytimeLinearAdsLength = playerInstance.timerPool[keyTime]['linear'].length;
    var timerPoolKeytimeNonlinearAdsLength = playerInstance.timerPool[keyTime]['nonLinear'].length;
    var timerPoolKeytimeLoadVastLength = playerInstance.timerPool[keyTime]['loadVast'].length;

    // remove the item from keytime if no ads to play
    if ([timerPoolKeytimeCloseStaticAdsLength, timerPoolKeytimeLinearAdsLength, timerPoolKeytimeNonlinearAdsLength, timerPoolKeytimeLoadVastLength].every(function (timerPoolLength) {
      return timerPoolLength === 0;
    })) {
      delete playerInstance.timerPool[keyTime];
      return;
    }

    // Task: close nonLinear ads
    if (timerPoolKeytimeCloseStaticAdsLength > 0) {
      for (var index = 0; index < timerPoolKeytimeCloseStaticAdsLength; index++) {
        var adToClose = playerInstance.timerPool[keyTime]['closeStaticAd'][index];
        if (adToClose.played === true) {
          playerInstance.completeNonLinearStatic(adToClose);
        }
      }

      // empty closeStaticAd from the timerpool after closing
      playerInstance.timerPool[keyTime]['closeStaticAd'] = [];
    }

    // Task: play linear ads
    if (timerPoolKeytimeLinearAdsLength > 0) {
      if (playerInstance.timerPool[keyTime]['linear'].length > 0) {
        playerInstance.playRoll(playerInstance.timerPool[keyTime]['linear']);

        // empty the linear ads from the timerpool after played
        playerInstance.timerPool[keyTime]['linear'] = [];

        // return after starting video ad, so non-linear will not overlap
        return;
      }
    }

    // Task: play nonLinear ads
    if (timerPoolKeytimeNonlinearAdsLength > 0) {
      for (var _index = 0; _index < timerPoolKeytimeNonlinearAdsLength; _index++) {
        var ad = playerInstance.timerPool[keyTime]['nonLinear'][_index];
        var rollListId = ad.rollListId;
        var vastOptions = playerInstance.adPool[rollListId];

        // we are not supporting nonLinear ads in cardBoard mode
        if (ad.played === false && !playerInstance.displayOptions.layoutControls.showCardBoardView) {
          playerInstance.createNonLinearStatic(ad);
          if (playerInstance.displayOptions.vastOptions.showProgressbarMarkers) {
            playerInstance.hideAdMarker(rollListId);
          }

          // delete nonLinear after playing
          playerInstance.timerPool[keyTime]['nonLinear'].splice(_index, 1);

          // return after starting non-linear ad, so multiple non-linear will not overlap
          // unplayed non-linear will appear if user seeks back to the time :)
          return;
        }
      }
    }

    // Task: Load VAST on demand
    if (timerPoolKeytimeLoadVastLength > 0) {
      playerInstance.timerPool[keyTime]['loadVast'].forEach(function (roll) {
        if (roll.roll === "postRoll" && roll.voidPostRollTasks) {
          // As postRoll schedules more than one task to cover the last few seconds of the video, we need to
          // prevent any other loadVast task from running for that postRoll
          return;
        } else if (roll.roll === "postRoll") {
          roll.voidPostRollTasks = true;
        }
        playerInstance.debugMessage("Handling on-demand VAST load for roll ".concat(roll.id));
        playerInstance.processVastWithRetries(roll);
      });
      playerInstance.timerPool[keyTime]['loadVast'] = [];
    }
  };
  playerInstance.adTimer = function () {
    if (!!playerInstance.isTimer) {
      return;
    }
    playerInstance.isTimer = !playerInstance.isTimer;
    playerInstance.timer = setInterval(function () {
      var keyTime = Math.floor(playerInstance.getCurrentTime());
      playerInstance.adKeytimePlay(keyTime);
    }, 800);
    playerInstance.destructors.push(function () {
      return playerInstance.timer;
    });
  };

  /**
   * Schedule tasks that need to be run with the main video timer
   *
   * @param {{ time: number, rollListId: any, loadVast: any }} task
   */
  playerInstance.scheduleTask = function (task) {
    if (task.time > playerInstance.mainVideoDuration || task.time < 0 || Number.isNaN(task.time)) {
      console.warn("Scheduled task has invalid time", task.time, '. Check your configuration.');
      return;
    }
    playerInstance.debugMessage("Scheduling task", task);
    if (!playerInstance.timerPool.hasOwnProperty(task.time)) {
      playerInstance.timerPool[task.time] = {
        linear: [],
        nonLinear: [],
        closeStaticAd: [],
        loadVast: []
      };
    }

    // Handle AD rendering
    if (task.rollListId) {
      var roll = playerInstance.rollsById[task.rollListId];
      roll.ads.filter(function (_ref) {
        var adType = _ref.adType;
        if (task.time === 0) {
          // Only non-linear should be scheduled on "preRoll"
          return adType !== 'linear';
        }
        return true;
      }).forEach(function (ad) {
        if (task.hasOwnProperty('playRoll') && ad.adType === 'linear') {
          playerInstance.timerPool[task.time]['linear'].push(ad);
        } else if (task.hasOwnProperty('playRoll') && ad.adType === 'nonLinear') {
          playerInstance.timerPool[task.time]['nonLinear'].push(ad);
        } else if (task.hasOwnProperty('closeStaticAd')) {
          playerInstance.timerPool[task.time]['closeStaticAd'].push(ad);
        }
      });
    }

    // Handle Loading VAST on demand
    if (task.loadVast) {
      playerInstance.timerPool[task.time]['loadVast'].push(task.roll);
    }
  };

  /**
   * Adds on demand rolls (midRoll, postRoll) to schedule
   */
  playerInstance.scheduleOnDemandRolls = function () {
    var midRollListIds = playerInstance.findRoll("midRoll") || [];
    var postRollListIds = playerInstance.findRoll("postRoll") || [];
    [].concat(adsupport_toConsumableArray(midRollListIds), adsupport_toConsumableArray(postRollListIds)).map(function (rollListId) {
      return playerInstance.rollsById[rollListId];
    }).filter(function (rollAd) {
      return rollAd.vastLoaded !== true && rollAd.error !== true;
    }).forEach(function (rollAd) {
      // Request will have the vastTimeout time to load
      if (rollAd.roll === "midRoll") {
        if (typeof rollAd.timer === 'string') {
          // This can result in NaN, in that case the midRoll will simply not happen (user configuration error)
          rollAd.timer = Math.floor(playerInstance.mainVideoDuration / 100 * rollAd.timer.replace('%', ''));
          playerInstance.debugMessage("Replaced midRoll from percentage to timer value ".concat(rollAd.timer, " seconds"));
        }
        var time = rollAd.timer - playerInstance.displayOptions.vastOptions.vastTimeout / 1000;

        // Handles cases where the midRoll should be loaded now, skipping the task scheduler
        if (time <= Number(playerInstance.getCurrentTime())) {
          playerInstance.debugMessage("Loading Mid Roll VAST immediately as it needs to be played soon");
          playerInstance.processVastWithRetries(rollAd);
        } else {
          playerInstance.scheduleTask({
            loadVast: true,
            time: time,
            roll: rollAd
          });
        }
      } else {
        var backwardScheduleTime = parseInt(playerInstance.mainVideoDuration);
        var scheduleTimeAmount = playerInstance.displayOptions.vastOptions.vastTimeout / 1000;

        // Used to prevent loading more than one of the tasks bellow
        rollAd.voidPostRollTasks = false;
        for (var i = 1; i <= scheduleTimeAmount; i++) {
          // Sets tasks for the last N seconds based on vastTimeout
          playerInstance.scheduleTask({
            loadVast: true,
            time: backwardScheduleTime - i,
            roll: rollAd
          });
        }
      }
    });
  };

  // ADS
  playerInstance.switchToMainVideo = function () {
    playerInstance.debugMessage('starting main video');
    playerInstance.domRef.player.src = playerInstance.originalSrc;
    playerInstance.initialiseStreamers();
    var newCurrentTime = typeof playerInstance.domRef.player.mainVideoCurrentTime !== 'undefined' ? Math.floor(playerInstance.domRef.player.mainVideoCurrentTime) : 0;
    if (playerInstance.domRef.player.hasOwnProperty('currentTime')) {
      playerInstance.domRef.player.currentTime = newCurrentTime;
    }
    if (playerInstance.displayOptions.layoutControls.loop) {
      playerInstance.domRef.player.loop = true;
    }
    playerInstance.setCurrentTimeAndPlay(newCurrentTime, playerInstance.autoplayAfterAd);
    playerInstance.isCurrentlyPlayingAd = false;
    playerInstance.deleteVastAdElements();
    playerInstance.adFinished = true;
    playerInstance.displayOptions.vastOptions.vastAdvanced.vastVideoEndedCallback();
    playerInstance.vastOptions = null;
    playerInstance.setBuffering();
    var progressbarContainer = playerInstance.domRef.wrapper.querySelector('.fluid_controls_progress_container');
    if (progressbarContainer !== null) {
      var backgroundColor = playerInstance.displayOptions.layoutControls.primaryColor ? playerInstance.displayOptions.layoutControls.primaryColor : "white";
      var currentProgressBar = playerInstance.domRef.player.parentNode.getElementsByClassName('fluid_controls_currentprogress');
      for (var i = 0; i < currentProgressBar.length; i++) {
        currentProgressBar[i].style.backgroundColor = backgroundColor;
      }
    }
    playerInstance.domRef.player.removeEventListener('ended', playerInstance.onVastAdEnded);
    if (playerInstance.displayOptions.vastOptions.showProgressbarMarkers) {
      playerInstance.showAdMarkers();
    }
    if (playerInstance.hasTitle()) {
      var title = playerInstance.domRef.wrapper.querySelector('.fp_title');
      title.style.display = 'inline';
    }
  };

  // ADS
  playerInstance.getNextAdPod = function () {
    if (playerInstance.temporaryAdPods.length > 0) {
      return playerInstance.temporaryAdPods.shift();
    }
    return null;
  };

  // ADS
  playerInstance.checkForNextAd = function () {
    var availableNextAdID = playerInstance.getNextAdPod();
    if (availableNextAdID === null) {
      playerInstance.switchToMainVideo();
      playerInstance.vastOptions = null;
      playerInstance.adFinished = true;
    } else {
      playerInstance.domRef.player.removeEventListener('ended', playerInstance.onVastAdEnded);
      playerInstance.isCurrentlyPlayingAd = false;
      playerInstance.vastOptions = null;
      playerInstance.adFinished = true;
      playerInstance.renderLinearAd(availableNextAdID, false); // passing false so it doesn't backup the Ad playbacktime as video playback time
    }
  };

  /**
   * Adds a Skip Button
   */
  playerInstance.addSkipButton = function () {
    // TODO: ahh yes, the DIVbutton...
    var divSkipButton = document.createElement('div');
    divSkipButton.className = 'skip_button skip_button_disabled';
    if (playerInstance.vastOptions.skipoffset > 0) {
      divSkipButton.innerHTML = playerInstance.displayOptions.vastOptions.skipButtonCaption.replace('[seconds]', playerInstance.vastOptions.skipoffset);
    }
    playerInstance.domRef.wrapper.appendChild(divSkipButton);
    if (playerInstance.vastOptions.skipoffset === 0) {
      playerInstance.decreaseSkipOffset();
    }
    playerInstance.domRef.player.addEventListener('timeupdate', playerInstance.decreaseSkipOffset, false);
  };

  /**
   * Ad Countdown
   */
  playerInstance.addAdCountdown = function () {
    if (playerInstance.isCurrentlyPlayingAd && playerInstance.hlsPlayer || playerInstance.currentVideoDuration === Infinity) {
      return; // Shouldn't show countdown if ad is a video live stream
    }

    var videoWrapper = playerInstance.domRef.wrapper;
    var divAdCountdown = document.createElement('div');

    // Create element
    var adCountdown = playerInstance.pad(parseInt(playerInstance.currentVideoDuration / 60)) + ':' + playerInstance.pad(parseInt(playerInstance.currentVideoDuration % 60));
    var durationText = parseInt(adCountdown);
    divAdCountdown.className = 'ad_countdown';
    divAdCountdown.innerHTML = "<span class='ad_timer_prefix'>Ad - </span>" + durationText;
    videoWrapper.appendChild(divAdCountdown);
    playerInstance.domRef.player.addEventListener('timeupdate', playerInstance.decreaseAdCountdown, false);
    videoWrapper.addEventListener('mouseover', function () {
      divAdCountdown.style.display = 'none';
    }, false);
  };
  playerInstance.decreaseAdCountdown = function decreaseAdCountdown() {
    var sec = parseInt(playerInstance.currentVideoDuration) - parseInt(playerInstance.domRef.player.currentTime);
    var btn = playerInstance.domRef.wrapper.querySelector('.ad_countdown');
    if (btn && isNaN(sec)) {
      btn.parentNode.removeChild(btn);
      return;
    }
    if (btn) {
      btn.innerHTML = "<span class='ad_timer_prefix'>Ad - </span> " + playerInstance.pad(parseInt(sec / 60)) + ':' + playerInstance.pad(parseInt(sec % 60));
    } else {
      playerInstance.domRef.player.removeEventListener('timeupdate', playerInstance.decreaseAdCountdown);
    }
  };
  playerInstance.removeAdCountdown = function () {
    var btn = playerInstance.domRef.wrapper.querySelector('.ad_countdown');
    if (btn) {
      btn.parentElement.removeChild(btn);
    }
  };
  playerInstance.toggleAdCountdown = function (showing) {
    var btn = playerInstance.domRef.wrapper.querySelector('.ad_countdown');
    if (btn) {
      if (showing) {
        btn.style.display = 'inline-block';
      } else {
        btn.style.display = 'none';
      }
    }
  };
  playerInstance.addAdPlayingText = function (textToShow) {
    var adPlayingDiv = document.createElement('div');
    if (playerInstance.displayOptions.layoutControls.primaryColor) {
      adPlayingDiv.style.backgroundColor = playerInstance.displayOptions.layoutControls.primaryColor;
      adPlayingDiv.style.opacity = 1;
    }
    adPlayingDiv.className = 'fluid_ad_playing';
    adPlayingDiv.innerText = textToShow;
    playerInstance.domRef.wrapper.appendChild(adPlayingDiv);
  };
  playerInstance.positionTextElements = function (adListData) {
    var allowedPosition = ['top left', 'top right', 'bottom left', 'bottom right'];
    var skipButton = playerInstance.domRef.wrapper.querySelector('.skip_button');
    var adPlayingDiv = playerInstance.domRef.wrapper.querySelector('.fluid_ad_playing');
    var ctaButton = playerInstance.domRef.wrapper.querySelector('.fluid_ad_cta');
    var ctaButtonHeightWithSpacing = 0;
    var adPlayingDivHeightWithSpacing = 0;
    var pixelSpacing = 8;
    var isBottom = false;
    var skipButtonHeightWithSpacing = 0;
    var positionsCTA = [];
    var defaultPositions = {
      top: {
        left: {
          h: 34,
          v: 34
        },
        right: {
          h: 0,
          v: 34
        }
      },
      bottom: {
        left: {
          h: 34,
          v: 50
        },
        right: {
          h: 0,
          v: 50
        }
      }
    };
    if (skipButton !== null) {
      skipButtonHeightWithSpacing = skipButton.offsetHeight + pixelSpacing;
      var wrapperElement = playerInstance.domRef.wrapper;
      if (wrapperElement.classList.contains('mobile')) {
        defaultPositions.top = {
          left: {
            h: 0,
            v: 8
          },
          right: {
            h: 0,
            v: 8
          }
        };
        defaultPositions.bottom = {
          left: {
            h: 0,
            v: 50
          },
          right: {
            h: 0,
            v: 50
          }
        };
      }
    }
    var CTATextPosition;
    if (ctaButton !== null) {
      CTATextPosition = playerInstance.rollsById[adListData.rollListId].adCTATextPosition ? playerInstance.rollsById[adListData.rollListId].adCTATextPosition.toLowerCase() : playerInstance.displayOptions.vastOptions.adCTATextPosition;
      if (allowedPosition.indexOf(CTATextPosition) === -1) {
        console.log('[FP Error] Invalid position for CTAText. Reverting to "bottom right"');
        CTATextPosition = 'bottom right';
      }
      ctaButton.classList.add.apply(ctaButton.classList, CTATextPosition.split(' '));
      positionsCTA = CTATextPosition.split(' ');
      isBottom = positionsCTA[0] === 'bottom';
      ctaButton.style[positionsCTA[0]] = defaultPositions[positionsCTA[0]][positionsCTA[1]].v + 'px';
      ctaButton.style[positionsCTA[1]] = defaultPositions[positionsCTA[0]][positionsCTA[1]].h + 'px';
      if (isBottom && positionsCTA[1] === 'right') {
        ctaButton.style[positionsCTA[0]] = defaultPositions[positionsCTA[0]][positionsCTA[1]].v + skipButtonHeightWithSpacing + 'px';
      }
      ctaButtonHeightWithSpacing = ctaButton.offsetHeight + pixelSpacing + 'px';
    }
    var adPlayingDivPosition;
    var positionsAdText;
    if (adPlayingDiv !== null) {
      adPlayingDivPosition = playerInstance.rollsById[adListData.rollListId].adTextPosition ? playerInstance.rollsById[adListData.rollListId].adTextPosition.toLowerCase() : playerInstance.displayOptions.vastOptions.adTextPosition;
      if (allowedPosition.indexOf(adPlayingDivPosition) === -1) {
        console.log('[FP Error] Invalid position for adText. Reverting to "top left"');
        adPlayingDivPosition = 'top left';
      }
      positionsAdText = adPlayingDivPosition.split(' ');
      adPlayingDiv.style[positionsAdText[0]] = defaultPositions[positionsAdText[0]][positionsAdText[1]].v + 'px';
      adPlayingDiv.style[positionsAdText[1]] = defaultPositions[positionsAdText[0]][positionsAdText[1]].h + 'px';
      adPlayingDivHeightWithSpacing = adPlayingDiv.offsetHeight + pixelSpacing + 'px';
    }
    if (ctaButtonHeightWithSpacing > 0 && adPlayingDivHeightWithSpacing > 0 && CTATextPosition === adPlayingDivPosition) {
      if (isBottom) {
        if (positionsCTA[1] === 'right') {
          adPlayingDiv.style.bottom = defaultPositions[positionsAdText[0]][positionsAdText[1]].v + skipButtonHeightWithSpacing + ctaButtonHeightWithSpacing + 'px';
        } else {
          adPlayingDiv.style.bottom = defaultPositions[positionsAdText[0]][positionsAdText[1]].v + ctaButtonHeightWithSpacing + 'px';
        }
      } else {
        ctaButton.style.top = defaultPositions[positionsCTA[0]][positionsCTA[1]].v + adPlayingDivHeightWithSpacing + 'px';
      }
    }
  };
  playerInstance.removeAdPlayingText = function () {
    var div = playerInstance.domRef.wrapper.querySelector('.fluid_ad_playing');
    if (!div) {
      return;
    }
    div.parentElement.removeChild(div);
  };

  /**
   * Adds CTA button from VAST, with fallback to IconClickTrough
   *
   * @param {string} landingPage
   */
  playerInstance.addCTAButton = function (landingPage) {
    if (playerInstance.vastOptions.titleCTA) {
      var _playerInstance$vastO = playerInstance.vastOptions.titleCTA,
        text = _playerInstance$vastO.text,
        link = _playerInstance$vastO.link,
        tracking = _playerInstance$vastO.tracking;
      return playerInstance.createAndAppendCTAButton(text, link, tracking);
    }
    if (landingPage && typeof playerInstance.displayOptions.vastOptions.adCTAText === 'string') {
      return playerInstance.createAndAppendCTAButton(playerInstance.displayOptions.vastOptions.adCTAText, landingPage, playerInstance.vastOptions.clickthroughUrl);
    }
  };

  /**
   * Creates and append CTA button given the input parameters
   *
   * @param {string} adCTAText
   *
   * @param {string} displayUrl
   *
   * @param {string} trackingUrl
   */
  playerInstance.createAndAppendCTAButton = function (adCTAText, displayUrl, trackingUrl) {
    var ctaButton = document.createElement('div');
    ctaButton.className = 'fluid_ad_cta';
    var link = document.createElement('span');
    var innerHTML = adCTAText;
    if (displayUrl) {
      innerHTML += "<br/><span class=\"add_icon_clickthrough\">" + displayUrl + "</span>";
    }
    link.innerHTML = innerHTML;
    ctaButton.addEventListener('click', function () {
      if (!playerInstance.domRef.player.paused) {
        playerInstance.domRef.player.pause();
      }
      var win = window.open(trackingUrl, '_blank');
      win.focus();
      return true;
    }, false);
    ctaButton.appendChild(link);
    playerInstance.domRef.wrapper.appendChild(ctaButton);
  };
  playerInstance.removeCTAButton = function () {
    var btn = playerInstance.domRef.wrapper.querySelector('.fluid_ad_cta');
    if (!btn) {
      return;
    }
    btn.parentElement.removeChild(btn);
  };
  playerInstance.decreaseSkipOffset = function () {
    var sec = playerInstance.vastOptions.skipoffset - Math.floor(playerInstance.domRef.player.currentTime);
    var btn = playerInstance.domRef.wrapper.querySelector('.skip_button');
    if (!btn) {
      playerInstance.domRef.player.removeEventListener('timeupdate', playerInstance.decreaseSkipOffset);
      return;
    }
    if (sec >= 1) {
      //set the button label with the remaining seconds
      btn.innerHTML = playerInstance.displayOptions.vastOptions.skipButtonCaption.replace('[seconds]', sec);
      return;
    }

    // TODO: refactored, but this is still terrible - remove all this and just make the button clickable...
    var skipLink = document.createElement('a');
    skipLink.href = '#';
    skipLink.className = 'js-skipHref';
    skipLink.innerHTML = playerInstance.displayOptions.vastOptions.skipButtonClickCaption;
    skipLink.onclick = function (e) {
      e.preventDefault();
      e.stopPropagation();
      playerInstance.pressSkipButton();
    };
    btn.innerHTML = '';
    btn.appendChild(skipLink);

    //removes the CSS class for a disabled button
    btn.className = btn.className.replace(/\bskip_button_disabled\b/, '');
    playerInstance.domRef.player.removeEventListener('timeupdate', playerInstance.decreaseSkipOffset);
  };
  playerInstance.pressSkipButton = function () {
    playerInstance.removeSkipButton();
    playerInstance.removeAdPlayingText();
    playerInstance.removeCTAButton();
    if (playerInstance.vastOptions.vpaid) {
      // skip the linear vpaid ad
      playerInstance.skipVpaidAd();
      return;
    }

    // skip the regular linear vast
    playerInstance.displayOptions.vastOptions.vastAdvanced.vastVideoSkippedCallback();
    var event = document.createEvent('Event');
    event.initEvent('ended', false, true);
    playerInstance.domRef.player.dispatchEvent(event);
  };
  playerInstance.removeSkipButton = function () {
    var btn = playerInstance.domRef.wrapper.querySelector('.skip_button');
    if (btn) {
      btn.parentElement.removeChild(btn);
    }
  };

  /**
   * Makes the player open the ad URL on clicking
   */
  playerInstance.addClickthroughLayer = function () {
    var divWrapper = playerInstance.domRef.wrapper;
    var divClickThrough = document.createElement('div');
    divClickThrough.className = 'vast_clickthrough_layer';
    divClickThrough.setAttribute('style', 'position: absolute; cursor: pointer; top: 0; left: 0; width: ' + playerInstance.domRef.player.offsetWidth + 'px; height: ' + playerInstance.domRef.player.offsetHeight + 'px;');
    divWrapper.appendChild(divClickThrough);

    //Bind the Onclick event
    var openClickthrough = function openClickthrough() {
      window.open(playerInstance.vastOptions.clickthroughUrl);

      //Tracking the Clickthorugh events
      if (typeof playerInstance.vastOptions.clicktracking !== 'undefined') {
        playerInstance.callUris(playerInstance.vastOptions.clicktracking);
      }
    };
    var clickthroughLayer = playerInstance.domRef.wrapper.querySelector('.vast_clickthrough_layer');
    var isIos9orLower = playerInstance.mobileInfo.device === 'iPhone' && playerInstance.mobileInfo.userOsMajor !== false && playerInstance.mobileInfo.userOsMajor <= 9;
    clickthroughLayer.onclick = function () {
      if (playerInstance.domRef.player.paused) {
        //On Mobile Safari on iPhones with iOS 9 or lower open the clickthrough only once
        if (isIos9orLower && !playerInstance.suppressClickthrough) {
          openClickthrough();
          playerInstance.suppressClickthrough = true;
        } else {
          playerInstance.domRef.player.play();
        }
      } else {
        openClickthrough();
        playerInstance.domRef.player.pause();
      }
    };
  };

  /**
   * Remove the Clickthrough layer
   */
  playerInstance.removeClickthrough = function () {
    var clickthroughLayer = playerInstance.domRef.wrapper.querySelector('.vast_clickthrough_layer');
    if (clickthroughLayer) {
      clickthroughLayer.parentNode.removeChild(clickthroughLayer);
    }
  };
}
;// CONCATENATED MODULE: ./src/modules/streaming.js
function streaming_toConsumableArray(arr) { return streaming_arrayWithoutHoles(arr) || streaming_iterableToArray(arr) || streaming_unsupportedIterableToArray(arr) || streaming_nonIterableSpread(); }
function streaming_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function streaming_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return streaming_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return streaming_arrayLikeToArray(o, minLen); }
function streaming_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function streaming_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return streaming_arrayLikeToArray(arr); }
function streaming_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// Prevent DASH.js from automatically attaching to video sources by default.
// Whoever thought this is a good idea?!
if (typeof window !== 'undefined' && !window.dashjs) {
  window.dashjs = {
    skipAutoCreate: true,
    isDefaultSubject: true
  };
}
/* harmony default export */ function streaming(playerInstance, options) {
  playerInstance.initialiseStreamers = function () {
    playerInstance.detachStreamers();
    switch (playerInstance.displayOptions.layoutControls.mediaType) {
      case 'application/dash+xml':
        // MPEG-DASH
        if (!playerInstance.dashScriptLoaded && (!window.dashjs || window.dashjs.isDefaultSubject)) {
          playerInstance.dashScriptLoaded = true;
          __webpack_require__.e(/* import() | dashjs */ 112).then(__webpack_require__.t.bind(__webpack_require__, 452, 23)).then(function (it) {
            window.dashjs = it.default;
            playerInstance.initialiseDash();
          });
        } else {
          playerInstance.initialiseDash();
        }
        break;
      case 'application/x-mpegurl':
        // HLS
        var displayOptions = playerInstance.displayOptions,
          domRef = playerInstance.domRef;
        var player = domRef.player;
        var hls = displayOptions.hls;

        // Doesn't load hls.js if player can play it natively
        if (player.canPlayType('application/x-mpegurl') && !hls.overrideNative) {
          playerInstance.debugMessage('Native HLS support found, skipping hls.js');
          break;
        }
        if (!playerInstance.hlsScriptLoaded && !window.Hls) {
          playerInstance.hlsScriptLoaded = true;
          __webpack_require__.e(/* import() | hlsjs */ 602).then(__webpack_require__.bind(__webpack_require__, 41)).then(function (it) {
            window.Hls = it.default;
            playerInstance.initialiseHls();
          });
        } else {
          playerInstance.initialiseHls();
        }
        break;
    }
  };
  playerInstance.initialiseDash = function () {
    if (typeof (window.MediaSource || window.WebKitMediaSource) === 'function') {
      // If false we want to override the autoPlay, as it comes from postRoll
      var playVideo = !playerInstance.autoplayAfterAd ? playerInstance.autoplayAfterAd : playerInstance.displayOptions.layoutControls.autoPlay;
      var defaultOptions = {
        'debug': {
          'logLevel':  false ? 0 : dashjs.Debug.LOG_LEVEL_FATAL
        }
      };
      var dashPlayer = dashjs.MediaPlayer().create();
      var _options = playerInstance.displayOptions.modules.configureDash(defaultOptions);
      dashPlayer.updateSettings(_options);
      playerInstance.displayOptions.modules.onBeforeInitDash(dashPlayer);
      dashPlayer.initialize(playerInstance.domRef.player, playerInstance.originalSrc, playVideo);
      dashPlayer.on('streamInitializing', function () {
        playerInstance.toggleLoader(true);
      });
      dashPlayer.on('canPlay', function () {
        playerInstance.toggleLoader(false);
      });
      dashPlayer.on('playbackPlaying', function () {
        playerInstance.toggleLoader(false);
      });
      playerInstance.displayOptions.modules.onAfterInitDash(dashPlayer);
      playerInstance.dashPlayer = dashPlayer;
    } else {
      playerInstance.nextSource();
      console.log('[FP_WARNING] Media type not supported by this browser using DASH.js. (application/dash+xml)');
    }
  };
  playerInstance.initialiseHls = function () {
    if (typeof Hls !== 'undefined' && Hls.isSupported()) {
      playerInstance.debugMessage('Initializing hls.js');
      var defaultOptions = {
        debug:  true && false === true,
        p2pConfig: {
          logLevel: false
        },
        enableWebVTT: false,
        enableCEA708Captions: false
      };
      var _options2 = playerInstance.displayOptions.modules.configureHls(defaultOptions);
      var hls = new Hls(_options2);
      playerInstance.displayOptions.modules.onBeforeInitHls(hls);
      hls.attachMedia(playerInstance.domRef.player);
      hls.loadSource(playerInstance.originalSrc);
      playerInstance.displayOptions.modules.onAfterInitHls(hls);
      playerInstance.hlsPlayer = hls;
      if (!playerInstance.firstPlayLaunched && playerInstance.displayOptions.layoutControls.autoPlay) {
        playerInstance.domRef.player.play();
      }
      playerInstance.createHLSVideoSourceSwitch();
    } else {
      playerInstance.nextSource();
      console.log('[FP_WARNING] Media type not supported by this browser using HLS.js. (application/x-mpegURL)');
    }
  };
  playerInstance.createHLSVideoSourceSwitch = function () {
    playerInstance.hlsPlayer.on(Hls.Events.MANIFEST_PARSED, function () {
      try {
        var levels = createHLSLevels();
        var sortedLevels = sortLevels(levels);
        playerInstance.videoSources = sortedLevels;

        // <=2 because of the added auto function
        if (sortedLevels.length <= 2) return;
        var sourceChangeButton = playerInstance.domRef.wrapper.querySelector('.fluid_control_video_source');
        toggleSourceChangeButtonVisibility(sortedLevels, sourceChangeButton);
        var sourceChangeList = createSourceChangeList(sortedLevels);
        attachSourceChangeList(sourceChangeButton, sourceChangeList);

        // Set initial level based on persisted quality or default to auto
        setInitialLevel(sortedLevels);
      } catch (err) {
        console.error(err);
      }
    });
  };
  function createHLSLevels() {
    var HLSLevels = playerInstance.hlsPlayer.levels.map(function (level, index) {
      return {
        id: index,
        title: String(level.width),
        isHD: level.videoRange === 'HDR',
        bitrate: level.bitrate
      };
    });
    var autoLevel = {
      id: -1,
      title: 'auto',
      isHD: false,
      bitrate: 0
    };
    return [].concat(streaming_toConsumableArray(HLSLevels), [autoLevel]);
  }
  function toggleSourceChangeButtonVisibility(levels, sourceChangeButton) {
    if (levels.length > 1) {
      sourceChangeButton.style.display = 'inline-block';
    } else {
      sourceChangeButton.style.display = 'none';
    }
  }
  function createSourceChangeList(levels) {
    var sourceChangeList = document.createElement('div');
    sourceChangeList.className = 'fluid_video_sources_list';
    sourceChangeList.style.display = 'none';
    levels.forEach(function (level) {
      var sourceChangeDiv = createSourceChangeItem(level);
      sourceChangeList.appendChild(sourceChangeDiv);
    });
    return sourceChangeList;
  }
  function createSourceChangeItem(level) {
    var sourceSelectedClass = getSourceSelectedClass(level);
    var hdIndicator = level.isHD ? "<sup style=\"color:".concat(playerInstance.displayOptions.layoutControls.primaryColor, "\" class=\"fp_hd_source\"></sup>") : '';
    var sourceChangeDiv = document.createElement('div');
    sourceChangeDiv.className = "fluid_video_source_list_item js-source_".concat(level.title);
    sourceChangeDiv.innerHTML = "<span class=\"source_button_icon ".concat(sourceSelectedClass, "\"></span>").concat(level.title).concat(hdIndicator);
    sourceChangeDiv.addEventListener('click', function (event) {
      return onSourceChangeClick(event, level);
    });
    return sourceChangeDiv;
  }
  function getSourceSelectedClass(level) {
    var matchingLevels = playerInstance.videoSources.filter(function (source) {
      return source.title === playerInstance.fluidStorage.fluidQuality;
    });

    // If there are multiple matching levels, use the first one
    if (matchingLevels.length > 1) {
      if (matchingLevels[0].id === level.id) {
        return "source_selected";
      }
    } else if (matchingLevels.length === 1) {
      return matchingLevels[0].id === level.id ? "source_selected" : "";
    }

    // Fallback to auto selection if no persistent level exists
    if (!matchingLevels.length && level.title === 'auto') {
      return "source_selected";
    }
    return "";
  }
  function onSourceChangeClick(event, selectedLevel) {
    event.stopPropagation();
    setPlayerDimensions();
    var videoChangedTo = event.currentTarget;
    clearSourceSelectedIcons();
    videoChangedTo.firstChild.classList.add('source_selected');
    playerInstance.videoSources.forEach(function (source) {
      if (source.title === videoChangedTo.innerText.replace(/(\r\n\t|\n|\r\t)/gm, '')) {
        playerInstance.hlsPlayer.currentLevel = selectedLevel.id;
        playerInstance.fluidStorage.fluidQuality = selectedLevel.title;
      }
    });
    playerInstance.openCloseVideoSourceSwitch();
  }

  // While changing source the player size can flash, we want to set the pixel dimensions then back to 100% afterwards
  function setPlayerDimensions() {
    playerInstance.domRef.player.style.width = "".concat(playerInstance.domRef.player.clientWidth, "px");
    playerInstance.domRef.player.style.height = "".concat(playerInstance.domRef.player.clientHeight, "px");
  }
  function clearSourceSelectedIcons() {
    var sourceIcons = playerInstance.domRef.wrapper.getElementsByClassName('source_button_icon');
    Array.from(sourceIcons).forEach(function (icon) {
      return icon.classList.remove('source_selected');
    });
  }
  function attachSourceChangeList(sourceChangeButton, sourceChangeList) {
    sourceChangeButton.appendChild(sourceChangeList);
    sourceChangeButton.removeEventListener('click', playerInstance.openCloseVideoSourceSwitch);
    sourceChangeButton.addEventListener('click', playerInstance.openCloseVideoSourceSwitch);
  }
  function setInitialLevel(levels) {
    // Check if a persistency level exists and set the current level accordingly
    var persistedLevel = levels.find(function (level) {
      return level.title === playerInstance.fluidStorage.fluidQuality;
    });
    if (persistedLevel) {
      playerInstance.hlsPlayer.currentLevel = persistedLevel.id;
    } else {
      // Default to 'auto' if no persisted level is found
      var autoLevel = levels.find(function (level) {
        return level.title === 'auto';
      });
      playerInstance.hlsPlayer.currentLevel = autoLevel.id;
    }
  }
  function sortLevels(levels) {
    return streaming_toConsumableArray(levels).sort(function (a, b) {
      // First sort by width in descending order
      if (b.width !== a.width) {
        return b.width - a.width;
      }
      // If width is the same, sort by bitrate in descending order
      return b.bitrate - a.bitrate;
    });
  }
  playerInstance.detachStreamers = function () {
    if (playerInstance.dashPlayer) {
      playerInstance.dashPlayer.reset();
      playerInstance.dashPlayer = false;
    } else if (playerInstance.hlsPlayer) {
      playerInstance.hlsPlayer.detachMedia();
      playerInstance.hlsPlayer = false;
    }
  };
}
;// CONCATENATED MODULE: ./src/modules/utils.js
function utils_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = utils_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function utils_slicedToArray(arr, i) { return utils_arrayWithHoles(arr) || utils_iterableToArrayLimit(arr, i) || utils_unsupportedIterableToArray(arr, i) || utils_nonIterableRest(); }
function utils_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function utils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return utils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return utils_arrayLikeToArray(o, minLen); }
function utils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function utils_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function utils_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
/* harmony default export */ function utils(playerInstance, options) {
  playerInstance.isTouchDevice = function () {
    return !!('ontouchstart' in window // works on most browsers
    || navigator.maxTouchPoints); // works on IE10/11 and Surface
  };

  /**
   * Distinguishes iOS from Android devices and the OS version.
   *
   * This should be avoided in favor of capability detection.
   *
   * @deprecated deprecated as of v3.0
   * @returns object
   */
  playerInstance.getMobileOs = function () {
    var ua = navigator.userAgent || '';
    var result = {
      device: false,
      userOs: false,
      userOsVer: false,
      userOsMajor: false
    };
    var versionIndex;
    // determine OS
    if (ua.match(/Android/i)) {
      result.userOs = 'Android';
      versionIndex = ua.indexOf('Android ');
    } else if (ua.match(/iPhone/i)) {
      result.device = 'iPhone';
      result.userOs = 'iOS';
      versionIndex = ua.indexOf('OS ');
    } else if (ua.match(/iPad/i)) {
      result.device = 'iPad';
      result.userOs = 'iOS';
      versionIndex = ua.indexOf('OS ');
    } else {
      result.userOs = false;
    }

    // determine version
    if ('iOS' === result.userOs && versionIndex > -1) {
      var userOsTemp = ua.substr(versionIndex + 3);
      var indexOfEndOfVersion = userOsTemp.indexOf(' ');
      if (indexOfEndOfVersion !== -1) {
        result.userOsVer = userOsTemp.substring(0, userOsTemp.indexOf(' ')).replace(/_/g, '.');
        result.userOsMajor = parseInt(result.userOsVer);
      }
    } else if ('Android' === result.userOs && versionIndex > -1) {
      result.userOsVer = ua.substr(versionIndex + 8, 3);
    } else {
      result.userOsVer = false;
    }
    return result;
  };

  /**
   * Browser detection.
   * This should be avoided in favor of capability detection.
   *
   * @deprecated deprecated as of v3.0
   *
   * @returns object
   */
  playerInstance.getBrowserVersion = function () {
    var ua = navigator.userAgent || '';
    var result = {
      browserName: false,
      fullVersion: false,
      majorVersion: false,
      userOsMajor: false
    };
    var idx, uaindex;
    try {
      result.browserName = navigator.appName;
      if ((idx = ua.indexOf('OPR/')) !== -1) {
        result.browserName = 'Opera';
        result.fullVersion = ua.substring(idx + 4);
      } else if ((idx = ua.indexOf('Opera')) !== -1) {
        result.browserName = 'Opera';
        result.fullVersion = ua.substring(idx + 6);
        if ((idx = ua.indexOf('Version')) !== -1) result.fullVersion = ua.substring(idx + 8);
      } else if ((idx = ua.indexOf('MSIE')) !== -1) {
        result.browserName = 'Microsoft Internet Explorer';
        result.fullVersion = ua.substring(idx + 5);
      } else if ((idx = ua.indexOf('Chrome')) !== -1) {
        result.browserName = 'Google Chrome';
        result.fullVersion = ua.substring(idx + 7);
      } else if ((idx = ua.indexOf('Safari')) !== -1) {
        result.browserName = 'Safari';
        result.fullVersion = ua.substring(idx + 7);
        if ((idx = ua.indexOf('Version')) !== -1) result.fullVersion = ua.substring(idx + 8);
      } else if ((idx = ua.indexOf('Firefox')) !== -1) {
        result.browserName = 'Mozilla Firefox';
        result.fullVersion = ua.substring(idx + 8);
      }

      // Others "name/version" is at the end of userAgent
      else if ((uaindex = ua.lastIndexOf(' ') + 1) < (idx = ua.lastIndexOf('/'))) {
        result.browserName = ua.substring(uaindex, idx);
        result.fullVersion = ua.substring(idx + 1);
        if (result.browserName.toLowerCase() === result.browserName.toUpperCase()) {
          result.browserName = navigator.appName;
        }
      }

      // trim the fullVersion string at semicolon/space if present
      if ((uaindex = result.fullVersion.indexOf(';')) !== -1) {
        result.fullVersion = result.fullVersion.substring(0, uaindex);
      }
      if ((uaindex = result.fullVersion.indexOf(' ')) !== -1) {
        result.fullVersion = result.fullVersion.substring(0, uaindex);
      }
      result.majorVersion = parseInt('' + result.fullVersion, 10);
      if (isNaN(result.majorVersion)) {
        result.fullVersion = '' + parseFloat(navigator.appVersion);
        result.majorVersion = parseInt(navigator.appVersion, 10);
      }
    } catch (e) {
      //Return default obj.
    }
    return result;
  };
  playerInstance.compareVersion = function (v1, v2) {
    if (typeof v1 !== 'string') return false;
    if (typeof v2 !== 'string') return false;
    v1 = v1.split('.');
    v2 = v2.split('.');
    var k = Math.min(v1.length, v2.length);
    for (var i = 0; i < k; ++i) {
      v1[i] = parseInt(v1[i], 10);
      v2[i] = parseInt(v2[i], 10);
      if (v1[i] > v2[i]) return 1;
      if (v1[i] < v2[i]) return -1;
    }
    return v1.length === v2.length ? 0 : v1.length < v2.length ? -1 : 1;
  };
  playerInstance.convertTimeStringToSeconds = function (str) {
    if (!(str && str.match(/^(\d){2}(:[0-5][0-9]){2}(.(\d){1,3})?$/))) {
      return false;
    }
    var timeParts = str.split(':');
    return parseInt(timeParts[0], 10) * 3600 + parseInt(timeParts[1], 10) * 60 + parseInt(timeParts[2], 10);
  };

  // Format time to hh:mm:ss
  playerInstance.formatTime = function (duration) {
    var formatDateObj = new Date(duration * 1000);
    var formatHours = playerInstance.pad(formatDateObj.getUTCHours());
    var formatMinutes = playerInstance.pad(formatDateObj.getUTCMinutes());
    var formatSeconds = playerInstance.pad(formatDateObj.getSeconds());
    return formatHours >= 1 ? formatHours + ':' + formatMinutes + ':' + formatSeconds : formatMinutes + ':' + formatSeconds;
  };
  playerInstance.pad = function (value) {
    if (value < 10) {
      return '0' + value;
    }
    return value;
  };

  /**
   * Checks if element is fully visible in the viewport
   *
   * @param {Element} element
   * @returns {boolean|null}
   */
  playerInstance.isElementVisible = function (element) {
    if (!element) {
      return null;
    }
    var rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
  };
  playerInstance.observe = function () {
    var observer = new IntersectionObserver(function (entries) {
      entries.forEach(function (entry) {
        if (entry.intersectionRatio >= 0.5) {
          playerInstance.domRef.player.inView = true;
        }
        if (entry.intersectionRatio == 0 && entry.target.glast) {
          playerInstance.domRef.player.inView = false;
        }
      });
    }, {
      threshold: [0.0, 0.5]
    });
    observer.observe(playerInstance.domRef.wrapper);
  };

  /**
   * Throttles callback by time
   *
   * @param callback
   * @param time
   * @returns {function(): void}
   */
  playerInstance.throttle = function throttle(callback, time) {
    var throttleControl = false;
    return function () {
      if (!throttleControl) {
        callback.apply(this, arguments);
        throttleControl = true;
        setTimeout(function () {
          throttleControl = false;
        }, time);
      }
    };
  };
  playerInstance.getImageTwoMostProminentColours = function (imageUrl) {
    return new Promise(function (resolve, reject) {
      var img = new Image();
      img.crossOrigin = 'Anonymous';
      img.src = imageUrl;
      img.onload = function () {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0, img.width, img.height);
        var imageData = ctx.getImageData(0, 0, img.width, img.height).data;
        var colorCount = {};
        for (var i = 0; i < imageData.length; i += 4) {
          var r = imageData[i];
          var g = imageData[i + 1];
          var b = imageData[i + 2];
          var color = "rgb(".concat(r, ",").concat(g, ",").concat(b, ")");
          if (colorCount[color]) {
            colorCount[color]++;
          } else {
            colorCount[color] = 1;
          }
        }
        var rgbToHsl = function rgbToHsl(r, g, b) {
          r /= 255, g /= 255, b /= 255;
          var max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          var h,
            s,
            l = (max + min) / 2;
          if (max === min) {
            h = s = 0;
          } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return [h, s, l];
        };
        var sortedColors = Object.keys(colorCount).map(function (color) {
          var _color$match$map = color.match(/\d+/g).map(Number),
            _color$match$map2 = utils_slicedToArray(_color$match$map, 3),
            r = _color$match$map2[0],
            g = _color$match$map2[1],
            b = _color$match$map2[2];
          var _rgbToHsl = rgbToHsl(r, g, b),
            _rgbToHsl2 = utils_slicedToArray(_rgbToHsl, 3),
            h = _rgbToHsl2[0],
            s = _rgbToHsl2[1],
            l = _rgbToHsl2[2];
          return {
            color: color,
            h: h,
            s: s,
            l: l,
            score: s + (1 - Math.abs(2 * l - 1))
          };
        }).sort(function (a, b) {
          return b.score - a.score;
        });
        var isCloseToBlack = function isCloseToBlack(color) {
          var rgb = color.match(/\d+/g).map(Number);
          var blackThreshold = 40;
          return rgb[0] < blackThreshold && rgb[1] < blackThreshold && rgb[2] < blackThreshold;
        };
        var minHueDifference = 0.1;
        var minSaturationDifference = 0.1;
        var minLightnessDifference = 0.1;
        var mostVibrantColors = [];
        var _iterator = utils_createForOfIteratorHelper(sortedColors),
          _step;
        try {
          var _loop = function _loop() {
            var colorObj = _step.value;
            if (mostVibrantColors.length === 2) return "break";
            if (!isCloseToBlack(colorObj.color)) {
              var enoughDifference = mostVibrantColors.every(function (existingColor) {
                var hueDifference = Math.abs(colorObj.h - existingColor.h);
                var saturationDifference = Math.abs(colorObj.s - existingColor.s);
                var lightnessDifference = Math.abs(colorObj.l - existingColor.l);
                return hueDifference >= minHueDifference && saturationDifference >= minSaturationDifference && lightnessDifference >= minLightnessDifference;
              });
              if (enoughDifference) {
                mostVibrantColors.push(colorObj);
              }
            }
          };
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _ret = _loop();
            if (_ret === "break") break;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (mostVibrantColors.length < 2) {
          mostVibrantColors = sortedColors.slice(0, 2);
        }
        resolve(mostVibrantColors.map(function (colorObj) {
          return colorObj.color;
        }));
      };
      img.onerror = function () {
        reject(new Error('Failed to load image'));
      };
    });
  };
}
;// CONCATENATED MODULE: ./src/modules/suggestedVideos.js
/* harmony default export */ function suggestedVideos(playerInstance, options) {
  playerInstance.suggestedVideosGrid = null;
  playerInstance.generateSuggestedVideoList = function () {
    var configUrl = playerInstance.displayOptions.suggestedVideos.configUrl;
    if (!configUrl) {
      return;
    }
    playerInstance.sendRequestAsync(configUrl, false, 5000).then(function (_ref) {
      var response = _ref.response;
      var config = JSON.parse(response);
      var suggestedVideosGrid = playerInstance.generateSuggestedVideoGrid(config);
      playerInstance.suggestedVideosGrid = suggestedVideosGrid;
    }).catch(function (err) {
      console.error('[FP_ERROR] given suggested videos config url is invalid or not found.', err);
    });
  };
  playerInstance.generateSuggestedVideoGrid = function (config) {
    var suggestedVideosGrid = document.createElement('div');
    suggestedVideosGrid.className = 'suggested_tile_grid';
    for (var i = 0; i < 12; i++) {
      var videoTile = playerInstance.createVideoTile(config[i]);
      suggestedVideosGrid.appendChild(videoTile);
    }
    return suggestedVideosGrid;
  };
  playerInstance.displaySuggestedVideos = function () {
    var PlayerDOM = playerInstance.domRef.wrapper;
    PlayerDOM.appendChild(playerInstance.suggestedVideosGrid);
  };
  playerInstance.clickSuggestedVideo = function (sources, subtitles, configUrl) {
    playerInstance.toggleLoader(true);
    playerInstance.hideSuggestedVideos();
    playerInstance.resetPlayer(sources, subtitles, configUrl);
    playerInstance.generateSuggestedVideoList();
  };
  playerInstance.resetPlayer = function (sources, subtitles, configUrl) {
    var videoDOM = playerInstance.domRef.wrapper.querySelector("#".concat(playerInstance.videoPlayerId));
    videoDOM.innerHTML = '';
    var sourcesHTML = '';
    if (sources) {
      sources.forEach(function (source) {
        sourcesHTML += "<source src='".concat(source.url, "' ").concat(source.hd ? 'data-fluid-hd' : '', " title=\"").concat(source.resolution, "\" type='").concat(source.mimeType, "'/>");
      });
    }
    if (subtitles) {
      subtitles.forEach(function (subtitle) {
        sourcesHTML += "<track label=\"".concat(subtitle.label, "\" kind=\"metadata\" srclang=\"").concat(subtitle.lang, "\" src=\"").concat(subtitle.url, "\" ").concat(subtitle.default ? 'default' : '', ">");
      });
    }
    videoDOM.innerHTML = sourcesHTML;
    playerInstance.removeVideoSourcesListFromDOM();
    var videoSourceList = playerInstance.domRef.wrapper.getElementsByClassName('fluid_control_video_source')[0];
    videoSourceList.innerHTML = '';
    playerInstance.domRef.player.src = '';
    playerInstance.domRef.player.removeAttribute('src');
    playerInstance.setVideoSource(sources[0].url);
    playerInstance.createVideoSourceSwitch(false);
    playerInstance.resetSubtitles();
    playerInstance.setPersistentSettings(true);
    playerInstance.loadInNewVideo();
    playerInstance.resetAds();

    // set new API config url
    if (configUrl) {
      playerInstance.displayOptions.suggestedVideos.configUrl = configUrl;
      playerInstance.generateSuggestedVideoList();
    }
  };
  playerInstance.createVideoTile = function (config) {
    var videoTile = document.createElement('div');
    videoTile.addEventListener('click', function () {
      playerInstance.clickSuggestedVideo(config.sources, config.subtitles, config.configUrl);
    }, false);
    videoTile.className = 'suggested_tile';
    videoTile.id = 'suggested_tile_' + config.id;
    playerInstance.getImageTwoMostProminentColours(config.thumbnailUrl).then(function (mostProminentColors) {
      if (mostProminentColors && mostProminentColors.length) {
        videoTile.style = "background: ".concat(mostProminentColors[0], ";");
      }
    });
    var videoImage = document.createElement('img');
    videoImage.src = config.thumbnailUrl;
    videoImage.className = 'suggested_tile_image';
    var videoTileOverlay = document.createElement('div');
    videoTileOverlay.className = 'suggested_tile_overlay';
    var title = document.createElement('p');
    title.className = 'suggested_tile_title';
    title.innerText = config.title;
    videoTileOverlay.appendChild(title);
    videoTile.appendChild(videoImage);
    videoTile.appendChild(videoTileOverlay);
    return videoTile;
  };
  playerInstance.resetSubtitles = function () {
    playerInstance.removeSubtitlesListFromDOM();
    var videoSubtitlesList = playerInstance.domRef.wrapper.getElementsByClassName('fluid_control_subtitles')[0];
    videoSubtitlesList.innerHTML = '';
    playerInstance.domRef.player.load();
    playerInstance.createSubtitles(false);
  };
  playerInstance.loadInNewVideo = function () {
    playerInstance.displayOptions.layoutControls.mediaType = playerInstance.getCurrentSrcType();
    playerInstance.initialiseStreamers();
    playerInstance.domRef.player.currentTime = 0;
    playerInstance.domRef.player.mainVideoCurrentTime = 0;
    playerInstance.setBuffering();
  };
  playerInstance.resetAds = function () {
    // Clear midroll and postroll ads
    playerInstance.timerPool = {};
    playerInstance.rollsById = {};
    playerInstance.adPool = {};
    playerInstance.adGroupedByRolls = {};
    playerInstance.onPauseRollAdPods = [];
    playerInstance.currentOnPauseRollAd = '';

    // Reset variables and flags, needed for assigning the different rolls correctly
    playerInstance.isTimer = false;
    playerInstance.timer = null;
    playerInstance.firstPlayLaunched = false;

    // Clear preroll ads
    playerInstance.preRollAdsResolved = false;
    playerInstance.preRollAdPods = [];
    playerInstance.preRollAdPodsLength = 0;
    playerInstance.preRollVastResolved = 0;
    playerInstance.autoplayAfterAd = true;

    // Wait until new selected video is buffered so we can get the video length
    // This is needed for mid and post rolls to assign the correct time key to their respective triggers
    var checkMainVideoDuration = function checkMainVideoDuration() {
      if (!isNaN(playerInstance.domRef.player.duration) && playerInstance.domRef.player.duration > 0) {
        playerInstance.toggleLoader(true);
        playerInstance.mainVideoDuration = playerInstance.domRef.player.duration;
        clearInterval(intervalId);

        // Set up ads
        playerInstance.setVastList();
        playerInstance.checkForNextAd();
        playerInstance.playPauseToggle();
      }
    };
    var intervalId = setInterval(checkMainVideoDuration, 100);
  };
  playerInstance.removeVideoSourcesListFromDOM = function () {
    var sourcesDOM = playerInstance.domRef.wrapper.getElementsByClassName('fluid_video_source_list_item');
    for (var i = 0; i < sourcesDOM.length; i++) {
      sourcesDOM[i].remove();
    }
  };
  playerInstance.removeSubtitlesListFromDOM = function () {
    var tracksDOM = playerInstance.domRef.wrapper.getElementsByClassName('fluid_subtitle_list_item');
    for (var i = 0; i < tracksDOM.length; i++) {
      tracksDOM[i].remove();
    }
  };
  playerInstance.hideSuggestedVideos = function () {
    var suggestedVideosDOM = playerInstance.domRef.wrapper.getElementsByClassName('suggested_tile_grid')[0];
    if (suggestedVideosDOM) {
      suggestedVideosDOM.remove();
    }
  };
  playerInstance.isShowingSuggestedVideos = function () {
    return !!playerInstance.domRef.wrapper.getElementsByClassName('suggested_tile_grid')[0];
  };
}
;// CONCATENATED MODULE: ./src/modules/miniplayer.js
/* harmony default export */ function miniplayer(playerInstance) {
  // Module constants
  var MINIMUM_WIDTH = 400; // Pixels
  var MINIMUM_HEIGHT = 225; // Pixels
  var MINIMUM_WIDTH_MOBILE = 40; // Percentage
  var TOGGLE_BY_VISIBILITY_DETECTION_RATE = 1000 / 60; // ms

  var DISABLE_MINI_PLAYER_MOBILE_ANIMATION_CLAMP = 50;
  var DISABLE_MINI_PLAYER_MOBILE_ANIMATION_DEADZONE = 5;
  var DESKTOP_ONLY_MEDIA_QUERY = '(max-width: 768px)';
  var FLUID_PLAYER_WRAPPER_CLASS = 'fluid_mini_player_mode';
  var CLOSE_BUTTON_WRAPPER_CLASS = 'mini-player-close-button-wrapper';
  var CLOSE_BUTTON_CLASS = 'mini-player-close-button';
  var PLACEHOLDER_CLASS = 'fluidplayer-miniplayer-player-placeholder';
  var DISABLE_MINI_PLAYER_MOBILE_CLASS = 'disable-mini-player-mobile';
  var LINEAR_CLICKTHROUGH_SELECTOR = '.vast_clickthrough_layer';
  var NON_LINEAR_SELECTOR = '.fluid_nonLinear_ad img, .fluid_vpaid_nonlinear_slot_iframe';
  var VPAID_FRAME_SELECTOR = '.fluid_vpaidNonLinear_frame';
  var MINI_PLAYER_TOGGLE_EVENT = 'miniPlayerToggle';

  // Module variables
  var originalWidth = null;
  var originalHeight = null;
  var originalNonLinearWidth = null;
  var originalNonLinearHeight = null;
  var isSetup = false;
  /** @type null | Element */
  var placeholderElement = null;
  var isMobile = false;
  /** @type boolean */
  var toggleByVisibilityControl = false;

  /**
   * Toggles the MiniPlayer given that it's enabled. Resets all other display modes.
   *
   * @param {'on'|'off'} [forceToggle]
   * @param {boolean} manualToggle
   */
  function toggleMiniPlayer(forceToggle) {
    var manualToggle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    playerInstance.debugMessage("[MiniPlayer] Toggling MiniPlayer, forceToggle: ".concat(forceToggle));
    var miniPlayerOptions = playerInstance.displayOptions.layoutControls.miniPlayer;
    if (!miniPlayerOptions.enabled) {
      playerInstance.debugMessage("[MiniPlayer] Prevent toggle MiniPlayer, it's currently disabled");
      return;
    }
    if (forceToggle === 'on' && playerInstance.miniPlayerToggledOn || forceToggle === 'off' && !playerInstance.miniPlayerToggledOn) {
      playerInstance.debugMessage("[MiniPlayer] Can't force toggle Mini Player to it's same state");
      return;
    }
    if (manualToggle) {
      toggleScreenDetection();
    }
    if (window.matchMedia(DESKTOP_ONLY_MEDIA_QUERY).matches) {
      isMobile = true;
    }

    // Important as the player can be in full screen or theater mode
    playerInstance.resetDisplayMode('miniPlayer');
    if (!isSetup) {
      // Setups JIT to avoid extra processing
      setupMiniPlayer();
    }
    if (forceToggle === 'off' || playerInstance.miniPlayerToggledOn) {
      toggleMiniPlayerOff();
    } else if (forceToggle === 'on' || !playerInstance.miniPlayerToggledOn) {
      toggleMiniPlayerOn(miniPlayerOptions.width, miniPlayerOptions.height, miniPlayerOptions.widthMobile, miniPlayerOptions.position);
    }
  }

  /**
   * Setups custom Mini Player DOM
   */
  function setupMiniPlayer() {
    var hasCloseButton = Boolean(playerInstance.domRef.player.parentNode.querySelector(".".concat(CLOSE_BUTTON_CLASS)));
    if (!hasCloseButton) {
      var closeButtonWrapper = document.createElement('div');
      closeButtonWrapper.classList.add(CLOSE_BUTTON_WRAPPER_CLASS);
      var closeButton = document.createElement('span');
      closeButton.classList.add(CLOSE_BUTTON_CLASS);
      closeButton.addEventListener('click', function () {
        toggleMiniPlayer('off', true);
        if (!playerInstance.domRef.player.paused) {
          playerInstance.playPauseToggle();
        }
      });
      closeButtonWrapper.appendChild(closeButton);
      playerInstance.domRef.player.parentNode.append(closeButtonWrapper);
    }
    if (isMobile) {
      setupMobile();
    }
    isSetup = true;
  }

  /**
   * Toggles the MiniPlayer off and restores previous functionality to player
   */
  function toggleMiniPlayerOff() {
    var videoWrapper = playerInstance.domRef.wrapper;
    removePlayerPlaceholder();
    videoWrapper.classList.remove(FLUID_PLAYER_WRAPPER_CLASS);
    videoWrapper.style.width = "".concat(originalWidth, "px");
    videoWrapper.style.height = "".concat(originalHeight, "px");
    originalWidth = null;
    originalHeight = null;
    adaptNonLinearSize();
    adaptLinearSize();
    playerInstance.miniPlayerToggledOn = false;
    emitToggleEvent();
  }

  /**
   * Toggles the MiniPlayer on, stores the original size of the player.
   *
   * @param {number} width
   * @param {number} height
   * @param {number} mobileWidth
   * @param {'top left'|'top right'|'bottom left'|'bottom right'} position
   */
  function toggleMiniPlayerOn(width, height, mobileWidth, position) {
    var videoWrapper = playerInstance.domRef.wrapper;
    var targetWidth = width > MINIMUM_WIDTH ? width : MINIMUM_WIDTH;
    var targetHeight = height > MINIMUM_HEIGHT ? height : MINIMUM_HEIGHT;
    var targetMobileWidth = mobileWidth > MINIMUM_WIDTH_MOBILE ? mobileWidth : MINIMUM_WIDTH_MOBILE;
    originalWidth = extractSizeFromElement(videoWrapper, 'width', 'clientWidth');
    originalHeight = extractSizeFromElement(videoWrapper, 'height', 'clientHeight');
    videoWrapper.classList.add(FLUID_PLAYER_WRAPPER_CLASS, "".concat(FLUID_PLAYER_WRAPPER_CLASS, "--").concat(position.trim().replace(/\s/, '-')));
    if (!isMobile) {
      videoWrapper.style.width = "".concat(targetWidth, "px");
      videoWrapper.style.height = "".concat(targetHeight, "px");
    } else {
      videoWrapper.style.width = "".concat(targetMobileWidth, "vw");
      videoWrapper.style.height = "auto";
      videoWrapper.style.aspectRatio = "16 / 9";
    }
    createPlayerPlaceholder(originalWidth, originalHeight);
    adaptNonLinearSize(targetWidth, targetHeight, targetMobileWidth);
    adaptLinearSize();
    playerInstance.miniPlayerToggledOn = true;
    emitToggleEvent();
  }

  /**
   * Emits event to Fluid Player Event API
   */
  function emitToggleEvent() {
    playerInstance.domRef.player.dispatchEvent(new CustomEvent(MINI_PLAYER_TOGGLE_EVENT, {
      detail: {
        isToggledOn: playerInstance.miniPlayerToggledOn
      }
    }));
  }

  /**
   * Extracts size from an element checking multiple element properties
   *
   * @param {HTMLElement} element
   * @param {'width'|'height'|null} styleProperty
   * @param {'clientWidth'|'clientHeight'|'width'|'height'} htmlProperty
   * @returns {number}
   */
  function extractSizeFromElement(element, styleProperty, htmlProperty) {
    if (styleProperty && element.style[styleProperty] && element.style[styleProperty].match('px')) {
      return parseInt(element.style[styleProperty]);
    } else {
      return String(element[htmlProperty]).match('px') ? parseInt(element[htmlProperty]) : element[htmlProperty];
    }
  }

  /**
   * Adapts NonLinear size (if present) to fit MiniPlayer view
   *
   * @param {number} [width]
   * @param {number} [height]
   * @param {number} [mobileWidth]
   */
  function adaptNonLinearSize(width, height, mobileWidth) {
    /** @type HTMLImageElement|HTMLIFrameElement */
    var nonLinear = playerInstance.domRef.wrapper.querySelector(NON_LINEAR_SELECTOR);
    /** @type HTMLElement */
    var vpaidFrame = playerInstance.domRef.wrapper.querySelector(VPAID_FRAME_SELECTOR);
    if (!nonLinear) return;
    if (isMobile) {
      width = window.innerWidth * mobileWidth / 100; // Transforms vw to px
    }

    var nonLinearWidth = extractSizeFromElement(nonLinear, null, 'width');
    var nonLinearHeight = extractSizeFromElement(nonLinear, null, 'height');
    if (originalNonLinearWidth && originalNonLinearHeight) {
      nonLinear.width = originalNonLinearWidth;
      nonLinear.height = originalNonLinearHeight;
      if (vpaidFrame) {
        vpaidFrame.style.width = "".concat(originalNonLinearWidth, "px");
        vpaidFrame.style.height = "".concat(originalNonLinearHeight, "px");
      }
      originalNonLinearWidth = originalNonLinearHeight = null;
    } else if (nonLinearWidth > width || nonLinearHeight > height) {
      var targetRatio = (width - (isMobile ? 4 : 32)) / nonLinearWidth;
      originalNonLinearWidth = nonLinearWidth;
      originalNonLinearHeight = nonLinearHeight;
      nonLinear.width = Math.round(nonLinearWidth * targetRatio);
      nonLinear.height = Math.round(nonLinearHeight * targetRatio);
      if (vpaidFrame) {
        vpaidFrame.style.width = "".concat(Math.round(nonLinearWidth * targetRatio), "px");
        vpaidFrame.style.height = "".concat(Math.round(nonLinearHeight * targetRatio), "px");
      }
    }
  }

  /**
   * Adapts Linear size (if present) to fit MiniPlayer view
   */
  function adaptLinearSize() {
    var clickTroughLayer = playerInstance.domRef.wrapper.querySelector(LINEAR_CLICKTHROUGH_SELECTOR);
    if (clickTroughLayer) {
      clickTroughLayer.style.width = "".concat(playerInstance.domRef.player.offsetWidth, "px");
      clickTroughLayer.style.height = "".concat(playerInstance.domRef.player.offsetHeight, "px");
    }
  }

  /**
   * Setups mobile disable element
   */
  function setupMobile() {
    var disableMiniPlayerMobile = document.createElement('div');
    var animationAmount = 0;
    var startTimestamp = 0;
    var startScreenX = 0;
    var hasTriggeredAnimation;
    disableMiniPlayerMobile.classList.add(DISABLE_MINI_PLAYER_MOBILE_CLASS);
    disableMiniPlayerMobile.ontouchstart = function (event) {
      hasTriggeredAnimation = false;
      startTimestamp = event.timeStamp;
      startScreenX = event.changedTouches[0].screenX;
      event.preventDefault();
    };
    disableMiniPlayerMobile.ontouchmove = function (event) {
      animationAmount = Math.min(Math.max(startScreenX - event.changedTouches[0].screenX, DISABLE_MINI_PLAYER_MOBILE_ANIMATION_CLAMP * -1), DISABLE_MINI_PLAYER_MOBILE_ANIMATION_CLAMP);
      if (Math.abs(animationAmount) > DISABLE_MINI_PLAYER_MOBILE_ANIMATION_DEADZONE) {
        // Moves the element the same amount as the touch event moved
        playerInstance.domRef.wrapper.style.transform = "translateX(".concat(animationAmount * -1, "px)");
        hasTriggeredAnimation = true;
      } else {
        playerInstance.domRef.wrapper.style.transform = "translateX(0px)";
      }
    };
    disableMiniPlayerMobile.ontouchend = function (event) {
      if (Math.abs(animationAmount) > DISABLE_MINI_PLAYER_MOBILE_ANIMATION_DEADZONE) {
        // Scroll X behaviour - Disable mini player and pauses video
        toggleMiniPlayer('off', true);
        if (!playerInstance.domRef.player.paused) {
          playerInstance.playPauseToggle();
        }
        event.preventDefault();
      } else if (!hasTriggeredAnimation) {
        // Tap behaviour - Disable mini player and moves screen to video
        toggleMiniPlayer('off', true);
        setTimeout(function () {
          playerInstance.domRef.wrapper.scrollIntoView({
            behavior: 'smooth',
            block: 'center'
          });
        });
      }
      animationAmount = 0;
      playerInstance.domRef.wrapper.style.transform = "";
    };

    // Fallback for when there is no touch event
    disableMiniPlayerMobile.onmouseup = function () {
      return toggleMiniPlayer('off', true);
    };
    playerInstance.domRef.wrapper.insertBefore(disableMiniPlayerMobile, playerInstance.domRef.player.nextSibling);
  }

  /**
   * Creates a placeholder element in place where the video player was
   *
   * @param {number} placeholderWidth
   * @param {number} placeholderHeight
   */
  function createPlayerPlaceholder(placeholderWidth, placeholderHeight) {
    placeholderElement = document.createElement('div');
    placeholderElement.classList.add(PLACEHOLDER_CLASS);
    placeholderElement.style.height = "".concat(placeholderHeight, "px");
    placeholderElement.style.width = "".concat(placeholderWidth, "px");
    placeholderElement.innerText = playerInstance.displayOptions.layoutControls.miniPlayer.placeholderText || '';
    placeholderElement.onclick = function () {
      return toggleMiniPlayer('off', true);
    };
    playerInstance.domRef.wrapper.parentElement.insertBefore(placeholderElement, playerInstance.domRef.wrapper);
  }

  /**
   * Removes the placeholder that was in place where video player was
   */
  function removePlayerPlaceholder() {
    playerInstance.domRef.wrapper.parentElement.removeChild(placeholderElement);
    placeholderElement = null;
  }

  /**
   * Toggles auto toggle for mini player
   */
  function toggleScreenDetection() {
    var autoToggle = playerInstance.displayOptions.layoutControls.miniPlayer.autoToggle;
    if (toggleByVisibilityControl || !autoToggle) {
      document.removeEventListener('scroll', toggleMiniPlayerByVisibility);
      return;
    }
    toggleByVisibilityControl = true;
    document.addEventListener('scroll', toggleMiniPlayerByVisibility, {
      passive: true
    });
  }

  /**
   * Checks for player visibility and toggles mini player based on it
   */
  var toggleMiniPlayerByVisibility = playerInstance.throttle(function toggleMiniPlayerByVisibility() {
    if (playerInstance.domRef.player.paused) {
      return;
    }
    var isPlayerVisible = playerInstance.isElementVisible(playerInstance.domRef.player);
    var isPlaceholderVisible = playerInstance.isElementVisible(playerInstance.domRef.wrapper.querySelector(".".concat(PLACEHOLDER_CLASS)));
    if (!isPlayerVisible && !playerInstance.miniPlayerToggledOn) {
      toggleMiniPlayer('on');
    } else if (isPlaceholderVisible && playerInstance.miniPlayerToggledOn) {
      toggleMiniPlayer('off');
    }
  }, TOGGLE_BY_VISIBILITY_DETECTION_RATE);

  // Exposes public module functions
  playerInstance.toggleMiniPlayer = toggleMiniPlayer;
  playerInstance.toggleMiniPlayerScreenDetection = toggleScreenDetection;
}
;// CONCATENATED MODULE: ./src/fluidplayer.js


// Player modules
function fluidplayer_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ fluidplayer_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == fluidplayer_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function fluidplayer_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function fluidplayer_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { fluidplayer_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { fluidplayer_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function fluidplayer_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = fluidplayer_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function fluidplayer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return fluidplayer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return fluidplayer_arrayLikeToArray(o, minLen); }
function fluidplayer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function fluidplayer_typeof(obj) { "@babel/helpers - typeof"; return fluidplayer_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, fluidplayer_typeof(obj); }










var FP_MODULES = [vpaid, vast, cardboard, subtitles, timeline, adsupport, streaming, utils, suggestedVideos, miniplayer];

// Determine build mode
// noinspection JSUnresolvedVariable
var FP_DEVELOPMENT_MODE =  true && "production" === 'development';

// Are we running in debug mode?
// noinspection JSUnresolvedVariable
var FP_RUNTIME_DEBUG =  true && false === true;
var playerInstances = 0;
var fluidPlayerClass = function fluidPlayerClass() {
  var _this = this;
  // "self" always points to current instance of the player within the scope of the instance
  // This should help readability and context awareness slightly...
  var self = this;
  self.domRef = {
    player: null
  };

  // noinspection JSUnresolvedVariable
  self.version =  true ? "3.38.0" : 0;
  // noinspection JSUnresolvedVariable
  self.homepage =  true ? "https://fluidplayer.com" + '/?utm_source=player&utm_medium=context_menu&utm_campaign=organic' : 0;
  self.destructors = [];
  self.init = function (playerTarget, options) {
    // Install player modules and features
    var moduleOptions = {
      development: FP_DEVELOPMENT_MODE,
      debug: FP_RUNTIME_DEBUG
    };
    for (var _i = 0, _FP_MODULES = FP_MODULES; _i < _FP_MODULES.length; _i++) {
      var playerModule = _FP_MODULES[_i];
      playerModule(self, moduleOptions);
    }
    var playerNode;
    if (playerTarget instanceof HTMLVideoElement) {
      playerNode = playerTarget;

      // Automatically assign ID if none exists
      if (!playerTarget.id) {
        playerTarget.id = 'fluid_player_instance_' + (playerInstances++).toString();
      }
    } else if (typeof playerTarget === 'string' || playerTarget instanceof String) {
      playerNode = document.getElementById(playerTarget);
    } else {
      throw 'Invalid initializer - player target must be HTMLVideoElement or ID';
    }
    if (!playerNode) {
      throw 'Could not find a HTML node to attach to for target ' + playerTarget + '"';
    }
    if (playerNode.classList.contains('js-fluid-player')) {
      throw 'Invalid initializer - player target already is initialized';
    }
    playerNode.setAttribute('playsinline', '');
    playerNode.setAttribute('webkit-playsinline', '');
    playerNode.classList.add('js-fluid-player');
    self.domRef.player = playerNode;
    self.vrROTATION_POSITION = 0.1;
    self.vrROTATION_SPEED = 80;
    self.vrMode = false;
    self.vrPanorama = null;
    self.vrViewer = null;
    self.vpaidTimer = null;
    self.vpaidAdUnit = null;
    self.vastOptions = null;
    /**
     * Don't use this as a way to change the DOM. DOM manipulation should be done with domRef.
     */
    self.videoPlayerId = playerNode.id;
    self.originalSrc = self.getCurrentSrc();
    self.isCurrentlyPlayingAd = false;
    self.recentWaiting = false;
    self.latestVolume = 1;
    self.currentVideoDuration = 0;
    self.firstPlayLaunched = false;
    self.suppressClickthrough = false;
    self.timelinePreviewData = [];
    self.mainVideoCurrentTime = 0;
    self.mainVideoDuration = 0;
    self.isTimer = false;
    self.timer = null;
    self.timerPool = {};
    self.rollsById = {};
    self.adPool = {};
    self.adGroupedByRolls = {};
    self.onPauseRollAdPods = [];
    self.currentOnPauseRollAd = '';
    self.preRollAdsResolved = false;
    self.preRollAdPods = [];
    self.preRollAdPodsLength = 0;
    self.preRollVastResolved = 0;
    self.temporaryAdPods = [];
    self.availableRolls = ['preRoll', 'midRoll', 'postRoll', 'onPauseRoll'];
    self.supportedNonLinearAd = ['300x250', '468x60', '728x90'];
    self.autoplayAfterAd = true;
    self.nonLinearDuration = 15;
    self.supportedStaticTypes = ['image/gif', 'image/jpeg', 'image/png'];
    self.inactivityTimeout = null;
    self.isUserActive = null;
    self.nonLinearVerticalAlign = 'bottom';
    self.vpaidNonLinearCloseButton = true;
    self.showTimeOnHover = true;
    self.initialAnimationSet = true;
    self.theatreMode = false;
    self.theatreModeAdvanced = false;
    self.fullscreenMode = false;
    self.originalWidth = playerNode.offsetWidth;
    self.originalHeight = playerNode.offsetHeight;
    self.dashPlayer = false;
    self.hlsPlayer = false;
    self.dashScriptLoaded = false;
    self.hlsScriptLoaded = false;
    self.isPlayingMedia = false;
    self.isSwitchingSource = false;
    self.isLoading = false;
    self.isInIframe = self.inIframe();
    self.mainVideoReadyState = false;
    self.xmlCollection = [];
    self.inLineFound = null;
    self.fluidStorage = {};
    self.fluidPseudoPause = false;
    self.mobileInfo = self.getMobileOs();
    self.events = {};
    self.timeSkipOffsetAmount = 10;

    //Default options
    self.displayOptions = {
      layoutControls: {
        mediaType: self.getCurrentSrcType(),
        primaryColor: false,
        posterImage: false,
        posterImageSize: 'contain',
        adProgressColor: '#f9d300',
        playButtonShowing: true,
        playPauseAnimation: true,
        closeButtonCaption: 'Close',
        // Remove?
        fillToContainer: false,
        autoPlay: false,
        preload: 'auto',
        mute: false,
        loop: null,
        keyboardControl: true,
        allowDownload: false,
        playbackRateEnabled: false,
        subtitlesEnabled: false,
        subtitlesOnByDefault: true,
        showCardBoardView: false,
        showCardBoardJoystick: false,
        allowTheatre: true,
        doubleclickFullscreen: true,
        theatreSettings: {
          width: '100%',
          height: '60%',
          marginTop: 0,
          horizontalAlign: 'center',
          keepPosition: false
        },
        theatreAdvanced: {
          theatreElement: null
        },
        title: null,
        logo: {
          imageUrl: null,
          position: 'top left',
          clickUrl: null,
          opacity: 1,
          mouseOverImageUrl: null,
          imageMargin: '2px',
          hideWithControls: false,
          showOverAds: false
        },
        controlBar: {
          autoHide: false,
          autoHideTimeout: 3,
          animated: true,
          playbackRates: ['x2', 'x1.5', 'x1', 'x0.5']
        },
        timelinePreview: {
          spriteImage: false,
          spriteRelativePath: false
        },
        htmlOnPauseBlock: {
          html: null,
          height: null,
          width: null
        },
        layout: 'default',
        //options: 'default', '<custom>'
        playerInitCallback: function playerInitCallback() {},
        persistentSettings: {
          volume: true,
          quality: true,
          speed: true,
          theatre: true
        },
        controlForwardBackward: {
          show: false,
          doubleTapMobile: true
        },
        contextMenu: {
          controls: true,
          links: []
        },
        miniPlayer: {
          enabled: true,
          width: 400,
          height: 225,
          widthMobile: 50,
          placeholderText: 'Playing in Miniplayer',
          position: 'bottom right',
          autoToggle: false
        }
      },
      suggestedVideos: {
        configUrl: null
      },
      vastOptions: {
        adList: {},
        skipButtonCaption: 'Skip ad in [seconds]',
        skipButtonClickCaption: 'Skip Ad <span class="skip_button_icon"></span>',
        adText: null,
        adTextPosition: 'top left',
        adCTAText: 'Visit now!',
        adCTATextPosition: 'bottom right',
        adCTATextVast: false,
        adClickable: true,
        vastTimeout: 5000,
        showProgressbarMarkers: false,
        allowVPAID: false,
        showPlayButton: false,
        maxAllowedVastTagRedirects: 3,
        vpaidTimeout: 3000,
        vastAdvanced: {
          vastLoadedCallback: function vastLoadedCallback() {},
          noVastVideoCallback: function noVastVideoCallback() {},
          vastVideoSkippedCallback: function vastVideoSkippedCallback() {},
          vastVideoEndedCallback: function vastVideoEndedCallback() {}
        }
      },
      hls: {
        overrideNative: false
      },
      captions: {
        play: 'Play',
        pause: 'Pause',
        mute: 'Mute',
        unmute: 'Unmute',
        fullscreen: 'Fullscreen',
        subtitles: 'Subtitles',
        exitFullscreen: 'Exit Fullscreen'
      },
      debug: FP_RUNTIME_DEBUG,
      modules: {
        configureHls: function configureHls(options) {
          return options;
        },
        onBeforeInitHls: function onBeforeInitHls(hls) {},
        onAfterInitHls: function onAfterInitHls(hls) {},
        configureDash: function configureDash(options) {
          return options;
        },
        onBeforeInitDash: function onBeforeInitDash(dash) {},
        onAfterInitDash: function onAfterInitDash(dash) {}
      },
      onBeforeXMLHttpRequestOpen: function onBeforeXMLHttpRequestOpen(request) {},
      onBeforeXMLHttpRequest: function onBeforeXMLHttpRequest(request) {
        if (FP_RUNTIME_DEBUG || FP_DEVELOPMENT_MODE) {
          console.debug('[FP_DEBUG] Request made', request);
        }
      }
    };
    if (!!options.hlsjsConfig) {
      console.error('[FP_ERROR] player option hlsjsConfig is removed and has no effect. ' + 'Use module callbacks instead!');
    }

    /**
     * Replaces values from objects without replacing the default object
     *
     * @param defaults
     * @param options
     * @returns {object}
     */
    function overrideDefaults(defaults, options) {
      Object.keys(options).forEach(function (defaultKey) {
        if (fluidplayer_typeof(options[defaultKey]) === 'object' && options[defaultKey] !== null && !Array.isArray(options[defaultKey])) {
          overrideDefaults(defaults[defaultKey], options[defaultKey]);
        } else if (typeof options[defaultKey] !== 'undefined') {
          defaults[defaultKey] = options[defaultKey];
        }
      });
      return defaults;
    }
    overrideDefaults(self.displayOptions, options);
    self.domRef.wrapper = self.setupPlayerWrapper();
    playerNode.addEventListener('webkitfullscreenchange', self.recalculateAdDimensions);
    playerNode.addEventListener('fullscreenchange', self.recalculateAdDimensions);
    playerNode.addEventListener('waiting', self.onRecentWaiting);
    playerNode.addEventListener('pause', self.onFluidPlayerPause);
    playerNode.addEventListener('error', self.onErrorDetection);
    playerNode.addEventListener('ended', self.onMainVideoEnded);
    playerNode.addEventListener('durationchange', function () {
      self.currentVideoDuration = self.getCurrentVideoDuration();
    });

    // 'loadedmetadata' inconsistently fires because the audio can already be loaded when the listener is added.
    // Here we use readystate to see if metadata has already loaded
    if (playerNode.readyState > 0) {
      self.mainVideoReady();
    } else {
      playerNode.addEventListener('loadedmetadata', self.mainVideoReady);
    }
    if (self.displayOptions.layoutControls.showCardBoardView) {
      // This fixes cross origin errors on three.js
      playerNode.setAttribute('crossOrigin', 'anonymous');
    }

    //Manually load the video duration if the video was loaded before adding the event listener
    self.currentVideoDuration = self.getCurrentVideoDuration();
    if (isNaN(self.currentVideoDuration) || !isFinite(self.currentVideoDuration)) {
      self.currentVideoDuration = 0;
    }
    self.setLayout();

    //Set the volume control state
    self.latestVolume = playerNode.volume;

    // Set the default animation setting
    self.initialAnimationSet = self.displayOptions.layoutControls.playPauseAnimation;

    //Set the custom fullscreen behaviour
    self.handleFullscreen();
    self.initLogo();
    self.initTitle();
    self.initMute();
    self.initLoop();
    self.displayOptions.layoutControls.playerInitCallback();
    self.createVideoSourceSwitch();
    self.createSubtitles();
    self.createCardboard();
    self.userActivityChecker();
    self.setVastList();
    self.setPersistentSettings();
    self.generateSuggestedVideoList();

    // Previously prevented to be initialized if preRolls were set up
    // but now the streamers support reinitialization
    self.initialiseStreamers();
    var _play_videoPlayer = playerNode.play;
    playerNode.play = function () {
      var promise = null;
      if (self.displayOptions.layoutControls.showCardBoardView) {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
          DeviceOrientationEvent.requestPermission().then(function (response) {
            if (response === 'granted') {
              self.debugMessage('DeviceOrientationEvent permission granted!');
            }
          }).catch(console.error);
        }
      }
      try {
        promise = _play_videoPlayer.apply(this, arguments);
        if (promise !== undefined && promise !== null) {
          promise.then(function () {
            self.isPlayingMedia = true;
            clearTimeout(self.promiseTimeout);
          }).catch(function (error) {
            console.error('[FP_ERROR] Playback error', error);
            var isAbortError = typeof error.name !== 'undefined' && error.name === 'AbortError';
            // Ignore abort errors which caused for example Safari or autoplay functions
            // (example: interrupted by a new load request)
            // (example: interrupted by a new load request)
            if (isAbortError) {
              // Ignore AbortError error reporting
            } else {
              self.announceLocalError(202, 'Failed to play video.');
            }
            clearTimeout(self.promiseTimeout);
          });
          self.promiseTimeout = setTimeout(function () {
            if (self.isPlayingMedia === false) {
              self.announceLocalError(204, '[FP_ERROR] Timeout error. Failed to play video?');
            }
          }, 5000);
        }
        return promise;
      } catch (error) {
        console.error('[FP_ERROR] Playback error', error);
        self.announceLocalError(201, 'Failed to play video.');
      }
    };
    var videoPauseOriginal = playerNode.pause;
    playerNode.pause = function () {
      if (self.isPlayingMedia === true) {
        self.isPlayingMedia = false;
        return videoPauseOriginal.apply(this, arguments);
      }

      // just in case
      if (self.isCurrentlyPlayingVideo(self.domRef.player)) {
        try {
          self.isPlayingMedia = false;
          return videoPauseOriginal.apply(this, arguments);
        } catch (e) {
          self.announceLocalError(203, 'Failed to play video.');
        }
      }
    };
    if (!!self.displayOptions.layoutControls.autoPlay && !self.dashScriptLoaded && !self.hlsScriptLoaded) {
      //There is known issue with Safari 11+, will prevent autoPlay, so we wont try
      var browserVersion = self.getBrowserVersion();
      if ('Safari' === browserVersion.browserName) {
        return;
      }
      playerNode.play();
    }
    if (!self.mobileInfo.userOs) {
      if (!self.displayOptions.layoutControls.controlBar.autoHide) {
        self.domRef.wrapper.addEventListener('mouseleave', self.handleMouseleave, false);
      }
      self.domRef.wrapper.addEventListener('mouseenter', self.showControlBar, false);
      self.domRef.wrapper.addEventListener('mouseenter', self.showTitle, false);
    } else {
      //On mobile mouseleave behavior does not make sense, so it's better to keep controls, once the playback starts
      //Autohide behavior on timer is a separate functionality
      self.hideControlBar();
      self.domRef.wrapper.addEventListener('touchstart', self.showControlBar, {
        passive: true
      });
    }

    //Keyboard Controls
    if (self.displayOptions.layoutControls.keyboardControl) {
      self.keyboardControl();
    }
    if (self.displayOptions.layoutControls.controlBar.autoHide) {
      self.linkControlBarUserActivity();
    }

    // Hide the captions on init if user added subtitles track.
    // We are taking captions track kind of as metadata
    try {
      if (!!self.domRef.player.textTracks) {
        var _iterator = fluidplayer_createForOfIteratorHelper(self.domRef.player.textTracks),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var textTrack = _step.value;
            textTrack.mode = 'hidden';
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    } catch (_ignored) {}
  };
  self.getCurrentVideoDuration = function () {
    if (self.domRef.player) {
      return self.domRef.player.duration;
    }
    return 0;
  };
  self.toggleLoader = function (showLoader) {
    self.isLoading = !!showLoader;
    var loaderDiv = self.domRef.wrapper.querySelector('.vast_video_loading');
    if (loaderDiv) {
      loaderDiv.style.display = showLoader ? 'table' : 'none';
    }
  };
  self.sendRequest = function (url, withCredentials, timeout, functionReadyStateChange) {
    var xmlHttpReq = new XMLHttpRequest();
    xmlHttpReq.onreadystatechange = functionReadyStateChange;
    self.displayOptions.onBeforeXMLHttpRequestOpen(xmlHttpReq);
    xmlHttpReq.open('GET', url, true);
    xmlHttpReq.withCredentials = withCredentials;
    xmlHttpReq.timeout = timeout;
    self.displayOptions.onBeforeXMLHttpRequest(xmlHttpReq);
    xmlHttpReq.send();
  };

  /**
   * Makes a XMLHttpRequest encapsulated by a Promise
   *
   * @param url
   * @param withCredentials
   * @param timeout
   * @returns {Promise<unknown>}
   */
  self.sendRequestAsync = /*#__PURE__*/function () {
    var _ref = fluidplayer_asyncToGenerator( /*#__PURE__*/fluidplayer_regeneratorRuntime().mark(function _callee(url, withCredentials, timeout) {
      return fluidplayer_regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return new Promise(function (resolve, reject) {
              var xmlHttpReq = new XMLHttpRequest();
              xmlHttpReq.onreadystatechange = function (event) {
                var response = event.target;
                if (response.readyState === 4 && response.status >= 200 && response.status < 300) {
                  resolve(response);
                } else if (response.readyState === 4) {
                  reject(response);
                }
              };
              self.displayOptions.onBeforeXMLHttpRequestOpen(xmlHttpReq);
              xmlHttpReq.open('GET', url, true);
              xmlHttpReq.withCredentials = withCredentials;
              xmlHttpReq.timeout = timeout;
              self.displayOptions.onBeforeXMLHttpRequest(xmlHttpReq);
              xmlHttpReq.send();
            });
          case 2:
            return _context.abrupt("return", _context.sent);
          case 3:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();

  // TODO: rename
  self.announceLocalError = function (code, msg) {
    var parsedCode = typeof code !== 'undefined' ? parseInt(code) : 900;
    var message = '[Error] (' + parsedCode + '): ';
    message += !msg ? 'Failed to load Vast' : msg;
    console.warn(message);
  };

  // TODO: move this somewhere else and refactor
  self.debugMessage = function () {
    var style = 'color: #fff; font-weight: bold; background-color: #1a5e87; padding: 3px 6px; border-radius: 3px;';
    if (self.displayOptions.debug) {
      var _console;
      for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {
        msg[_key] = arguments[_key];
      }
      (_console = console).log.apply(_console, ['%cFP DEBUG', style].concat(msg));
    }
  };
  self.onMainVideoEnded = function (event) {
    self.debugMessage('onMainVideoEnded is called');
    if (self.isCurrentlyPlayingAd && self.autoplayAfterAd) {
      // It may be in-stream ending, and if it's not postroll then we don't execute anything
      return;
    }

    //we can remove timer as no more ad will be shown
    if (Math.floor(self.getCurrentTime()) >= Math.floor(self.mainVideoDuration)) {
      // play pre-roll ad
      // sometime pre-roll ad will be missed because we are clearing the timer
      self.adKeytimePlay(Math.floor(self.mainVideoDuration));
      clearInterval(self.timer);
    }
    if (!!self.displayOptions.layoutControls.loop) {
      self.switchToMainVideo();
      self.playPauseToggle();
    }

    // Event listener doesn't wait on flags to be flipped from post roll ads, needs small time out to compensate
    setTimeout(function () {
      if (!self.isCurrentlyPlayingAd && self.displayOptions.suggestedVideos.configUrl) {
        self.displaySuggestedVideos();
      }
    }, 100);
  };
  self.getCurrentTime = function () {
    return self.isCurrentlyPlayingAd ? self.mainVideoCurrentTime : self.domRef.player.currentTime;
  };

  /**
   * Gets the src value of the first source element of the video tag.
   *
   * @returns string|null
   */
  self.getCurrentSrc = function () {
    var sources = self.domRef.player.getElementsByTagName('source');
    if (sources.length) {
      return sources[0].getAttribute('src');
    }
    return null;
  };

  /**
   * Src types required for streaming elements
   */
  self.getCurrentSrcType = function () {
    var sources = self.domRef.player.getElementsByTagName('source');
    if (!sources.length) {
      return null;
    }
    for (var i = 0; i < sources.length; i++) {
      if (sources[i].getAttribute('src') === self.originalSrc) {
        return sources[i].getAttribute('type').toLowerCase();
      }
    }
    return null;
  };
  self.onRecentWaiting = function () {
    self.recentWaiting = true;
    setTimeout(function () {
      self.recentWaiting = false;
    }, 1000);
  };

  /**
   * Dispatches a custom pause event which is not present when seeking.
   */
  self.onFluidPlayerPause = function () {
    setTimeout(function () {
      if (self.recentWaiting) {
        return;
      }
      var event = document.createEvent('CustomEvent');
      event.initEvent('fluidplayerpause', false, true);
      self.domRef.player.dispatchEvent(event);
    }, 100);
  };
  self.checkShouldDisplayVolumeBar = function () {
    return 'iOS' !== self.getMobileOs().userOs;
  };
  self.generateCustomControlTags = function (options) {
    var controls = {};

    // Loader
    controls.loader = document.createElement('div');
    controls.loader.className = 'vast_video_loading';
    controls.loader.style.display = 'none';

    // Root element
    controls.root = document.createElement('div');
    controls.root.className = 'fluid_controls_container';
    if (!options.displayVolumeBar) {
      controls.root.className = controls.root.className + ' no_volume_bar';
    }
    if (options.controlForwardBackward) {
      controls.root.className = controls.root.className + ' skip_controls';
    }

    // Left container
    controls.leftContainer = document.createElement('div');
    controls.leftContainer.className = 'fluid_controls_left';
    controls.root.appendChild(controls.leftContainer);

    // Left container -> Play/Pause
    controls.playPause = document.createElement('div');
    controls.playPause.className = 'fluid_button fluid_button_play fluid_control_playpause';
    controls.leftContainer.appendChild(controls.playPause);
    if (options.controlForwardBackward) {
      // Left container -> Skip backwards
      controls.skipBack = document.createElement('div');
      controls.skipBack.className = 'fluid_button fluid_button_skip_back';
      controls.leftContainer.appendChild(controls.skipBack);

      // Left container -> Skip forward
      controls.skipForward = document.createElement('div');
      controls.skipForward.className = 'fluid_button fluid_button_skip_forward';
      controls.leftContainer.appendChild(controls.skipForward);
    }

    // Progress container
    controls.progressContainer = document.createElement('div');
    controls.progressContainer.className = 'fluid_controls_progress_container fluid_slider';
    controls.root.appendChild(controls.progressContainer);

    // Progress container -> Progress wrapper
    controls.progressWrapper = document.createElement('div');
    controls.progressWrapper.className = 'fluid_controls_progress';
    controls.progressContainer.appendChild(controls.progressWrapper);

    // Progress container -> Progress wrapper -> Current progress
    controls.progressCurrent = document.createElement('div');
    controls.progressCurrent.className = 'fluid_controls_currentprogress';
    controls.progressCurrent.style.backgroundColor = options.primaryColor;
    controls.progressWrapper.appendChild(controls.progressCurrent);

    // Progress container -> Progress wrapper -> Current progress -> Marker
    controls.progress_current_marker = document.createElement('div');
    controls.progress_current_marker.className = 'fluid_controls_currentpos';
    controls.progressCurrent.appendChild(controls.progress_current_marker);

    // Progress container -> Buffered indicator
    controls.bufferedIndicator = document.createElement('div');
    controls.bufferedIndicator.className = 'fluid_controls_buffered';
    controls.progressContainer.appendChild(controls.bufferedIndicator);

    // Progress container -> Ad markers
    controls.adMarkers = document.createElement('div');
    controls.adMarkers.className = 'fluid_controls_ad_markers_holder';
    controls.progressContainer.appendChild(controls.adMarkers);

    // Right container
    controls.rightContainer = document.createElement('div');
    controls.rightContainer.className = 'fluid_controls_right';
    controls.root.appendChild(controls.rightContainer);

    // Right container -> Fullscreen
    controls.fullscreen = document.createElement('div');
    controls.fullscreen.className = 'fluid_button fluid_control_fullscreen fluid_button_fullscreen';
    controls.rightContainer.appendChild(controls.fullscreen);
    if (options.miniPlayer.enabled) {
      // Right container -> MiniPlayer
      controls.miniPlayer = document.createElement('div');
      controls.miniPlayer.className = 'fluid_button fluid_control_mini_player fluid_button_mini_player';
      controls.rightContainer.appendChild(controls.miniPlayer);
    }

    // Right container -> Theatre
    controls.theatre = document.createElement('div');
    controls.theatre.className = 'fluid_button fluid_control_theatre fluid_button_theatre';
    controls.rightContainer.appendChild(controls.theatre);

    // Right container -> Cardboard
    controls.cardboard = document.createElement('div');
    controls.cardboard.className = 'fluid_button fluid_control_cardboard fluid_button_cardboard';
    controls.rightContainer.appendChild(controls.cardboard);

    // Right container -> Subtitles
    controls.subtitles = document.createElement('div');
    controls.subtitles.className = 'fluid_button fluid_control_subtitles fluid_button_subtitles';
    controls.rightContainer.appendChild(controls.subtitles);

    // Right container -> Video source
    controls.videoSource = document.createElement('div');
    controls.videoSource.className = 'fluid_button fluid_control_video_source fluid_button_video_source';
    controls.rightContainer.appendChild(controls.videoSource);

    // Right container -> Playback rate
    controls.playbackRate = document.createElement('div');
    controls.playbackRate.className = 'fluid_button fluid_control_playback_rate fluid_button_playback_rate';
    controls.rightContainer.appendChild(controls.playbackRate);

    // Right container -> Download
    controls.download = document.createElement('div');
    controls.download.className = 'fluid_button fluid_control_download fluid_button_download';
    controls.rightContainer.appendChild(controls.download);

    // Right container -> Volume container
    controls.volumeContainer = document.createElement('div');
    controls.volumeContainer.className = 'fluid_control_volume_container fluid_slider';
    controls.rightContainer.appendChild(controls.volumeContainer);

    // Right container -> Volume container -> Volume
    controls.volume = document.createElement('div');
    controls.volume.className = 'fluid_control_volume';
    controls.volumeContainer.appendChild(controls.volume);

    // Right container -> Volume container -> Volume -> Current
    controls.volumeCurrent = document.createElement('div');
    controls.volumeCurrent.className = 'fluid_control_currentvolume';
    controls.volume.appendChild(controls.volumeCurrent);

    // Right container -> Volume container -> Volume -> Current -> position
    controls.volumeCurrentPos = document.createElement('div');
    controls.volumeCurrentPos.className = 'fluid_control_volume_currentpos';
    controls.volumeCurrent.appendChild(controls.volumeCurrentPos);

    // Right container -> Volume container
    controls.mute = document.createElement('div');
    controls.mute.className = 'fluid_button fluid_button_volume fluid_control_mute';
    controls.rightContainer.appendChild(controls.mute);

    // Right container -> Volume container
    controls.duration = document.createElement('div');
    controls.duration.className = 'fluid_control_duration fluid_fluid_control_duration';
    controls.duration.innerText = '00:00 / 00:00';
    controls.rightContainer.appendChild(controls.duration);
    return controls;
  };
  self.controlPlayPauseToggle = function () {
    var playPauseButton = self.domRef.player.parentNode.getElementsByClassName('fluid_control_playpause');
    var menuOptionPlay = self.domRef.wrapper.querySelector('.context_option_play');
    var controlsDisplay = self.domRef.player.parentNode.getElementsByClassName('fluid_controls_container');
    var fpLogo = self.domRef.wrapper.querySelector('.logo_holder');
    var initialPlay = self.domRef.wrapper.querySelector('.fluid_initial_play');
    if (initialPlay) {
      self.domRef.wrapper.querySelector('.fluid_initial_play').style.display = "none";
      self.domRef.wrapper.querySelector('.fluid_initial_play_button_container').style.opacity = "1";
    }
    if (!self.domRef.player.paused) {
      for (var i = 0; i < playPauseButton.length; i++) {
        playPauseButton[i].className = playPauseButton[i].className.replace(/\bfluid_button_play\b/g, 'fluid_button_pause');
      }
      for (var _i2 = 0; _i2 < controlsDisplay.length; _i2++) {
        controlsDisplay[_i2].classList.remove('initial_controls_show');
      }
      if (fpLogo) {
        fpLogo.classList.remove('initial_controls_show');
      }
      if (menuOptionPlay !== null) {
        menuOptionPlay.innerHTML = self.displayOptions.captions.pause;
      }
      return;
    }
    for (var _i3 = 0; _i3 < playPauseButton.length; _i3++) {
      playPauseButton[_i3].className = playPauseButton[_i3].className.replace(/\bfluid_button_pause\b/g, 'fluid_button_play');
    }
    for (var _i4 = 0; _i4 < controlsDisplay.length; _i4++) {
      controlsDisplay[_i4].classList.add('initial_controls_show');
    }
    if (self.isCurrentlyPlayingAd && self.displayOptions.vastOptions.showPlayButton) {
      self.domRef.wrapper.querySelector('.fluid_initial_play').style.display = "block";
      self.domRef.wrapper.querySelector('.fluid_initial_play_button_container').style.opacity = "1";
    }
    if (fpLogo) {
      fpLogo.classList.add('initial_controls_show');
    }
    if (menuOptionPlay !== null) {
      menuOptionPlay.innerHTML = self.displayOptions.captions.play;
    }
  };
  self.playPauseAnimationToggle = function (play) {
    if (self.isCurrentlyPlayingAd || !self.displayOptions.layoutControls.playPauseAnimation || self.isSwitchingSource) {
      return;
    }
    var playButtonElement = self.domRef.wrapper.querySelector('.fluid_initial_play_button, .fluid_initial_pause_button');
    if (play) {
      playButtonElement.classList.remove('fluid_initial_pause_button');
      playButtonElement.classList.add('fluid_initial_play_button');
    } else {
      playButtonElement.classList.remove('fluid_initial_play_button');
      playButtonElement.classList.add('fluid_initial_pause_button');
    }
    self.domRef.wrapper.querySelector('.fluid_initial_play').classList.add('transform-active');
    setTimeout(function () {
      self.domRef.wrapper.querySelector('.fluid_initial_play').classList.remove('transform-active');
    }, 800);
  };
  self.contolProgressbarUpdate = function () {
    var currentProgressTag = self.domRef.player.parentNode.getElementsByClassName('fluid_controls_currentprogress');
    for (var i = 0; i < currentProgressTag.length; i++) {
      currentProgressTag[i].style.width = self.domRef.player.currentTime / self.currentVideoDuration * 100 + '%';
    }
  };
  self.controlDurationUpdate = function () {
    var currentPlayTime = self.formatTime(self.domRef.player.currentTime);
    var isLiveHls = false;
    if (self.hlsPlayer) {
      isLiveHls = self.hlsPlayer.levels && self.hlsPlayer.levels[self.hlsPlayer.currentLevel] && self.hlsPlayer.levels[self.hlsPlayer.currentLevel].details.live;
    }
    var durationText;
    if (isNaN(self.currentVideoDuration) || !isFinite(self.currentVideoDuration) || isLiveHls) {
      durationText = currentPlayTime;
    } else {
      var totalTime = self.formatTime(self.currentVideoDuration);
      durationText = currentPlayTime + ' / ' + totalTime;
    }
    var timePlaceholder = self.domRef.player.parentNode.getElementsByClassName('fluid_control_duration');
    for (var i = 0; i < timePlaceholder.length; i++) {
      timePlaceholder[i].innerHTML = durationText;
    }
  };
  self.contolVolumebarUpdate = function () {
    var currentVolumeTag = self.domRef.wrapper.querySelector('.fluid_control_currentvolume');
    var volumeposTag = self.domRef.wrapper.querySelector('.fluid_control_volume_currentpos');
    var volumebarTotalWidth = self.domRef.wrapper.querySelector('.fluid_control_volume').clientWidth;
    var volumeposTagWidth = volumeposTag.clientWidth;
    var muteButtonTag = self.domRef.player.parentNode.getElementsByClassName('fluid_control_mute');
    var menuOptionMute = self.domRef.wrapper.querySelector('.context_option_mute');
    if (0 !== self.domRef.player.volume) {
      self.latestVolume = self.domRef.player.volume;
      self.fluidStorage.fluidMute = false;
    } else {
      self.fluidStorage.fluidMute = true;
    }
    if (self.domRef.player.volume && !self.domRef.player.muted) {
      for (var i = 0; i < muteButtonTag.length; i++) {
        muteButtonTag[i].className = muteButtonTag[i].className.replace(/\bfluid_button_mute\b/g, 'fluid_button_volume');
      }
      if (menuOptionMute !== null) {
        menuOptionMute.innerHTML = self.displayOptions.captions.mute;
      }
    } else {
      for (var _i5 = 0; _i5 < muteButtonTag.length; _i5++) {
        muteButtonTag[_i5].className = muteButtonTag[_i5].className.replace(/\bfluid_button_volume\b/g, 'fluid_button_mute');
      }
      if (menuOptionMute !== null) {
        menuOptionMute.innerHTML = self.displayOptions.captions.unmute;
      }
    }
    currentVolumeTag.style.width = self.domRef.player.volume * volumebarTotalWidth + 'px';
    volumeposTag.style.left = self.domRef.player.volume * volumebarTotalWidth - volumeposTagWidth / 2 + 'px';
  };
  self.muteToggle = function () {
    if (0 !== self.domRef.player.volume && !self.domRef.player.muted) {
      self.domRef.player.volume = 0;
      self.domRef.player.muted = true;
    } else {
      self.domRef.player.volume = self.latestVolume;
      self.domRef.player.muted = false;
    }

    // Persistent settings
    self.fluidStorage.fluidVolume = self.latestVolume;
    self.fluidStorage.fluidMute = self.domRef.player.muted;
  };
  self.checkFullscreenSupport = function () {
    var videoPlayerWrapper = self.domRef.wrapper;
    if (videoPlayerWrapper.mozRequestFullScreen) {
      return {
        goFullscreen: 'mozRequestFullScreen',
        exitFullscreen: 'mozCancelFullScreen',
        isFullscreen: 'mozFullScreenElement'
      };
    } else if (videoPlayerWrapper.webkitRequestFullscreen) {
      return {
        goFullscreen: 'webkitRequestFullscreen',
        exitFullscreen: 'webkitExitFullscreen',
        isFullscreen: 'webkitFullscreenElement'
      };
    } else if (videoPlayerWrapper.msRequestFullscreen) {
      return {
        goFullscreen: 'msRequestFullscreen',
        exitFullscreen: 'msExitFullscreen',
        isFullscreen: 'msFullscreenElement'
      };
    } else if (videoPlayerWrapper.requestFullscreen) {
      return {
        goFullscreen: 'requestFullscreen',
        exitFullscreen: 'exitFullscreen',
        isFullscreen: 'fullscreenElement'
      };
    } else if (self.domRef.player.webkitSupportsFullscreen) {
      return {
        goFullscreen: 'webkitEnterFullscreen',
        exitFullscreen: 'webkitExitFullscreen',
        isFullscreen: 'webkitDisplayingFullscreen'
      };
    }
    return false;
  };
  self.fullscreenOff = function (fullscreenButton, menuOptionFullscreen) {
    for (var i = 0; i < fullscreenButton.length; i++) {
      fullscreenButton[i].className = fullscreenButton[i].className.replace(/\bfluid_button_fullscreen_exit\b/g, 'fluid_button_fullscreen');
    }
    if (menuOptionFullscreen !== null) {
      menuOptionFullscreen.innerHTML = 'Fullscreen';
    }
    self.fullscreenMode = false;
  };
  self.fullscreenOn = function (fullscreenButton, menuOptionFullscreen) {
    for (var i = 0; i < fullscreenButton.length; i++) {
      fullscreenButton[i].className = fullscreenButton[i].className.replace(/\bfluid_button_fullscreen\b/g, 'fluid_button_fullscreen_exit');
    }
    if (menuOptionFullscreen !== null) {
      menuOptionFullscreen.innerHTML = self.displayOptions.captions.exitFullscreen;
    }
    self.fullscreenMode = true;
  };
  self.fullscreenToggle = function () {
    self.debugMessage("Toggling Full Screen");
    var videoPlayerTag = self.domRef.player;
    var fullscreenTag = self.domRef.wrapper;
    var requestFullscreenFunctionNames = self.checkFullscreenSupport();
    var fullscreenButton = videoPlayerTag.parentNode.getElementsByClassName('fluid_control_fullscreen');
    var menuOptionFullscreen = fullscreenTag.querySelector('.context_option_fullscreen');
    self.resetDisplayMode('fullScreen');
    var functionNameToExecute;
    if (requestFullscreenFunctionNames) {
      // iOS fullscreen elements are different and so need to be treated separately
      if (requestFullscreenFunctionNames.goFullscreen === 'webkitEnterFullscreen') {
        if (!videoPlayerTag[requestFullscreenFunctionNames.isFullscreen]) {
          functionNameToExecute = 'videoPlayerTag.' + requestFullscreenFunctionNames.goFullscreen + '();';
          self.fullscreenOn(fullscreenButton, menuOptionFullscreen);
          new Function('videoPlayerTag', functionNameToExecute)(videoPlayerTag);
        }
      } else {
        if (document[requestFullscreenFunctionNames.isFullscreen] === null) {
          //Go fullscreen
          functionNameToExecute = 'videoPlayerTag.' + requestFullscreenFunctionNames.goFullscreen + '();';
          self.fullscreenOn(fullscreenButton, menuOptionFullscreen);
        } else {
          //Exit fullscreen
          functionNameToExecute = 'document.' + requestFullscreenFunctionNames.exitFullscreen + '();';
          self.fullscreenOff(fullscreenButton, menuOptionFullscreen);
        }
        new Function('videoPlayerTag', functionNameToExecute)(fullscreenTag);
      }
    } else {
      //The browser does not support the Fullscreen API, so a pseudo-fullscreen implementation is used
      if (fullscreenTag.className.search(/\bpseudo_fullscreen\b/g) !== -1) {
        fullscreenTag.className = fullscreenTag.className.replace(/\bpseudo_fullscreen\b/g, '');
        self.fullscreenOff(fullscreenButton, menuOptionFullscreen);
      } else {
        fullscreenTag.className += ' pseudo_fullscreen';
        self.fullscreenOn(fullscreenButton, menuOptionFullscreen);
      }
    }
    self.resizeVpaidAuto();

    // Listen for fullscreen exit event on safari, as the fullscreen mode uses the native UI in iOS
    self.domRef.player.addEventListener('webkitendfullscreen', function () {
      self.fullscreenOff(fullscreenButton, menuOptionFullscreen);
    });
  };
  self.findClosestParent = function (el, selector) {
    var matchesFn = null;

    // find vendor prefix
    ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'].some(function (fn) {
      if (typeof document.body[fn] == 'function') {
        matchesFn = fn;
        return true;
      }
      return false;
    });
    var parent;

    // Check if the current element matches the selector
    if (el[matchesFn](selector)) {
      return el;
    }

    // traverse parents
    while (el) {
      parent = el.parentElement;
      if (parent && parent[matchesFn](selector)) {
        return parent;
      }
      el = parent;
    }
    return null;
  };
  self.getTranslateX = function (el) {
    var coordinates = null;
    try {
      var results = el.style.transform.match(/translate3d\((-?\d+px,\s?){2}-?\d+px\)/);
      if (results && results.length) {
        coordinates = results[0].replace('translate3d(', '').replace(')', '').replace(/\s/g, '').replace(/px/g, '').split(',');
      }
    } catch (e) {
      coordinates = null;
    }
    return coordinates && coordinates.length === 3 ? parseInt(coordinates[0]) : 0;
  };
  self.getEventOffsetX = function (evt, el) {
    var x = 0;
    var translateX = 0;
    while (el && !isNaN(el.offsetLeft)) {
      translateX = self.getTranslateX(el);
      if (el.tagName === 'BODY') {
        x += el.offsetLeft + el.clientLeft + translateX - (el.scrollLeft || document.documentElement.scrollLeft);
      } else {
        x += el.offsetLeft + el.clientLeft + translateX - el.scrollLeft;
      }
      el = el.offsetParent;
    }
    var eventX;
    if (typeof evt.touches !== 'undefined' && typeof evt.touches[0] !== 'undefined') {
      eventX = evt.touches[0].clientX;
    } else {
      eventX = evt.clientX;
    }
    return eventX - x;
  };
  self.getEventOffsetY = function (evt, el) {
    var fullscreenMultiplier = 1;
    var requestFullscreenFunctionNames = self.checkFullscreenSupport();
    if (requestFullscreenFunctionNames && document[requestFullscreenFunctionNames.isFullscreen]) {
      fullscreenMultiplier = 0;
    }
    var y = 0;
    while (el && !isNaN(el.offsetTop)) {
      if (el.tagName === 'BODY') {
        y += el.offsetTop - (el.scrollTop || document.documentElement.scrollTop) * fullscreenMultiplier;
      } else {
        y += el.offsetTop - el.scrollTop * fullscreenMultiplier;
      }
      el = el.offsetParent;
    }
    return evt.clientY - y;
  };
  self.onProgressbarMouseDown = function (event) {
    self.displayOptions.layoutControls.playPauseAnimation = false;
    // we need an initial position for touchstart events, as mouse up has no offset x for iOS
    var initialPosition;
    if (self.displayOptions.layoutControls.showCardBoardView) {
      initialPosition = self.getEventOffsetX(event, event.target.parentNode);
    } else {
      initialPosition = self.getEventOffsetX(event, self.domRef.wrapper.querySelector('.fluid_controls_progress_container'));
    }
    if (self.isCurrentlyPlayingAd) {
      return;
    }
    self.fluidPseudoPause = true;
    var initiallyPaused = self.domRef.player.paused;
    if (!initiallyPaused) {
      self.domRef.player.pause();
    }
    var shiftTime = function shiftTime(timeBarX) {
      var totalWidth = self.domRef.wrapper.querySelector('.fluid_controls_progress_container').clientWidth;
      if (totalWidth) {
        self.domRef.player.currentTime = self.currentVideoDuration * timeBarX / totalWidth;
      }
      self.hideSuggestedVideos();
    };
    var onProgressbarMouseMove = function onProgressbarMouseMove(event) {
      var currentX = self.getEventOffsetX(event, event.target.parentNode);
      initialPosition = NaN; // mouse up will fire after the move, we don't want to trigger the initial position in the event of iOS
      shiftTime(currentX);
      self.contolProgressbarUpdate();
      self.controlDurationUpdate();
    };
    var onProgressbarMouseUp = function onProgressbarMouseUp(event) {
      document.removeEventListener('mousemove', onProgressbarMouseMove);
      document.removeEventListener('touchmove', onProgressbarMouseMove);
      document.removeEventListener('mouseup', onProgressbarMouseUp);
      document.removeEventListener('touchend', onProgressbarMouseUp);
      var clickedX = self.getEventOffsetX(event, event.target.parentNode);
      if (isNaN(clickedX) && !isNaN(initialPosition)) {
        clickedX = initialPosition;
      }
      if (!isNaN(clickedX)) {
        shiftTime(clickedX);
      }
      if (!initiallyPaused) {
        self.play();
      }

      // Wait till video played then re-enable the animations
      if (self.initialAnimationSet) {
        setTimeout(function () {
          self.displayOptions.layoutControls.playPauseAnimation = self.initialAnimationSet;
        }, 200);
      }
      self.fluidPseudoPause = false;
    };
    document.addEventListener('mouseup', onProgressbarMouseUp);
    document.addEventListener('touchend', onProgressbarMouseUp, {
      passive: true
    });
    document.addEventListener('mousemove', onProgressbarMouseMove);
    document.addEventListener('touchmove', onProgressbarMouseMove, {
      passive: true
    });
  };
  self.onVolumeBarMouseDown = function () {
    var shiftVolume = function shiftVolume(volumeBarX) {
      var totalWidth = self.domRef.controls.volumeContainer.clientWidth;
      if (totalWidth) {
        var newVolume = volumeBarX / totalWidth;
        if (newVolume < 0.05) {
          newVolume = 0;
          self.domRef.player.muted = true;
        } else if (newVolume > 0.95) {
          newVolume = 1;
        }
        if (self.domRef.player.muted && newVolume > 0) {
          self.domRef.player.muted = false;
        }
        self.setVolume(newVolume);
      }
    };
    var onVolumeBarMouseMove = function onVolumeBarMouseMove(event) {
      var currentX = self.getEventOffsetX(event, self.domRef.controls.volumeContainer);
      shiftVolume(currentX);
    };
    var onVolumeBarMouseUp = function onVolumeBarMouseUp(event) {
      document.removeEventListener('mousemove', onVolumeBarMouseMove);
      document.removeEventListener('touchmove', onVolumeBarMouseMove);
      document.removeEventListener('mouseup', onVolumeBarMouseUp);
      document.removeEventListener('touchend', onVolumeBarMouseUp);
      var currentX = self.getEventOffsetX(event, self.domRef.controls.volumeContainer);
      if (!isNaN(currentX)) {
        shiftVolume(currentX);
      }
    };
    document.addEventListener('mouseup', onVolumeBarMouseUp);
    document.addEventListener('touchend', onVolumeBarMouseUp, {
      passive: true
    });
    document.addEventListener('mousemove', onVolumeBarMouseMove);
    document.addEventListener('touchmove', onVolumeBarMouseMove, {
      passive: true
    });
  };
  self.findRoll = function (roll) {
    var ids = [];
    ids.length = 0;
    if (!roll || !self.hasOwnProperty('rollsById')) {
      return;
    }
    for (var key in self.rollsById) {
      if (!self.rollsById.hasOwnProperty(key)) {
        continue;
      }
      if (self.rollsById[key].roll === roll) {
        ids.push(key);
      }
    }
    return ids;
  };
  self.onKeyboardVolumeChange = function (direction) {
    var volume = self.domRef.player.volume;
    if ('asc' === direction) {
      volume += 0.05;
    } else if ('desc' === direction) {
      volume -= 0.05;
    }
    if (volume < 0.05) {
      volume = 0;
    } else if (volume > 0.95) {
      volume = 1;
    }
    self.setVolume(volume);
  };
  self.onKeyboardSeekPosition = function (keyCode) {
    if (self.isCurrentlyPlayingAd) {
      return;
    }
    self.domRef.player.currentTime = self.getNewCurrentTimeValueByKeyCode(keyCode, self.domRef.player.currentTime, self.domRef.player.duration);
  };
  self.getNewCurrentTimeValueByKeyCode = function (keyCode, currentTime, duration) {
    var newCurrentTime = currentTime;
    switch (keyCode) {
      case 35:
        //End
        newCurrentTime = duration;
        break;
      case 36:
        //Home
        newCurrentTime = 0;
        break;
      case 48: //0
      case 49: //1
      case 50: //2
      case 51: //3
      case 52: //4
      case 53: //5
      case 54: //6
      case 55: //7
      case 56: //8
      case 57:
        //9
        if (keyCode < 58 && keyCode > 47) {
          var percent = (keyCode - 48) * 10;
          newCurrentTime = duration * percent / 100;
        }
        break;
    }
    return newCurrentTime;
  };
  self.handleMouseleave = function (event) {
    if (typeof event.clientX !== 'undefined' && self.domRef.wrapper.contains(document.elementFromPoint(event.clientX, event.clientY))) {
      //false positive; we didn't actually leave the player
      return;
    }
    self.hideControlBar();
    self.hideTitle();
  };
  self.handleMouseenterForKeyboard = function () {
    if (self.captureKey) {
      return;
    }
    self.captureKey = function (event) {
      event.stopPropagation();
      var keyCode = event.keyCode;
      switch (keyCode) {
        case 70:
          //f
          self.fullscreenToggle();
          event.preventDefault();
          break;
        case 13: //Enter
        case 32:
          //Space
          self.playPauseToggle();
          event.preventDefault();
          break;
        case 77:
          //m
          self.muteToggle();
          event.preventDefault();
          break;
        case 38:
          //up arrow
          self.onKeyboardVolumeChange('asc');
          event.preventDefault();
          break;
        case 40:
          //down arrow
          self.onKeyboardVolumeChange('desc');
          event.preventDefault();
          break;
        case 37:
          //left arrow
          self.skipRelative(-self.timeSkipOffsetAmount);
          break;
        case 39:
          //right arrow
          self.skipRelative(self.timeSkipOffsetAmount);
          break;
        case 35: //End
        case 36: //Home
        case 48: //0
        case 49: //1
        case 50: //2
        case 51: //3
        case 52: //4
        case 53: //5
        case 54: //6
        case 55: //7
        case 56: //8
        case 57:
          //9
          self.onKeyboardSeekPosition(keyCode);
          event.preventDefault();
          break;
        case 73:
          // i
          self.toggleMiniPlayer(undefined, true);
          break;
      }
      return false;
    };
    document.addEventListener('keydown', self.captureKey, true);
  };
  self.keyboardControl = function () {
    self.domRef.wrapper.addEventListener('click', self.handleMouseenterForKeyboard, false);

    // When we click outside player, we stop registering keyboard events
    var clickHandler = self.handleWindowClick.bind(self);
    self.destructors.push(function () {
      window.removeEventListener('click', clickHandler);
    });
    window.addEventListener('click', clickHandler);
  };
  self.handleWindowClick = function (e) {
    if (!self.domRef.wrapper) {
      console.warn('Dangling click event listener should be collected for unknown wrapper.' + 'Did you forget to call destroy on player instance?');
      return;
    }
    var inScopeClick = self.domRef.wrapper.contains(e.target) || e.target.classList.contains('.js-skipHref');
    if (inScopeClick) {
      return;
    }
    document.removeEventListener('keydown', self.captureKey, true);
    delete self['captureKey'];
    if (self.theatreMode && !self.theatreModeAdvanced) {
      self.theatreToggle();
    }
  };
  self.initialPlay = function () {
    self.domRef.player.addEventListener('playing', function () {
      self.toggleLoader(false);
    });
    self.domRef.player.addEventListener('timeupdate', function () {
      // some places we are manually displaying toggleLoader
      // user experience toggleLoader being displayed even when content is playing in background
      self.toggleLoader(false);
    });
    self.domRef.player.addEventListener('waiting', function () {
      self.toggleLoader(true);
    });
    if (!self.displayOptions.layoutControls.playButtonShowing) {
      // Controls always showing until the video is first played
      var initialControlsDisplay = self.domRef.wrapper.querySelector('.fluid_controls_container');
      initialControlsDisplay.classList.remove('initial_controls_show');
      // The logo shows before playing but may need to be removed
      var fpPlayer = self.domRef.wrapper.querySelector('.logo_holder');
      if (fpPlayer) {
        fpPlayer.classList.remove('initial_controls_show');
      }
    }
    if (!self.firstPlayLaunched) {
      self.playPauseToggle();
      self.domRef.player.removeEventListener('play', self.initialPlay);
    }
  };
  self.playPauseToggle = function () {
    self.hideSuggestedVideos();
    var isFirstStart = !self.firstPlayLaunched;
    var preRolls = self.findRoll('preRoll');
    if (!isFirstStart || preRolls.length === 0) {
      if (isFirstStart && preRolls.length === 0) {
        self.firstPlayLaunched = true;
        self.displayOptions.vastOptions.vastAdvanced.noVastVideoCallback();
      }
      if (self.domRef.player.paused) {
        if (self.isCurrentlyPlayingAd && self.vastOptions !== null && self.vastOptions.vpaid) {
          // resume the vpaid linear ad
          self.resumeVpaidAd();
        } else {
          // Check if video has ended. If so, replay
          if (Math.floor(self.currentVideoDuration) === Math.floor(self.domRef.player.currentTime)) {
            self.initialiseStreamers();
            self.domRef.player.currentTime = 0;
          }

          // resume the regular linear vast or content video player
          if (self.dashPlayer) {
            self.dashPlayer.play();
          } else {
            self.domRef.player.play();
          }
        }
        self.playPauseAnimationToggle(true);
      } else if (!isFirstStart) {
        if (self.isCurrentlyPlayingAd && self.vastOptions !== null && self.vastOptions.vpaid) {
          // pause the vpaid linear ad
          self.pauseVpaidAd();
        } else {
          // pause the regular linear vast or content video player
          self.domRef.player.pause();
        }
        self.playPauseAnimationToggle(false);
      }
      self.toggleOnPauseAd();
    } else {
      self.isCurrentlyPlayingAd = true;

      // Workaround for Safari or Mobile Chrome - otherwise it blocks the subsequent
      // play() command, because it considers it not being triggered by the user.
      // The URL is hardcoded here to cover widest possible use cases.
      // If you know of an alternative workaround for this issue - let us know!
      var browserVersion = self.getBrowserVersion();
      var isChromeAndroid = self.mobileInfo.userOs !== false && self.mobileInfo.userOs === 'Android' && browserVersion.browserName === 'Google Chrome';
      if ('Safari' === browserVersion.browserName || isChromeAndroid) {
        self.domRef.player.src = 'https://cdn.fluidplayer.com/static/blank.mp4';
        self.domRef.player.play();
        self.playPauseAnimationToggle(true);
      }
      self.firstPlayLaunched = true;

      //trigger the loading of the VAST Tag
      self.prepareVast('preRoll');
      self.preRollAdPodsLength = preRolls.length;
    }
    var prepareVastAdsThatKnowDuration = function prepareVastAdsThatKnowDuration() {
      self.prepareVast('onPauseRoll');
      self.scheduleOnDemandRolls();
    };
    if (isFirstStart) {
      // Remove the div that was placed as a fix for poster image and DASH streaming, if it exists
      var pseudoPoster = self.domRef.wrapper.querySelector('.fluid_pseudo_poster');
      if (pseudoPoster) {
        pseudoPoster.parentNode.removeChild(pseudoPoster);
      }
      if (self.mainVideoDuration > 0) {
        prepareVastAdsThatKnowDuration();
      } else {
        self.domRef.player.addEventListener('mainVideoDurationSet', prepareVastAdsThatKnowDuration);
      }
    }
    self.adTimer();
    var blockOnPause = self.domRef.wrapper.querySelector('.fluid_html_on_pause_container');
    if (blockOnPause && !self.isCurrentlyPlayingAd) {
      if (self.domRef.player.paused) {
        blockOnPause.style.display = 'flex';
      } else {
        blockOnPause.style.display = 'none';
      }
    }
  };
  self.setCustomControls = function () {
    //Set the Play/Pause behaviour
    self.trackEvent(self.domRef.player.parentNode, 'click', '.fluid_control_playpause', function () {
      if (!self.firstPlayLaunched) {
        self.domRef.player.removeEventListener('play', self.initialPlay);
      }
      self.playPauseToggle();
    }, false);
    self.domRef.player.addEventListener('play', function () {
      self.controlPlayPauseToggle();
      self.contolVolumebarUpdate();
    }, false);
    self.domRef.player.addEventListener('fluidplayerpause', function () {
      self.controlPlayPauseToggle();
    }, false);

    //Set the progressbar
    self.domRef.player.addEventListener('timeupdate', function () {
      self.contolProgressbarUpdate();
      self.controlDurationUpdate();
    });
    var isMobileChecks = self.getMobileOs();
    var eventOn = isMobileChecks.userOs ? 'touchstart' : 'mousedown';
    if (self.displayOptions.layoutControls.showCardBoardView) {
      self.trackEvent(self.domRef.player.parentNode, eventOn, '.fluid_controls_progress_container', function (event) {
        return self.onProgressbarMouseDown(event);
      }, false);
    } else {
      self.domRef.wrapper.querySelector('.fluid_controls_progress_container').addEventListener(eventOn, function (event) {
        return self.onProgressbarMouseDown(event);
      }, {
        passive: true
      });
    }

    //Set the volume controls
    self.domRef.wrapper.querySelector('.fluid_control_volume_container').addEventListener(eventOn, function (event) {
      return self.onVolumeBarMouseDown();
    }, {
      passive: true
    });
    self.domRef.player.addEventListener('volumechange', function () {
      return self.contolVolumebarUpdate();
    });
    self.trackEvent(self.domRef.player.parentNode, 'click', '.fluid_control_mute', function () {
      return self.muteToggle();
    });
    self.setBuffering();

    //Set the fullscreen control
    self.trackEvent(self.domRef.player.parentNode, 'click', '.fluid_control_fullscreen', function () {
      return self.fullscreenToggle();
    });

    // Theatre mode
    if (self.displayOptions.layoutControls.allowTheatre && !self.isInIframe) {
      self.domRef.wrapper.querySelector('.fluid_control_theatre').style.display = 'inline-block';
      self.trackEvent(self.domRef.player.parentNode, 'click', '.fluid_control_theatre', function () {
        return self.theatreToggle();
      });
    } else {
      self.domRef.wrapper.querySelector('.fluid_control_theatre').style.display = 'none';
    }

    // Mini Player
    if (self.displayOptions.layoutControls.miniPlayer.enabled && !self.isInIframe) {
      self.trackEvent(self.domRef.player.parentNode, 'click', '.fluid_control_mini_player', function () {
        return self.toggleMiniPlayer(undefined, true);
      });
    }
    self.domRef.player.addEventListener('ratechange', function () {
      if (self.isCurrentlyPlayingAd) {
        self.playbackRate = 1;
      }
    });
  };

  // Create the time position preview only if the vtt previews aren't enabled
  self.createTimePositionPreview = function () {
    if (!self.showTimeOnHover) {
      return;
    }
    var progressContainer = self.domRef.wrapper.querySelector('.fluid_controls_progress_container');
    var previewContainer = document.createElement('div');
    previewContainer.className = 'fluid_timeline_preview';
    previewContainer.style.display = 'none';
    previewContainer.style.position = 'absolute';
    progressContainer.appendChild(previewContainer);

    // Set up hover for time position preview display
    self.domRef.wrapper.querySelector('.fluid_controls_progress_container').addEventListener('mousemove', function (event) {
      var progressContainer = self.domRef.wrapper.querySelector('.fluid_controls_progress_container');
      var totalWidth = progressContainer.clientWidth;
      var hoverTimeItem = self.domRef.wrapper.querySelector('.fluid_timeline_preview');
      var hoverQ = self.getEventOffsetX(event, progressContainer);
      var hoverSecondQ = self.currentVideoDuration * hoverQ / totalWidth;
      hoverTimeItem.innerText = self.formatTime(hoverSecondQ);
      hoverTimeItem.style.display = 'block';
      hoverTimeItem.style.left = hoverSecondQ / self.domRef.player.duration * 100 + "%";
    }, false);

    // Hide timeline preview on mouseout
    self.domRef.wrapper.querySelector('.fluid_controls_progress_container').addEventListener('mouseout', function () {
      var hoverTimeItem = self.domRef.wrapper.querySelector('.fluid_timeline_preview');
      hoverTimeItem.style.display = 'none';
    }, false);
  };
  self.setCustomContextMenu = function () {
    var playerWrapper = self.domRef.wrapper;
    var showDefaultControls = self.displayOptions.layoutControls.contextMenu.controls;
    var extraLinks = self.displayOptions.layoutControls.contextMenu.links;

    //Create own context menu
    var divContextMenu = document.createElement('div');
    divContextMenu.className = 'fluid_context_menu';
    divContextMenu.style.display = 'none';
    divContextMenu.style.position = 'absolute';
    var contextMenuList = document.createElement('ul');
    divContextMenu.appendChild(contextMenuList);
    if (Array.isArray(extraLinks)) {
      extraLinks.forEach(function appendExtraLinks(link, index) {
        var linkItem = document.createElement('li');
        linkItem.innerHTML = link.label;
        linkItem.addEventListener('click', function () {
          return window.open(link.href, '_blank');
        }, false);
        contextMenuList.appendChild(linkItem);
      });
    }
    if (showDefaultControls) {
      var menuItemPlay = document.createElement('li');
      menuItemPlay.className = 'context_option_play';
      menuItemPlay.innerHTML = self.displayOptions.captions.play;
      menuItemPlay.addEventListener('click', function () {
        return self.playPauseToggle();
      }, false);
      contextMenuList.appendChild(menuItemPlay);
      var menuItemMute = document.createElement('li');
      menuItemMute.className = 'context_option_mute';
      menuItemMute.innerHTML = self.displayOptions.captions.mute;
      menuItemMute.addEventListener('click', function () {
        return self.muteToggle();
      }, false);
      contextMenuList.appendChild(menuItemMute);
      var menuItemFullscreen = document.createElement('li');
      menuItemFullscreen.className = 'context_option_fullscreen';
      menuItemFullscreen.innerHTML = self.displayOptions.captions.fullscreen;
      menuItemFullscreen.addEventListener('click', function () {
        return self.fullscreenToggle();
      }, false);
      contextMenuList.appendChild(menuItemFullscreen);
    }
    var menuItemVersion = document.createElement('li');
    menuItemVersion.innerHTML = 'Fluid Player ' + self.version;
    menuItemVersion.addEventListener('click', function () {
      return window.open(self.homepage, '_blank');
    }, false);
    contextMenuList.appendChild(menuItemVersion);
    self.domRef.player.parentNode.insertBefore(divContextMenu, self.domRef.player.nextSibling);

    //Disable the default context menu
    playerWrapper.addEventListener('contextmenu', function (e) {
      e.preventDefault();
      divContextMenu.style.left = self.getEventOffsetX(e, self.domRef.player) + 'px';
      divContextMenu.style.top = self.getEventOffsetY(e, self.domRef.player) + 'px';
      divContextMenu.style.display = 'block';
    }, false);

    //Hide the context menu on clicking elsewhere
    document.addEventListener('click', function (e) {
      if (e.target !== self.domRef.player || e.button !== 2) {
        divContextMenu.style.display = 'none';
      }
    }, false);
  };
  self.setDefaultLayout = function () {
    self.domRef.wrapper.className += ' fluid_player_layout_' + self.displayOptions.layoutControls.layout;
    self.setCustomContextMenu();
    var controls = self.generateCustomControlTags({
      displayVolumeBar: self.checkShouldDisplayVolumeBar(),
      primaryColor: self.displayOptions.layoutControls.primaryColor ? self.displayOptions.layoutControls.primaryColor : 'red',
      controlForwardBackward: !!self.displayOptions.layoutControls.controlForwardBackward.show,
      miniPlayer: self.displayOptions.layoutControls.miniPlayer
    });

    // Remove the default controls
    self.domRef.player.removeAttribute('controls');

    // Insert custom controls and append loader
    self.domRef.player.parentNode.insertBefore(controls.root, self.domRef.player.nextSibling);
    self.domRef.player.parentNode.insertBefore(controls.loader, self.domRef.player.nextSibling);

    // Register controls locally
    self.domRef.controls = controls;

    /**
     * Set the volumebar after its elements are properly rendered.
     */
    var remainingAttemptsToInitiateVolumeBar = 100;
    var initiateVolumebar = function initiateVolumebar() {
      if (!remainingAttemptsToInitiateVolumeBar) {
        clearInterval(initiateVolumebarTimerId);
      } else if (self.checkIfVolumebarIsRendered()) {
        clearInterval(initiateVolumebarTimerId);
        self.contolVolumebarUpdate();
      } else {
        remainingAttemptsToInitiateVolumeBar--;
      }
    };
    var initiateVolumebarTimerId = setInterval(initiateVolumebar, 100);
    self.destructors.push(function () {
      return clearInterval(initiateVolumebarTimerId);
    });
    if (self.displayOptions.layoutControls.doubleclickFullscreen && !(self.isTouchDevice() || !self.displayOptions.layoutControls.controlForwardBackward.doubleTapMobile)) {
      self.domRef.player.addEventListener('dblclick', self.fullscreenToggle);
    }
    self.initHtmlOnPauseBlock();
    self.setCustomControls();
    self.setupThumbnailPreview();
    self.createTimePositionPreview();
    self.posterImage();
    self.initPlayButton();
    self.setVideoPreload();
    self.createPlaybackList();
    self.createDownload();
    self.toggleMiniPlayerScreenDetection();
    if (!!self.displayOptions.layoutControls.controlForwardBackward.show) {
      self.initSkipControls();
    }
    if (!!self.displayOptions.layoutControls.controlForwardBackward.doubleTapMobile) {
      self.initDoubleTapSkip();
    }
    self.initSkipAnimationElements();
  };
  self.initSkipControls = function () {
    self.domRef.controls.skipBack.addEventListener('click', self.skipRelative.bind(_this, -self.timeSkipOffsetAmount));
    self.domRef.controls.skipForward.addEventListener('click', self.skipRelative.bind(_this, self.timeSkipOffsetAmount));
  };

  /**
   * Creates the skip animation elements and appends them to the player
   *
   * @returns {void}
   */
  self.initSkipAnimationElements = function initSkipAnimationElements() {
    var skipAnimationWrapper = document.createElement('div');
    skipAnimationWrapper.classList.add('fluid_player_skip_offset');
    var skipAnimationBackward = document.createElement('div');
    skipAnimationBackward.classList.add('fluid_player_skip_offset__backward');
    skipAnimationWrapper.appendChild(skipAnimationBackward);
    var skipAnimationBackwardIcon = document.createElement('div');
    skipAnimationBackwardIcon.classList.add('fluid_player_skip_offset__backward-icon');
    skipAnimationBackwardIcon.ontransitionend = function () {
      return skipAnimationBackwardIcon.classList.remove('animate');
    };
    skipAnimationBackward.appendChild(skipAnimationBackwardIcon);
    var skipAnimationForward = document.createElement('div');
    skipAnimationForward.classList.add('fluid_player_skip_offset__forward');
    skipAnimationWrapper.appendChild(skipAnimationForward);
    var skipAnimationForwardIcon = document.createElement('div');
    skipAnimationForwardIcon.classList.add('fluid_player_skip_offset__forward-icon');
    skipAnimationForwardIcon.ontransitionend = function () {
      return skipAnimationForwardIcon.classList.remove('animate');
    };
    skipAnimationForward.appendChild(skipAnimationForwardIcon);
    self.domRef.player.parentNode.insertBefore(skipAnimationWrapper, self.domRef.player.nextSibling);
  };

  /**
   * Initialises the double tap skip functionality
   */
  self.initDoubleTapSkip = function () {
    var hasDoubleClicked = false;
    var timeouts = [];
    function clearTimeouts() {
      timeouts.forEach(function (timeout) {
        return clearTimeout(timeout);
      });
      timeouts = [];
    }
    self.domRef.player.addEventListener('click', function (event) {
      // Check if it's mobile on the fly and prevent double click skip if it is
      if (!self.isTouchDevice()) {
        return;
      }
      var offsetX = event.offsetX;
      var clientWidth = self.domRef.player.clientWidth;

      // Simulates default behaviour if it's a single click
      timeouts.push(setTimeout(function () {
        hasDoubleClicked = false;
        self.playPauseToggle();
      }, 300));

      // Skips video time if it's a double click
      if (hasDoubleClicked) {
        clearTimeouts();
        hasDoubleClicked = false;
        return self.skipRelative(offsetX < clientWidth / 2 ? -self.timeSkipOffsetAmount : self.timeSkipOffsetAmount);
      }
      hasDoubleClicked = true;
    });
  };

  /**
   * Skips the video time by timeOffset relative to the current video time
   *
   * @param {number} timeOffset
   */
  self.skipRelative = function skipRelative(timeOffset) {
    self.debugMessage('skipping video time by ', timeOffset);
    if (self.isCurrentlyPlayingAd) {
      return;
    }
    var skipTo = self.domRef.player.currentTime + timeOffset;
    if (skipTo < 0) {
      skipTo = 0;
    }
    self.domRef.player.currentTime = skipTo;

    // Trigger animation
    if (timeOffset >= 0) {
      var forwardElement = self.domRef.wrapper.querySelector(".fluid_player_skip_offset__forward-icon");
      forwardElement.classList.add('animate');
    } else {
      var backwardElement = self.domRef.wrapper.querySelector(".fluid_player_skip_offset__backward-icon");
      backwardElement.classList.add('animate');
    }
  };

  /**
   * Checks if the volumebar is rendered and the styling applied by comparing
   * the width of 2 elements that should look different.
   *
   * @returns Boolean
   */
  self.checkIfVolumebarIsRendered = function () {
    var volumeposTag = self.domRef.wrapper.querySelector('.fluid_control_volume_currentpos');
    var volumebarTotalWidth = self.domRef.wrapper.querySelector('.fluid_control_volume').clientWidth;
    var volumeposTagWidth = volumeposTag.clientWidth;
    return volumeposTagWidth !== volumebarTotalWidth;
  };
  self.setLayout = function () {
    //All other browsers
    if (!self.isTouchDevice()) {
      self.domRef.player.addEventListener('click', function () {
        return self.playPauseToggle();
      }, false);
    }
    //Mobile Safari - because it does not emit a click event on initial click of the video
    self.domRef.player.addEventListener('play', self.initialPlay, false);
    self.setDefaultLayout();
  };
  self.handleFullscreen = function () {
    if (typeof document.vastFullsreenChangeEventListenersAdded !== 'undefined') {
      return;
    }
    ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'msfullscreenchange'].forEach(function (eventType) {
      if (fluidplayer_typeof(document['on' + eventType]) === 'object') {
        document.addEventListener(eventType, function (ev) {
          self.recalculateAdDimensions();
        }, false);
      }
    });
    document.vastFullsreenChangeEventListenersAdded = true;
  };
  self.setupPlayerWrapper = function () {
    var wrapper = document.createElement('div');
    wrapper.id = 'fluid_video_wrapper_' + self.videoPlayerId;
    wrapper.className = self.isTouchDevice() ? 'fluid_video_wrapper mobile' : 'fluid_video_wrapper';

    //Assign the height/width dimensions to the wrapper
    if (self.displayOptions.layoutControls.fillToContainer) {
      wrapper.style.width = '100%';
      wrapper.style.height = '100%';
    } else {
      wrapper.style.height = self.domRef.player.clientHeight + 'px';
      wrapper.style.width = self.domRef.player.clientWidth + 'px';
    }
    self.domRef.player.style.height = '100%';
    self.domRef.player.style.width = '100%';
    self.domRef.player.parentNode.insertBefore(wrapper, self.domRef.player);
    wrapper.appendChild(self.domRef.player);
    return wrapper;
  };
  self.onErrorDetection = function () {
    if (self.domRef.player.networkState === self.domRef.player.NETWORK_NO_SOURCE && self.isCurrentlyPlayingAd) {
      //Probably the video ad file was not loaded successfully
      self.playMainVideoWhenVastFails(401);
    }
  };
  self.createVideoSourceSwitch = function () {
    var initialLoad = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var sources = [];
    var sourcesList = self.domRef.player.querySelectorAll('source');
    [].forEach.call(sourcesList, function (source) {
      if (source.title && source.src) {
        sources.push({
          'title': source.title,
          'url': source.src,
          'isHD': source.getAttribute('data-fluid-hd') != null
        });
      }
    });
    var sourceChangeButton = self.domRef.wrapper.querySelector('.fluid_control_video_source');
    self.videoSources = sources;
    if (self.videoSources.length > 1) {
      sourceChangeButton.style.display = 'inline-block';
    } else {
      sourceChangeButton.style.display = 'none';
    }
    if (self.videoSources.length <= 1) {
      return;
    }
    var appendSourceChange = false;
    var sourceChangeList = document.createElement('div');
    sourceChangeList.className = 'fluid_video_sources_list';
    sourceChangeList.style.display = 'none';
    var firstSource = true;
    var _iterator2 = fluidplayer_createForOfIteratorHelper(self.videoSources),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var source = _step2.value;
        // Fix for issues occurring on iOS with mkv files
        var getTheType = source.url.split(".").pop();
        if (self.mobileInfo.userOs === 'iOS' && getTheType === 'mkv') {
          continue;
        }

        // On suggested videos, if the resolution doesn't exist in the new source list, use the first one in the list
        // This gets overwritten if it's needed by setPersistentSettings()
        if (firstSource && !initialLoad) {
          self.domRef.player.src = source.url;
        }
        var sourceSelected = firstSource ? "source_selected" : "";
        var hdElement = source.isHD ? '<sup style="color:' + self.displayOptions.layoutControls.primaryColor + '" class="fp_hd_source"></sup>' : '';
        firstSource = false;
        var sourceChangeDiv = document.createElement('div');
        sourceChangeDiv.className = 'fluid_video_source_list_item js-source_' + source.title;
        sourceChangeDiv.innerHTML = '<span class="source_button_icon ' + sourceSelected + '"></span>' + source.title + hdElement;
        sourceChangeDiv.addEventListener('click', function (event) {
          event.stopPropagation();
          // While changing source the player size can flash, we want to set the pixel dimensions then back to 100% afterwards
          self.domRef.player.style.width = self.domRef.player.clientWidth + 'px';
          self.domRef.player.style.height = self.domRef.player.clientHeight + 'px';
          var videoChangedTo = this;
          var sourceIcons = self.domRef.wrapper.getElementsByClassName('source_button_icon');
          for (var i = 0; i < sourceIcons.length; i++) {
            sourceIcons[i].className = sourceIcons[i].className.replace('source_selected', '');
          }
          videoChangedTo.firstChild.className += ' source_selected';
          self.videoSources.forEach(function (source) {
            if (source.title === videoChangedTo.innerText.replace(/(\r\n\t|\n|\r\t)/gm, '')) {
              self.setBuffering();
              self.setVideoSource(source.url);
              self.fluidStorage.fluidQuality = source.title;
            }
          });
          self.openCloseVideoSourceSwitch();
        });
        sourceChangeList.appendChild(sourceChangeDiv);
        appendSourceChange = true;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    if (appendSourceChange) {
      sourceChangeButton.appendChild(sourceChangeList);
      // To reset player for suggested videos, in case the event listener already exists
      sourceChangeButton.removeEventListener('click', self.openCloseVideoSourceSwitch);
      sourceChangeButton.addEventListener('click', self.openCloseVideoSourceSwitch);
    } else {
      // Didn't give any source options
      self.domRef.wrapper.querySelector('.fluid_control_video_source').style.display = 'none';
    }
  };
  self.openCloseVideoSourceSwitch = function () {
    var sourceChangeList = self.domRef.wrapper.querySelector('.fluid_video_sources_list');
    if (self.isCurrentlyPlayingAd || self.isShowingSuggestedVideos()) {
      sourceChangeList.style.display = 'none';
      return;
    }
    if (sourceChangeList.style.display !== 'none') {
      sourceChangeList.style.display = 'none';
      return;
    }
    sourceChangeList.style.display = 'block';
    var mouseOut = function mouseOut() {
      sourceChangeList.removeEventListener('mouseleave', mouseOut);
      sourceChangeList.style.display = 'none';
    };
    sourceChangeList.addEventListener('mouseleave', mouseOut);
  };
  self.setVideoSource = function (url) {
    if (self.mobileInfo.userOs === 'iOS' && url.indexOf('.mkv') > 0) {
      console.log('[FP_ERROR] .mkv files not supported by iOS devices.');
      return false;
    }
    if (self.isCurrentlyPlayingAd) {
      self.originalSrc = url;
      return;
    }
    self.isSwitchingSource = true;
    var play = false;
    if (!self.domRef.player.paused) {
      self.domRef.player.pause();
      play = true;
    }
    var currentTime = self.domRef.player.currentTime;
    self.setCurrentTimeAndPlay(currentTime, play);
    self.domRef.player.src = url;
    self.originalSrc = url;
    self.displayOptions.layoutControls.mediaType = self.getCurrentSrcType();
    self.initialiseStreamers();
  };
  self.setCurrentTimeAndPlay = function (newCurrentTime, shouldPlay) {
    var loadedMetadata = function loadedMetadata() {
      self.domRef.player.currentTime = newCurrentTime;
      self.domRef.player.removeEventListener('loadedmetadata', loadedMetadata);
      // Safari ios and mac fix to set currentTime
      if (self.mobileInfo.userOs === 'iOS' || self.getBrowserVersion().browserName.toLowerCase() === 'safari') {
        self.domRef.player.addEventListener('playing', videoPlayStart);
      }
      if (shouldPlay) {
        self.domRef.player.play();
      } else {
        self.domRef.player.pause();
        self.controlPlayPauseToggle();
      }
      self.isSwitchingSource = false;
      self.domRef.player.style.width = '100%';
      self.domRef.player.style.height = '100%';
    };
    var videoPlayStart = function videoPlayStart() {
      self.currentTime = newCurrentTime;
      self.domRef.player.removeEventListener('playing', videoPlayStart);
    };
    self.domRef.player.addEventListener('loadedmetadata', loadedMetadata, false);
    self.domRef.player.load();
  };
  self.initTitle = function () {
    if (!self.displayOptions.layoutControls.title) {
      return;
    }
    var titleHolder = document.createElement('div');
    self.domRef.player.parentNode.insertBefore(titleHolder, null);
    titleHolder.innerHTML += self.displayOptions.layoutControls.title;
    titleHolder.classList.add('fp_title');
  };
  self.hasTitle = function () {
    var title = self.domRef.wrapper.querySelector('.fp_title');
    var titleOption = self.displayOptions.layoutControls.title;
    return title && titleOption != null;
  };
  self.hideTitle = function () {
    var titleHolder = self.domRef.wrapper.querySelector('.fp_title');
    if (!self.hasTitle()) {
      return;
    }
    titleHolder.classList.add('fade_out');
  };
  self.showTitle = function () {
    var titleHolder = self.domRef.wrapper.querySelector('.fp_title');
    if (!self.hasTitle()) {
      return;
    }
    titleHolder.classList.remove('fade_out');
  };
  self.initLogo = function () {
    if (!self.displayOptions.layoutControls.logo.imageUrl) {
      return;
    }

    // Container div for the logo
    // This is to allow for fade in and out logo_maintain_display
    var logoHolder = document.createElement('div');
    logoHolder.className = 'logo_holder';
    if (self.displayOptions.layoutControls.logo.hideWithControls) {
      logoHolder.classList.add('initial_controls_show', 'fp_logo');
    } else {
      logoHolder.classList.add('logo_maintain_display');
    }
    // The logo itself
    var logoImage = document.createElement('img');
    if (self.displayOptions.layoutControls.logo.imageUrl) {
      logoImage.src = self.displayOptions.layoutControls.logo.imageUrl;
    }
    logoImage.style.position = 'absolute';
    logoImage.style.margin = self.displayOptions.layoutControls.logo.imageMargin;
    var logoPosition = self.displayOptions.layoutControls.logo.position.toLowerCase();
    if (logoPosition.indexOf('bottom') !== -1) {
      logoImage.style.bottom = 0;
    } else {
      logoImage.style.top = 0;
    }
    if (logoPosition.indexOf('right') !== -1) {
      logoImage.style.right = 0;
    } else {
      logoImage.style.left = 0;
    }
    if (self.displayOptions.layoutControls.logo.opacity) {
      logoImage.style.opacity = self.displayOptions.layoutControls.logo.opacity;
    }
    if (self.displayOptions.layoutControls.logo.clickUrl !== null) {
      logoImage.style.cursor = 'pointer';
      logoImage.addEventListener('click', function () {
        var win = window.open(self.displayOptions.layoutControls.logo.clickUrl, '_blank');
        win.focus();
      });
    }

    // If a mouseOverImage is provided then we must set up the listeners for it
    if (self.displayOptions.layoutControls.logo.mouseOverImageUrl) {
      logoImage.addEventListener('mouseover', function () {
        logoImage.src = self.displayOptions.layoutControls.logo.mouseOverImageUrl;
      }, false);
      logoImage.addEventListener('mouseout', function () {
        logoImage.src = self.displayOptions.layoutControls.logo.imageUrl;
      }, false);
    }
    self.domRef.player.parentNode.insertBefore(logoHolder, null);
    logoHolder.appendChild(logoImage, null);
  };
  self.initHtmlOnPauseBlock = function () {
    //If onPauseRoll is defined than HtmlOnPauseBlock won't be shown
    if (self.hasValidOnPauseAd()) {
      return;
    }
    if (!self.displayOptions.layoutControls.htmlOnPauseBlock.html) {
      return;
    }
    var containerDiv = document.createElement('div');
    containerDiv.className = 'fluid_html_on_pause_container';
    containerDiv.style.display = 'none';
    containerDiv.innerHTML = self.displayOptions.layoutControls.htmlOnPauseBlock.html;
    containerDiv.onclick = function (event) {
      self.playPauseToggle();
    };
    if (self.displayOptions.layoutControls.htmlOnPauseBlock.width) {
      containerDiv.style.width = self.displayOptions.layoutControls.htmlOnPauseBlock.width + 'px';
    }
    if (self.displayOptions.layoutControls.htmlOnPauseBlock.height) {
      containerDiv.style.height = self.displayOptions.layoutControls.htmlOnPauseBlock.height + 'px';
    }
    self.domRef.player.parentNode.insertBefore(containerDiv, null);
  };

  /**
   * Play button in the middle when the video loads
   */
  self.initPlayButton = function () {
    // Create the html for the play button
    var containerDiv = document.createElement('div');
    containerDiv.className = 'fluid_html_on_pause fluid_initial_play_button_container';
    var backgroundColor = self.displayOptions.layoutControls.primaryColor ? self.displayOptions.layoutControls.primaryColor : "#333333";
    containerDiv.innerHTML = '<div class="fluid_initial_play" style="background-color:' + backgroundColor + '"><div class="fluid_initial_play_button"></div></div>';
    var initPlayEventTypes = ['click', 'touchend'];
    var initPlayFunction = function initPlayFunction() {
      self.playPauseToggle();
      initPlayEventTypes.forEach(function (eventType) {
        return containerDiv.removeEventListener(eventType, initPlayFunction);
      });
    };
    initPlayEventTypes.forEach(function (eventType) {
      return containerDiv.addEventListener(eventType, initPlayFunction);
    });

    // If the user has chosen to not show the play button we'll make it invisible
    // We don't hide altogether because animations might still be used
    if (!self.displayOptions.layoutControls.playButtonShowing) {
      var initialControlsDisplay = self.domRef.wrapper.querySelector('.fluid_controls_container');
      initialControlsDisplay.classList.add('initial_controls_show');
      containerDiv.style.opacity = '0';
    }
    self.domRef.player.parentNode.insertBefore(containerDiv, null);
  };

  /**
   * Set the mainVideoDuration property one the video is loaded
   */
  self.mainVideoReady = function () {
    if (!(self.mainVideoDuration === 0 && !self.isCurrentlyPlayingAd && self.mainVideoReadyState === false)) {
      return;
    }
    var event = new CustomEvent('mainVideoDurationSet');
    self.mainVideoDuration = self.domRef.player.duration;
    self.mainVideoReadyState = true;
    self.domRef.player.dispatchEvent(event);
    self.domRef.player.removeEventListener('loadedmetadata', self.mainVideoReady);
  };
  self.userActivityChecker = function () {
    var videoPlayer = self.domRef.wrapper;
    self.newActivity = null;
    var isMouseStillDown = false;
    var activity = function activity(event) {
      if (event.type === 'touchstart' || event.type === 'mousedown') {
        isMouseStillDown = true;
      }
      if (event.type === 'touchend' || event.type === 'mouseup') {
        isMouseStillDown = false;
      }
      self.newActivity = true;
    };
    var intervalId = setInterval(function () {
      if (self.newActivity !== true) {
        return;
      }
      if (!isMouseStillDown && !self.isLoading) {
        self.newActivity = false;
      }
      if (self.isUserActive === false || !self.isControlBarVisible()) {
        var event = new CustomEvent('userActive');
        self.domRef.player.dispatchEvent(event);
        self.isUserActive = true;
      }
      clearTimeout(self.inactivityTimeout);
      self.inactivityTimeout = setTimeout(function () {
        if (self.newActivity === true) {
          clearTimeout(self.inactivityTimeout);
          return;
        }
        self.isUserActive = false;
        var event = new CustomEvent('userInactive');
        self.domRef.player.dispatchEvent(event);
      }, self.displayOptions.layoutControls.controlBar.autoHideTimeout * 1000);
    }, 300);
    self.destructors.push(function () {
      return clearInterval(intervalId);
    });
    var listenTo = self.isTouchDevice() ? ['touchstart', 'touchmove', 'touchend'] : ['mousemove', 'mousedown', 'mouseup'];
    for (var i = 0; i < listenTo.length; i++) {
      videoPlayer.addEventListener(listenTo[i], activity, {
        passive: true
      });
    }
  };
  self.hasControlBar = function () {
    return !!self.domRef.wrapper.querySelector('.fluid_controls_container');
  };
  self.isControlBarVisible = function () {
    if (self.hasControlBar() === false) {
      return false;
    }
    var controlBar = self.domRef.wrapper.querySelector('.fluid_controls_container');
    var style = window.getComputedStyle(controlBar, null);
    return !(style.opacity === 0 || style.visibility === 'hidden');
  };
  self.setVideoPreload = function () {
    self.domRef.player.setAttribute('preload', self.displayOptions.layoutControls.preload);
  };
  self.hideControlBar = function () {
    if (self.isCurrentlyPlayingAd && !self.domRef.player.paused) {
      self.toggleAdCountdown(true);
    }
    self.domRef.player.style.cursor = 'none';

    // handles both VR and Normal condition
    if (!self.hasControlBar()) {
      return;
    }
    var divVastControls = self.domRef.player.parentNode.getElementsByClassName('fluid_controls_container');
    var fpLogo = self.domRef.player.parentNode.getElementsByClassName('fp_logo');
    for (var i = 0; i < divVastControls.length; i++) {
      if (self.displayOptions.layoutControls.controlBar.animated) {
        divVastControls[i].classList.remove('fade_in');
        divVastControls[i].classList.add('fade_out');
      } else {
        divVastControls[i].style.display = 'none';
      }
    }
    if (self.displayOptions.layoutControls.logo.hideWithControls) {
      for (var _i6 = 0; _i6 < fpLogo.length; _i6++) {
        if (self.displayOptions.layoutControls.controlBar.animated) {
          if (fpLogo[_i6]) {
            fpLogo[_i6].classList.remove('fade_in');
            fpLogo[_i6].classList.add('fade_out');
          }
        } else {
          if (fpLogo[_i6]) {
            fpLogo[_i6].style.display = 'none';
          }
        }
      }
    }
  };
  self.showControlBar = function (event) {
    if (self.isCurrentlyPlayingAd && !self.domRef.player.paused) {
      self.toggleAdCountdown(false);
    }
    if (event.type === 'mouseenter' || event.type === 'userActive') {
      self.domRef.player.style.cursor = 'default';
    }
    if (!self.hasControlBar()) {
      return;
    }
    var divVastControls = self.domRef.player.parentNode.getElementsByClassName('fluid_controls_container');
    var fpLogo = self.domRef.player.parentNode.getElementsByClassName('fp_logo');
    for (var i = 0; i < divVastControls.length; i++) {
      if (self.displayOptions.layoutControls.controlBar.animated) {
        divVastControls[i].classList.remove('fade_out');
        divVastControls[i].classList.add('fade_in');
      } else {
        divVastControls[i].style.display = 'block';
      }
    }
    if (self.displayOptions.layoutControls.logo.hideWithControls) {
      for (var _i7 = 0; _i7 < fpLogo.length; _i7++) {
        if (self.displayOptions.layoutControls.controlBar.animated) {
          if (fpLogo[_i7]) {
            fpLogo[_i7].classList.remove('fade_out');
            fpLogo[_i7].classList.add('fade_in');
          }
        } else {
          if (fpLogo[_i7]) {
            fpLogo[_i7].style.display = 'block';
          }
        }
      }
    }
  };
  self.linkControlBarUserActivity = function () {
    self.domRef.player.addEventListener('userInactive', self.hideControlBar);
    self.domRef.player.addEventListener('userInactive', self.hideTitle);
    self.domRef.player.addEventListener('userActive', self.showControlBar);
    self.domRef.player.addEventListener('userActive', self.showTitle);
  };
  self.initMute = function () {
    if (self.displayOptions.layoutControls.mute !== true) {
      return;
    }
    self.domRef.player.volume = 0;
  };
  self.initLoop = function () {
    self.domRef.player.loop = !!self.displayOptions.layoutControls.loop;
  };
  self.setBuffering = function () {
    var progressInterval;
    var bufferBar = self.domRef.player.parentNode.getElementsByClassName('fluid_controls_buffered');
    for (var j = 0; j < bufferBar.length; j++) {
      bufferBar[j].style.width = 0;
    }

    // Buffering
    var logProgress = function logProgress() {
      var duration = self.domRef.player.duration;
      if (duration <= 0) {
        return;
      }
      for (var i = 0; i < self.domRef.player.buffered.length; i++) {
        if (self.domRef.player.buffered.start(self.domRef.player.buffered.length - 1 - i) >= self.domRef.player.currentTime) {
          continue;
        }
        var newBufferLength = self.domRef.player.buffered.end(self.domRef.player.buffered.length - 1 - i) / duration * 100 + "%";
        for (var _j = 0; _j < bufferBar.length; _j++) {
          bufferBar[_j].style.width = newBufferLength;
        }

        // Stop checking for buffering if the video is fully buffered
        if (!!progressInterval && 1 === self.domRef.player.buffered.end(self.domRef.player.buffered.length - 1 - i) / duration) {
          clearInterval(progressInterval);
        }
        break;
      }
    };
    progressInterval = setInterval(logProgress, 500);
    self.destructors.push(function () {
      return clearInterval(progressInterval);
    });
  };
  self.createPlaybackList = function () {
    if (!self.displayOptions.layoutControls.playbackRateEnabled) {
      return;
    }
    var sourceChangeButton = self.domRef.wrapper.querySelector('.fluid_control_playback_rate');
    sourceChangeButton.style.display = 'inline-block';
    var sourceChangeList = document.createElement('div');
    sourceChangeList.className = 'fluid_video_playback_rates';
    sourceChangeList.style.display = 'none';
    if (!Array.isArray(self.displayOptions.layoutControls.controlBar.playbackRates) || self.displayOptions.layoutControls.controlBar.playbackRates.some(function (rate) {
      return typeof rate !== 'string' || Number.isNaN(Number(rate.replace('x', '')));
    })) {
      self.displayOptions.layoutControls.controlBar.playbackRates = ['x2', 'x1.5', 'x1', 'x0.5'];
    }
    self.displayOptions.layoutControls.controlBar.playbackRates.forEach(function (rate) {
      var sourceChangeDiv = document.createElement('div');
      sourceChangeDiv.className = 'fluid_video_playback_rates_item';
      sourceChangeDiv.innerText = rate;
      sourceChangeDiv.addEventListener('click', function (event) {
        event.stopPropagation();
        var playbackRate = this.innerText.replace('x', '');
        self.setPlaybackSpeed(playbackRate);
        self.openCloseVideoPlaybackRate();
      });
      sourceChangeList.appendChild(sourceChangeDiv);
    });
    sourceChangeButton.appendChild(sourceChangeList);
    sourceChangeButton.addEventListener('click', function () {
      self.openCloseVideoPlaybackRate();
    });
  };
  self.openCloseVideoPlaybackRate = function () {
    var sourceChangeList = self.domRef.wrapper.querySelector('.fluid_video_playback_rates');
    if (self.isCurrentlyPlayingAd || 'none' !== sourceChangeList.style.display) {
      sourceChangeList.style.display = 'none';
      return;
    }
    sourceChangeList.style.display = 'block';
    var mouseOut = function mouseOut() {
      sourceChangeList.removeEventListener('mouseleave', mouseOut);
      sourceChangeList.style.display = 'none';
    };
    sourceChangeList.addEventListener('mouseleave', mouseOut);
  };
  self.createDownload = function () {
    var downloadOption = self.domRef.wrapper.querySelector('.fluid_control_download');
    if (!self.displayOptions.layoutControls.allowDownload) {
      return;
    }
    downloadOption.style.display = 'inline-block';
    var downloadClick = document.createElement('a');
    downloadClick.className = 'fp_download_click';
    downloadClick.onclick = function (e) {
      var linkItem = this;
      if (typeof e.stopImmediatePropagation !== 'undefined') {
        e.stopImmediatePropagation();
      }
      setTimeout(function () {
        linkItem.download = '';
        linkItem.href = '';
      }, 100);
    };
    downloadOption.appendChild(downloadClick);
    downloadOption.addEventListener('click', function () {
      var downloadItem = self.domRef.wrapper.querySelector('.fp_download_click');
      downloadItem.download = self.originalSrc;
      downloadItem.href = self.originalSrc;
      downloadClick.click();
    });
  };
  self.theatreToggle = function () {
    self.debugMessage("Toggling Theater Mode");
    if (self.isInIframe) {
      return;
    }

    // Theatre and fullscreen, it's only one or the other
    _this.resetDisplayMode('theaterMode');

    // Advanced Theatre mode if specified
    if (self.displayOptions.layoutControls.theatreAdvanced) {
      var elementForTheatre = self.domRef.wrapper.querySelector("#".concat(self.displayOptions.layoutControls.theatreAdvanced.theatreElement));
      var theatreClassToApply = self.displayOptions.layoutControls.theatreAdvanced.classToApply;
      if (elementForTheatre != null && theatreClassToApply != null) {
        if (!self.theatreMode) {
          elementForTheatre.classList.add(theatreClassToApply);
        } else {
          elementForTheatre.classList.remove(theatreClassToApply);
        }
        self.theatreModeAdvanced = !self.theatreModeAdvanced;
      } else {
        console.log('[FP_ERROR] Theatre mode elements could not be found, defaulting behaviour.');
        // Default overlay behaviour
        self.defaultTheatre();
      }
    } else {
      // Default overlay behaviour
      self.defaultTheatre();
    }

    // Set correct variables
    self.theatreMode = !self.theatreMode;
    self.fluidStorage.fluidTheatre = self.theatreMode;

    // Trigger theatre event
    var theatreEvent = self.theatreMode ? 'theatreModeOn' : 'theatreModeOff';
    var event = document.createEvent('CustomEvent');
    event.initEvent(theatreEvent, false, true);
    self.domRef.player.dispatchEvent(event);
    self.resizeVpaidAuto();
  };
  self.defaultTheatre = function () {
    var videoWrapper = self.domRef.wrapper;
    if (self.theatreMode) {
      videoWrapper.classList.remove('fluid_theatre_mode');
      videoWrapper.style.maxHeight = '';
      videoWrapper.style.marginTop = '';
      videoWrapper.style.left = '';
      videoWrapper.style.right = '';
      videoWrapper.style.position = '';
      if (!self.displayOptions.layoutControls.fillToContainer) {
        videoWrapper.style.width = self.originalWidth + 'px';
        videoWrapper.style.height = self.originalHeight + 'px';
      } else {
        videoWrapper.style.width = '100%';
        videoWrapper.style.height = '100%';
      }
      return;
    }
    videoWrapper.classList.add('fluid_theatre_mode');
    var workingWidth = self.displayOptions.layoutControls.theatreSettings.width;
    var defaultHorizontalMargin = '10px';
    videoWrapper.style.width = workingWidth;
    videoWrapper.style.height = self.displayOptions.layoutControls.theatreSettings.height;
    videoWrapper.style.maxHeight = screen.height + "px";
    videoWrapper.style.marginTop = self.displayOptions.layoutControls.theatreSettings.marginTop + 'px';
    switch (self.displayOptions.layoutControls.theatreSettings.horizontalAlign) {
      case 'center':
        // We must calculate the margin differently based on whether they passed % or px
        if (typeof workingWidth == 'string' && workingWidth.substr(workingWidth.length - 1) === "%") {
          // A margin of half the remaining space
          defaultHorizontalMargin = (100 - parseInt(workingWidth.substring(0, workingWidth.length - 1))) / 2 + "%";
        } else if (typeof workingWidth == 'string' && workingWidth.substr(workingWidth.length - 2) === "px") {
          // Half the (Remaining width / fullwidth)
          defaultHorizontalMargin = (screen.width - parseInt(workingWidth.substring(0, workingWidth.length - 2))) / screen.width * 100 / 2 + "%";
        } else {
          console.log('[FP_ERROR] Theatre width specified invalid.');
        }
        videoWrapper.style.left = defaultHorizontalMargin;
        break;
      case 'right':
        videoWrapper.style.right = defaultHorizontalMargin;
        break;
      case 'left':
      default:
        videoWrapper.style.left = defaultHorizontalMargin;
        break;
    }
  };

  // Set the poster for the video, taken from custom params
  // Cannot use the standard video tag poster image as it can be removed by the persistent settings
  self.posterImage = function () {
    if (!self.displayOptions.layoutControls.posterImage) {
      return;
    }
    var containerDiv = document.createElement('div');
    containerDiv.className = 'fluid_pseudo_poster';
    if (['auto', 'contain', 'cover'].indexOf(self.displayOptions.layoutControls.posterImageSize) === -1) {
      console.log('[FP_ERROR] Not allowed value in posterImageSize');
      return;
    }
    containerDiv.style.background = "url('" + self.displayOptions.layoutControls.posterImage + "') center center / " + self.displayOptions.layoutControls.posterImageSize + " no-repeat black";
    self.domRef.player.parentNode.insertBefore(containerDiv, null);
  };

  // This is called when a media type is unsupported. We'll find the current source and try set the next source if it exists
  self.nextSource = function () {
    var sources = self.domRef.player.getElementsByTagName('source');
    if (!sources.length) {
      return null;
    }
    for (var i = 0; i < sources.length - 1; i++) {
      if (sources[i].getAttribute('src') === self.originalSrc && sources[i + 1].getAttribute('src')) {
        self.setVideoSource(sources[i + 1].getAttribute('src'));
        return;
      }
    }
  };
  self.inIframe = function () {
    try {
      return window.self !== window.top;
    } catch (e) {
      return true;
    }
  };
  self.setPersistentSettings = function () {
    var ignoreMute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    try {
      if (!(typeof Storage !== 'undefined' && typeof localStorage !== 'undefined')) {
        return;
      }
    } catch (e) {
      return;
    }

    // See https://github.com/fluid-player/fluid-player/issues/271
    var testKey = '_fp_storage_enabled',
      storage = localStorage;
    try {
      storage.setItem(testKey, '1');
      storage.removeItem(testKey);
    } catch (error) {
      return false;
    }
    self.fluidStorage = localStorage;
    if (typeof self.fluidStorage.fluidVolume !== 'undefined' && self.displayOptions.layoutControls.persistentSettings.volume && !ignoreMute) {
      self.setVolume(self.fluidStorage.fluidVolume);
      if (typeof self.fluidStorage.fluidMute !== 'undefined' && self.fluidStorage.fluidMute === 'true') {
        self.muteToggle();
      }
    }
    if (typeof self.fluidStorage.fluidQuality !== 'undefined' && self.displayOptions.layoutControls.persistentSettings.quality) {
      var sourceOption = self.domRef.wrapper.querySelector('.js-source_' + self.fluidStorage.fluidQuality);
      var sourceChangeButton = self.domRef.wrapper.querySelector('.fluid_control_video_source');
      if (sourceOption) {
        sourceOption.click();
        sourceChangeButton.click();
      }
    }
    if (typeof self.fluidStorage.fluidSpeed !== 'undefined' && self.displayOptions.layoutControls.persistentSettings.speed) {
      self.setPlaybackSpeed(self.fluidStorage.fluidSpeed);
    }
    if (typeof self.fluidStorage.fluidTheatre !== 'undefined' && self.fluidStorage.fluidTheatre === 'true' && self.displayOptions.layoutControls.persistentSettings.theatre) {
      self.theatreToggle();
    }
  };

  // "API" Functions
  self.play = function () {
    if (!self.domRef.player.paused) {
      return;
    }
    self.playPauseToggle();
    return true;
  };
  self.pause = function () {
    if (!self.domRef.player.paused) {
      self.playPauseToggle();
    }
    return true;
  };
  self.skipTo = function (time) {
    self.domRef.player.currentTime = time;
  };
  self.setPlaybackSpeed = function (speed) {
    if (self.isCurrentlyPlayingAd) {
      return;
    }
    self.domRef.player.playbackRate = speed;
    self.fluidStorage.fluidSpeed = speed;
  };
  self.setVolume = function (passedVolume) {
    self.domRef.player.volume = passedVolume;

    // If user scrolls to volume 0, we should not store 0 as
    // latest volume - there is a property called "muted" already
    // and storing 0 will break the toggle.
    // In case user scrolls to 0 we assume last volume to be 1
    // for toggle.
    var latestVolume = 0 === passedVolume ? 1 : passedVolume;
    self.latestVolume = latestVolume;
    self.fluidStorage.fluidVolume = latestVolume;
  };
  self.isCurrentlyPlayingVideo = function (instance) {
    return instance && instance.currentTime > 0 && !instance.paused && !instance.ended && instance.readyState > 2;
  };
  self.setHtmlOnPauseBlock = function (passedHtml) {
    if (fluidplayer_typeof(passedHtml) != 'object' || typeof passedHtml.html == 'undefined') {
      return false;
    }
    var htmlBlock = self.domRef.wrapper.querySelector('.fluid_html_on_pause_container');

    // We create the HTML block from scratch if it doesn't already exist
    if (!htmlBlock) {
      var containerDiv = document.createElement('div');
      containerDiv.className = 'fluid_html_on_pause';
      containerDiv.style.display = 'none';
      containerDiv.innerHTML = passedHtml.html;
      containerDiv.onclick = function () {
        self.playPauseToggle();
      };
      if (passedHtml.width) {
        containerDiv.style.width = passedHtml.width + 'px';
      }
      if (passedHtml.height) {
        containerDiv.style.height = passedHtml.height + 'px';
      }
      self.domRef.player.parentNode.insertBefore(containerDiv, null);
      return;
    }
    htmlBlock.innerHTML = passedHtml.html;
    if (passedHtml.width) {
      htmlBlock.style.width = passedHtml.width + 'px';
    }
    if (passedHtml.height) {
      htmlBlock.style.height = passedHtml.height + 'px';
    }
  };
  self.toggleControlBar = function (show) {
    var controlBar = self.domRef.wrapper.querySelector('.fluid_controls_container');
    if (show) {
      controlBar.className += ' initial_controls_show';
      return;
    }
    controlBar.className = controlBar.className.replace(' initial_controls_show', '');
  };
  self.on = function (eventCall, callback) {
    /**
     * Improves events by adding player info to the callbacks
     */
    var getAdditionalInfo = function getAdditionalInfo() {
      return {
        mediaSourceType: self.adFinished === false ? 'ad' : 'source'
      };
    };
    var functionCall = function functionCall() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return callback.apply(void 0, args.concat([getAdditionalInfo()]));
    };
    switch (eventCall) {
      case 'play':
        self.domRef.player.onplay = functionCall;
        break;
      case 'seeked':
        self.domRef.player.onseeked = functionCall;
        break;
      case 'ended':
        self.domRef.player.onended = functionCall;
        break;
      case 'pause':
        self.domRef.player.addEventListener('pause', function () {
          if (!self.fluidPseudoPause) {
            functionCall();
          }
        });
        break;
      case 'playing':
        self.domRef.player.addEventListener('playing', functionCall);
        break;
      case 'theatreModeOn':
        self.domRef.player.addEventListener('theatreModeOn', functionCall);
        break;
      case 'theatreModeOff':
        self.domRef.player.addEventListener('theatreModeOff', functionCall);
        break;
      case 'timeupdate':
        self.domRef.player.addEventListener('timeupdate', function () {
          functionCall(self.getCurrentTime());
        });
        break;
      case 'miniPlayerToggle':
        self.domRef.player.addEventListener('miniPlayerToggle', functionCall);
        break;
      default:
        console.log('[FP_ERROR] Event not recognised');
        break;
    }
  };
  self.toggleLogo = function (logo) {
    if (fluidplayer_typeof(logo) != 'object' || !logo.imageUrl) {
      return false;
    }
    var logoBlock = self.domRef.wrapper.querySelector('.fp_logo');

    // We create the logo from scratch if it doesn't already exist, they might not give everything correctly so we
    self.displayOptions.layoutControls.logo.imageUrl = logo.imageUrl ? logo.imageUrl : null;
    self.displayOptions.layoutControls.logo.position = logo.position ? logo.position : 'top left';
    self.displayOptions.layoutControls.logo.clickUrl = logo.clickUrl ? logo.clickUrl : null;
    self.displayOptions.layoutControls.logo.opacity = logo.opacity ? logo.opacity : 1;
    self.displayOptions.layoutControls.logo.mouseOverImageUrl = logo.mouseOverImageUrl ? logo.mouseOverImageUrl : null;
    self.displayOptions.layoutControls.logo.imageMargin = logo.imageMargin ? logo.imageMargin : '2px';
    self.displayOptions.layoutControls.logo.hideWithControls = logo.hideWithControls ? logo.hideWithControls : false;
    self.displayOptions.layoutControls.logo.showOverAds = logo.showOverAds ? logo.showOverAds : false;
    if (logoBlock) {
      logoBlock.remove();
    }
    self.initLogo();
  };

  // this functions helps in adding event listeners for future dynamic elements
  // trackEvent(document, "click", ".some_elem", callBackFunction);
  self.trackEvent = function (el, evt, sel, handler) {
    if (typeof self.events[sel] === 'undefined') {
      self.events[sel] = {};
    }
    if (typeof self.events[sel][evt] === 'undefined') {
      self.events[sel][evt] = [];
    }
    self.events[sel][evt].push(handler);
    self.registerListener(el, evt, sel, handler);
  };
  self.registerListener = function (el, evt, sel, handler) {
    var currentElements = el.querySelectorAll(sel);
    for (var i = 0; i < currentElements.length; i++) {
      currentElements[i].addEventListener(evt, handler);
    }
  };
  self.copyEvents = function (topLevelEl) {
    for (var sel in self.events) {
      if (!self.events.hasOwnProperty(sel)) {
        continue;
      }
      for (var evt in self.events[sel]) {
        if (!self.events[sel].hasOwnProperty(evt)) {
          continue;
        }
        for (var i = 0; i < self.events[sel][evt].length; i++) {
          self.registerListener(topLevelEl, evt, sel, self.events[sel][evt][i]);
        }
      }
    }
  };

  /**
   * Resets all display types that are not the target display mode
   *
   * @param {'fullScreen'|'theaterMode'|'miniPlayer'} displayTarget
   */
  self.resetDisplayMode = function (displayTarget) {
    if (self.fullscreenMode && displayTarget !== 'fullScreen') {
      self.fullscreenToggle();
    }
    if (self.theatreMode && displayTarget !== 'theaterMode') {
      self.theatreToggle();
    }
    if (self.miniPlayerToggledOn && displayTarget !== 'miniPlayer') {
      self.toggleMiniPlayer('off');
    }
  };
  self.destroy = function () {
    self.domRef.player.classList.remove('js-fluid-player');
    var numDestructors = self.destructors.length;
    if (0 === numDestructors) {
      return;
    }
    self.destructors.forEach(function (destructor) {
      return destructor.call(self);
    });
    var container = self.domRef.wrapper;
    if (!container) {
      console.warn('Unable to remove wrapper element for Fluid Player instance - element not found');
      return;
    }
    if ('function' === typeof container.remove) {
      container.remove();
      return;
    }
    if (container.parentNode) {
      container.parentNode.removeChild(container);
      return;
    }
    console.error('Unable to remove wrapper element for Fluid Player instance - no parent');
  };
};

/**
 * Public Fluid Player API interface
 * @param instance
 */
var fluidPlayerInterface = function fluidPlayerInterface(instance) {
  this.play = function () {
    return instance.play();
  };
  this.pause = function () {
    return instance.pause();
  };
  this.skipTo = function (position) {
    return instance.skipTo(position);
  };
  this.setPlaybackSpeed = function (speed) {
    return instance.setPlaybackSpeed(speed);
  };
  this.setVolume = function (volume) {
    return instance.setVolume(volume);
  };
  this.setHtmlOnPauseBlock = function (options) {
    return instance.setHtmlOnPauseBlock(options);
  };
  this.toggleControlBar = function (state) {
    return instance.toggleControlBar(state);
  };
  this.toggleFullScreen = function (state) {
    return instance.fullscreenToggle(state);
  };
  this.toggleMiniPlayer = function (state) {
    if (state === undefined) {
      state = !instance.miniPlayerToggledOn;
    }
    return instance.toggleMiniPlayer(state ? 'on' : 'off', true);
  };
  this.destroy = function () {
    return instance.destroy();
  };
  this.dashInstance = function () {
    return !!instance.dashPlayer ? instance.dashPlayer : null;
  };
  this.hlsInstance = function () {
    return !!instance.hlsPlayer ? instance.hlsPlayer : null;
  };
  this.on = function (event, callback) {
    return instance.on(event, callback);
  };
  this.setDebug = function (value) {
    instance.displayOptions.debug = value;
  };
};

/**
 * Initialize and attach Fluid Player to instance of HTMLVideoElement
 *
 * @param target ID of HTMLVideoElement or reference to HTMLVideoElement
 * @param options Fluid Player configuration options
 * @returns {fluidPlayerInterface}
 */
var fluidPlayerInitializer = function fluidPlayerInitializer(target, options) {
  var instance = new fluidPlayerClass();
  if (!options) {
    options = {};
  }
  instance.init(target, options);
  var publicInstance = new fluidPlayerInterface(instance);
  if (window && FP_DEVELOPMENT_MODE) {
    var debugApi = {
      id: target,
      options: options,
      instance: publicInstance,
      internals: instance
    };
    if (typeof window.fluidPlayerDebug === 'undefined') {
      window.fluidPlayerDebug = [];
    }
    window.fluidPlayerDebug.push(debugApi);
    console.log('Created instance of Fluid Player. ' + 'Debug API available at window.fluidPlayerDebug[' + (window.fluidPlayerDebug.length - 1) + '].', debugApi);
  }
  return publicInstance;
};
if (FP_DEVELOPMENT_MODE) {
  console.log('Fluid Player - Development Build' + (FP_RUNTIME_DEBUG ? ' (in debug mode)' : ''));
}
/* harmony default export */ var fluidplayer = (fluidPlayerInitializer);
;// CONCATENATED MODULE: ./src/index.js
if (false) {}
if (false) {}
if (false) { var isLocalhost; }
if (false) {}


/* harmony default export */ var src = (fluidplayer);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(379);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(795);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(569);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(565);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(216);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(589);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./src/css/fluidplayer.css
var css_fluidplayer = __webpack_require__(410);
;// CONCATENATED MODULE: ./src/css/fluidplayer.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(css_fluidplayer/* default */.Z, options);




       /* harmony default export */ var src_css_fluidplayer = (css_fluidplayer/* default */.Z && css_fluidplayer/* default.locals */.Z.locals ? css_fluidplayer/* default.locals */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/browser.js
/**
 * Build entry point for CDN builds.
 * You SHOULD NOT import this file except if you plan to build browser distribution of Fluid Player.
 */



// Import CSS automatically in browser builds.

if (window) {
  /**
   * Register public interface.
   */
  if (!window.fluidPlayer) {
    window.fluidPlayer = src;
  }
}
}();
/******/ })()
;
